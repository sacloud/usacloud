// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cli

import (
	"encoding/json"
	"fmt"
	"strings"
	"sync"

	"github.com/imdario/mergo"
	"github.com/sacloud/libsacloud/sacloud"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/schema"
	"gopkg.in/urfave/cli.v2"
)

func init() {
	serverListParam := params.NewListServerParam()
	serverBuildParam := params.NewBuildServerParam()
	serverReadParam := params.NewReadServerParam()
	serverUpdateParam := params.NewUpdateServerParam()
	serverDeleteParam := params.NewDeleteServerParam()
	serverPlanChangeParam := params.NewPlanChangeServerParam()
	serverBootParam := params.NewBootServerParam()
	serverShutdownParam := params.NewShutdownServerParam()
	serverShutdownForceParam := params.NewShutdownForceServerParam()
	serverResetParam := params.NewResetServerParam()
	serverWaitForBootParam := params.NewWaitForBootServerParam()
	serverWaitForDownParam := params.NewWaitForDownServerParam()
	serverSSHParam := params.NewSSHServerParam()
	serverSSHExecParam := params.NewSSHExecServerParam()
	serverScpParam := params.NewScpServerParam()
	serverVncParam := params.NewVncServerParam()
	serverVncInfoParam := params.NewVncInfoServerParam()
	serverVncSendParam := params.NewVncSendServerParam()
	serverVncSnapshotParam := params.NewVncSnapshotServerParam()
	serverRemoteDesktopParam := params.NewRemoteDesktopServerParam()
	serverRemoteDesktopInfoParam := params.NewRemoteDesktopInfoServerParam()
	serverDiskInfoParam := params.NewDiskInfoServerParam()
	serverDiskConnectParam := params.NewDiskConnectServerParam()
	serverDiskDisconnectParam := params.NewDiskDisconnectServerParam()
	serverInterfaceInfoParam := params.NewInterfaceInfoServerParam()
	serverInterfaceAddForInternetParam := params.NewInterfaceAddForInternetServerParam()
	serverInterfaceAddForRouterParam := params.NewInterfaceAddForRouterServerParam()
	serverInterfaceAddForSwitchParam := params.NewInterfaceAddForSwitchServerParam()
	serverInterfaceAddDisconnectedParam := params.NewInterfaceAddDisconnectedServerParam()
	serverISOInfoParam := params.NewISOInfoServerParam()
	serverISOInsertParam := params.NewISOInsertServerParam()
	serverISOEjectParam := params.NewISOEjectServerParam()
	serverMonitorCPUParam := params.NewMonitorCPUServerParam()
	serverMonitorNicParam := params.NewMonitorNicServerParam()
	serverMonitorDiskParam := params.NewMonitorDiskServerParam()
	serverMaintenanceInfoParam := params.NewMaintenanceInfoServerParam()

	cliCommand := &cli.Command{
		Name:  "server",
		Usage: "A manage commands of Server",
		Subcommands: []*cli.Command{
			{
				Name:    "list",
				Aliases: []string{"ls", "find", "selector"},
				Usage:   "List Server",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "name",
						Usage: "set filter by name(s)",
					},
					&cli.Int64SliceFlag{
						Name:  "id",
						Usage: "set filter by id(s)",
					},
					&cli.StringSliceFlag{
						Name:    "tags",
						Aliases: []string{"selector"},
						Usage:   "set filter by tags(AND)",
					},
					&cli.IntFlag{
						Name:    "from",
						Aliases: []string{"offset"},
						Usage:   "set offset",
					},
					&cli.IntFlag{
						Name:    "max",
						Aliases: []string{"limit"},
						Usage:   "set limit",
					},
					&cli.StringSliceFlag{
						Name:  "sort",
						Usage: "set field(s) for sort",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverListParam.ParamTemplate = c.String("param-template")
					serverListParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverListParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewListServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverListParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("name") {
						serverListParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						serverListParam.Id = toSakuraIDs(c.Int64Slice("id"))
					}
					if c.IsSet("tags") {
						serverListParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						serverListParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						serverListParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						serverListParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						serverListParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverListParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverListParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverListParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverListParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverListParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverListParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverListParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverListParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverListParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverListParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverListParam.QueryFile = c.String("query-file")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverListParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverListParam.GenerateSkeleton {
						serverListParam.GenerateSkeleton = false
						serverListParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverListParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverListParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverListParam)

					// Run command with params
					return funcs.ServerList(ctx, serverListParam)

				},
			},
			{
				Name:  "build",
				Usage: "Build Server",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "core",
						Usage: "[Required] set CPU core count",
						Value: 1,
					},
					&cli.IntFlag{
						Name:  "memory",
						Usage: "[Required] set memory size(GB)",
						Value: 1,
					},
					&cli.StringFlag{
						Name:  "commitment",
						Usage: "set plan of core assignment",
						Value: "standard",
					},
					&cli.Int64Flag{
						Name:  "private-host-id",
						Usage: "set private-host-id",
					},
					&cli.StringFlag{
						Name:  "disk-mode",
						Usage: "[Required] disk create mode[create/connect/diskless]",
						Value: "create",
					},
					&cli.StringFlag{
						Name:  "os-type",
						Usage: "set source OS type",
					},
					&cli.StringFlag{
						Name:  "disk-plan",
						Usage: "set disk plan('hdd' or 'ssd')",
						Value: "ssd",
					},
					&cli.StringFlag{
						Name:  "disk-connection",
						Usage: "set disk connection('virtio' or 'ide')",
						Value: "virtio",
					},
					&cli.IntFlag{
						Name:  "disk-size",
						Usage: "set disk size(GB)",
						Value: 20,
					},
					&cli.Int64Flag{
						Name:  "source-archive-id",
						Usage: "set source disk ID",
					},
					&cli.Int64Flag{
						Name:  "source-disk-id",
						Usage: "set source disk ID",
					},
					&cli.Int64SliceFlag{
						Name:  "distant-from",
						Usage: "set distant from disk IDs",
					},
					&cli.Int64Flag{
						Name:  "disk-id",
						Usage: "set connect disk ID",
					},
					&cli.Int64Flag{
						Name:  "iso-image-id",
						Usage: "set iso-image ID",
					},
					&cli.StringFlag{
						Name:  "network-mode",
						Usage: "[Required] network connection mode[shared/switch/disconnect/none]",
						Value: "shared",
					},
					&cli.StringFlag{
						Name:  "interface-driver",
						Usage: "set interface driver[virtio/e1000]",
						Value: "virtio",
					},
					&cli.Int64Flag{
						Name:  "packet-filter-id",
						Usage: "set packet filter ID",
					},
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "set connect switch ID",
					},
					&cli.StringFlag{
						Name:  "hostname",
						Usage: "set hostname",
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "set password",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.BoolFlag{
						Name:    "disable-password-auth",
						Aliases: []string{"disable-pw-auth"},
						Usage:   "disable password auth on SSH",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress  prefix",
						Value:   24,
					},
					&cli.StringFlag{
						Name:    "default-route",
						Aliases: []string{"gateway"},
						Usage:   "set default gateway",
					},
					&cli.StringSliceFlag{
						Name:    "startup-scripts",
						Aliases: []string{"notes"},
						Usage:   "set startup script(s)",
					},
					&cli.Int64SliceFlag{
						Name:    "startup-script-ids",
						Aliases: []string{"note-ids"},
						Usage:   "set startup script ID(s)",
					},
					&cli.BoolFlag{
						Name:  "startup-scripts-ephemeral",
						Usage: "set startup script persist mode",
						Value: true,
					},
					&cli.StringFlag{
						Name:  "ssh-key-mode",
						Usage: "ssh-key mode[none/id/generate/upload]",
					},
					&cli.StringFlag{
						Name:  "ssh-key-name",
						Usage: "set ssh-key name",
					},
					&cli.Int64SliceFlag{
						Name:  "ssh-key-ids",
						Usage: "set ssh-key ID(s)",
					},
					&cli.StringFlag{
						Name:  "ssh-key-pass-phrase",
						Usage: "set ssh-key pass phrase",
					},
					&cli.StringFlag{
						Name:  "ssh-key-description",
						Usage: "set ssh-key description",
					},
					&cli.StringFlag{
						Name:  "ssh-key-private-key-output",
						Usage: "set ssh-key privatekey output path",
					},
					&cli.StringSliceFlag{
						Name:  "ssh-key-public-keys",
						Usage: "set ssh-key public key ",
					},
					&cli.StringSliceFlag{
						Name:  "ssh-key-public-key-files",
						Usage: "set ssh-key public key file",
					},
					&cli.BoolFlag{
						Name:  "ssh-key-ephemeral",
						Usage: "set ssh-key persist mode",
						Value: true,
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "[Required] set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.BoolFlag{
						Name:  "us-keyboard",
						Usage: "use us-keyboard",
					},
					&cli.BoolFlag{
						Name:  "disable-boot-after-create",
						Usage: "boot after create",
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverBuildParam.ParamTemplate = c.String("param-template")
					serverBuildParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverBuildParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBuildServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverBuildParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("core") {
						serverBuildParam.Core = c.Int("core")
					}
					if c.IsSet("memory") {
						serverBuildParam.Memory = c.Int("memory")
					}
					if c.IsSet("commitment") {
						serverBuildParam.Commitment = c.String("commitment")
					}
					if c.IsSet("private-host-id") {
						serverBuildParam.PrivateHostId = sacloud.ID(c.Int64("private-host-id"))
					}
					if c.IsSet("disk-mode") {
						serverBuildParam.DiskMode = c.String("disk-mode")
					}
					if c.IsSet("os-type") {
						serverBuildParam.OsType = c.String("os-type")
					}
					if c.IsSet("disk-plan") {
						serverBuildParam.DiskPlan = c.String("disk-plan")
					}
					if c.IsSet("disk-connection") {
						serverBuildParam.DiskConnection = c.String("disk-connection")
					}
					if c.IsSet("disk-size") {
						serverBuildParam.DiskSize = c.Int("disk-size")
					}
					if c.IsSet("source-archive-id") {
						serverBuildParam.SourceArchiveId = sacloud.ID(c.Int64("source-archive-id"))
					}
					if c.IsSet("source-disk-id") {
						serverBuildParam.SourceDiskId = sacloud.ID(c.Int64("source-disk-id"))
					}
					if c.IsSet("distant-from") {
						serverBuildParam.DistantFrom = toSakuraIDs(c.Int64Slice("distant-from"))
					}
					if c.IsSet("disk-id") {
						serverBuildParam.DiskId = sacloud.ID(c.Int64("disk-id"))
					}
					if c.IsSet("iso-image-id") {
						serverBuildParam.ISOImageId = sacloud.ID(c.Int64("iso-image-id"))
					}
					if c.IsSet("network-mode") {
						serverBuildParam.NetworkMode = c.String("network-mode")
					}
					if c.IsSet("interface-driver") {
						serverBuildParam.InterfaceDriver = c.String("interface-driver")
					}
					if c.IsSet("packet-filter-id") {
						serverBuildParam.PacketFilterId = sacloud.ID(c.Int64("packet-filter-id"))
					}
					if c.IsSet("switch-id") {
						serverBuildParam.SwitchId = sacloud.ID(c.Int64("switch-id"))
					}
					if c.IsSet("hostname") {
						serverBuildParam.Hostname = c.String("hostname")
					}
					if c.IsSet("password") || command.IsEmpty(serverBuildParam.Password) {
						serverBuildParam.Password = c.String("password")
					}
					if c.IsSet("disable-password-auth") {
						serverBuildParam.DisablePasswordAuth = c.Bool("disable-password-auth")
					}
					if c.IsSet("ipaddress") {
						serverBuildParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("nw-masklen") {
						serverBuildParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("default-route") {
						serverBuildParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("startup-scripts") {
						serverBuildParam.StartupScripts = c.StringSlice("startup-scripts")
					}
					if c.IsSet("startup-script-ids") {
						serverBuildParam.StartupScriptIds = toSakuraIDs(c.Int64Slice("startup-script-ids"))
					}
					if c.IsSet("startup-scripts-ephemeral") {
						serverBuildParam.StartupScriptsEphemeral = c.Bool("startup-scripts-ephemeral")
					}
					if c.IsSet("ssh-key-mode") {
						serverBuildParam.SSHKeyMode = c.String("ssh-key-mode")
					}
					if c.IsSet("ssh-key-name") {
						serverBuildParam.SSHKeyName = c.String("ssh-key-name")
					}
					if c.IsSet("ssh-key-ids") {
						serverBuildParam.SSHKeyIds = toSakuraIDs(c.Int64Slice("ssh-key-ids"))
					}
					if c.IsSet("ssh-key-pass-phrase") {
						serverBuildParam.SSHKeyPassPhrase = c.String("ssh-key-pass-phrase")
					}
					if c.IsSet("ssh-key-description") {
						serverBuildParam.SSHKeyDescription = c.String("ssh-key-description")
					}
					if c.IsSet("ssh-key-private-key-output") {
						serverBuildParam.SSHKeyPrivateKeyOutput = c.String("ssh-key-private-key-output")
					}
					if c.IsSet("ssh-key-public-keys") {
						serverBuildParam.SSHKeyPublicKeys = c.StringSlice("ssh-key-public-keys")
					}
					if c.IsSet("ssh-key-public-key-files") {
						serverBuildParam.SSHKeyPublicKeyFiles = c.StringSlice("ssh-key-public-key-files")
					}
					if c.IsSet("ssh-key-ephemeral") {
						serverBuildParam.SSHKeyEphemeral = c.Bool("ssh-key-ephemeral")
					}
					if c.IsSet("name") {
						serverBuildParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						serverBuildParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						serverBuildParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						serverBuildParam.IconId = sacloud.ID(c.Int64("icon-id"))
					}
					if c.IsSet("assumeyes") {
						serverBuildParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverBuildParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverBuildParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverBuildParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverBuildParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverBuildParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverBuildParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverBuildParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverBuildParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverBuildParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverBuildParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverBuildParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverBuildParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("us-keyboard") {
						serverBuildParam.UsKeyboard = c.Bool("us-keyboard")
					}
					if c.IsSet("disable-boot-after-create") {
						serverBuildParam.DisableBootAfterCreate = c.Bool("disable-boot-after-create")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverBuildParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverBuildParam.GenerateSkeleton {
						serverBuildParam.GenerateSkeleton = false
						serverBuildParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverBuildParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverBuildParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverBuildParam)

					// confirm
					if !serverBuildParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("build") {
							return nil
						}
					}

					// Run command with params
					return funcs.ServerBuild(ctx, serverBuildParam)

				},
			},
			{
				Name:      "read",
				Usage:     "Read Server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverReadParam.ParamTemplate = c.String("param-template")
					serverReadParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverReadParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewReadServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverReadParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverReadParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverReadParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverReadParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverReadParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverReadParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverReadParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverReadParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverReadParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverReadParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverReadParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverReadParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverReadParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverReadParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverReadParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverReadParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverReadParam.GenerateSkeleton {
						serverReadParam.GenerateSkeleton = false
						serverReadParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverReadParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverReadParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverReadParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverReadParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverReadParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverReadParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverReadParam.Selector) == 0 || hasTags(&v, serverReadParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverReadParam.SetId(id)
						p := *serverReadParam // copy struct value
						serverReadParam := &p
						go func() {
							err := funcs.ServerRead(ctx, serverReadParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "update",
				Usage:     "Update Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "interface-driver",
						Usage: "set interface driver[virtio/e1000]",
						Value: "virtio",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverUpdateParam.ParamTemplate = c.String("param-template")
					serverUpdateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverUpdateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUpdateServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverUpdateParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("interface-driver") {
						serverUpdateParam.InterfaceDriver = c.String("interface-driver")
					}
					if c.IsSet("selector") {
						serverUpdateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						serverUpdateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						serverUpdateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						serverUpdateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						serverUpdateParam.IconId = sacloud.ID(c.Int64("icon-id"))
					}
					if c.IsSet("assumeyes") {
						serverUpdateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverUpdateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverUpdateParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverUpdateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverUpdateParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverUpdateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverUpdateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverUpdateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverUpdateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverUpdateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverUpdateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverUpdateParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverUpdateParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverUpdateParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverUpdateParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverUpdateParam.GenerateSkeleton {
						serverUpdateParam.GenerateSkeleton = false
						serverUpdateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverUpdateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverUpdateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverUpdateParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverUpdateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverUpdateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverUpdateParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverUpdateParam.Selector) == 0 || hasTags(&v, serverUpdateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverUpdateParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("update", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverUpdateParam.SetId(id)
						p := *serverUpdateParam // copy struct value
						serverUpdateParam := &p
						go func() {
							err := funcs.ServerUpdate(ctx, serverUpdateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "delete",
				Aliases:   []string{"rm"},
				Usage:     "Delete Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:    "force",
						Aliases: []string{"f"},
						Usage:   "forced-shutdown flag if server is running",
					},
					&cli.BoolFlag{
						Name:  "without-disk",
						Usage: "don't delete connected disks with server",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverDeleteParam.ParamTemplate = c.String("param-template")
					serverDeleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverDeleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDeleteServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverDeleteParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("force") {
						serverDeleteParam.Force = c.Bool("force")
					}
					if c.IsSet("without-disk") {
						serverDeleteParam.WithoutDisk = c.Bool("without-disk")
					}
					if c.IsSet("selector") {
						serverDeleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverDeleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverDeleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverDeleteParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverDeleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverDeleteParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverDeleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverDeleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverDeleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverDeleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverDeleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverDeleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverDeleteParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverDeleteParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverDeleteParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverDeleteParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverDeleteParam.GenerateSkeleton {
						serverDeleteParam.GenerateSkeleton = false
						serverDeleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverDeleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverDeleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverDeleteParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverDeleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverDeleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverDeleteParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverDeleteParam.Selector) == 0 || hasTags(&v, serverDeleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverDeleteParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("delete", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverDeleteParam.SetId(id)
						p := *serverDeleteParam // copy struct value
						serverDeleteParam := &p
						go func() {
							err := funcs.ServerDelete(ctx, serverDeleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "plan-change",
				Usage:     "Change server plan(core/memory)",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "core",
						Usage: "[Required] set CPU core count",
					},
					&cli.IntFlag{
						Name:  "memory",
						Usage: "[Required] set memory size(GB)",
					},
					&cli.StringFlag{
						Name:  "commitment",
						Usage: "set plan of core assignment",
						Value: "standard",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverPlanChangeParam.ParamTemplate = c.String("param-template")
					serverPlanChangeParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverPlanChangeParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPlanChangeServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverPlanChangeParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("core") {
						serverPlanChangeParam.Core = c.Int("core")
					}
					if c.IsSet("memory") {
						serverPlanChangeParam.Memory = c.Int("memory")
					}
					if c.IsSet("commitment") {
						serverPlanChangeParam.Commitment = c.String("commitment")
					}
					if c.IsSet("selector") {
						serverPlanChangeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverPlanChangeParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverPlanChangeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverPlanChangeParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverPlanChangeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverPlanChangeParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverPlanChangeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverPlanChangeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverPlanChangeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverPlanChangeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverPlanChangeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverPlanChangeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverPlanChangeParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverPlanChangeParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverPlanChangeParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverPlanChangeParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverPlanChangeParam.GenerateSkeleton {
						serverPlanChangeParam.GenerateSkeleton = false
						serverPlanChangeParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverPlanChangeParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverPlanChangeParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverPlanChangeParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverPlanChangeParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverPlanChangeParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverPlanChangeParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverPlanChangeParam.Selector) == 0 || hasTags(&v, serverPlanChangeParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverPlanChangeParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("plan-change", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverPlanChangeParam.SetId(id)
						p := *serverPlanChangeParam // copy struct value
						serverPlanChangeParam := &p
						go func() {
							err := funcs.ServerPlanChange(ctx, serverPlanChangeParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "boot",
				Aliases:   []string{"power-on"},
				Usage:     "Boot Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverBootParam.ParamTemplate = c.String("param-template")
					serverBootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverBootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBootServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverBootParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverBootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverBootParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverBootParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverBootParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverBootParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverBootParam.GenerateSkeleton {
						serverBootParam.GenerateSkeleton = false
						serverBootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverBootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverBootParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverBootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverBootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverBootParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverBootParam.Selector) == 0 || hasTags(&v, serverBootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverBootParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("boot", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverBootParam.SetId(id)
						p := *serverBootParam // copy struct value
						serverBootParam := &p
						go func() {
							err := funcs.ServerBoot(ctx, serverBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown",
				Aliases:   []string{"power-off"},
				Usage:     "Shutdown Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverShutdownParam.ParamTemplate = c.String("param-template")
					serverShutdownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverShutdownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverShutdownParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverShutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverShutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverShutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverShutdownParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverShutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverShutdownParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverShutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverShutdownParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverShutdownParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverShutdownParam.GenerateSkeleton {
						serverShutdownParam.GenerateSkeleton = false
						serverShutdownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverShutdownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverShutdownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverShutdownParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverShutdownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverShutdownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverShutdownParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverShutdownParam.Selector) == 0 || hasTags(&v, serverShutdownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverShutdownParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("shutdown", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverShutdownParam.SetId(id)
						p := *serverShutdownParam // copy struct value
						serverShutdownParam := &p
						go func() {
							err := funcs.ServerShutdown(ctx, serverShutdownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown-force",
				Aliases:   []string{"stop"},
				Usage:     "ShutdownForce Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverShutdownForceParam.ParamTemplate = c.String("param-template")
					serverShutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverShutdownForceParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownForceServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverShutdownForceParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverShutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverShutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverShutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverShutdownForceParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverShutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverShutdownForceParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverShutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverShutdownForceParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverShutdownForceParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverShutdownForceParam.GenerateSkeleton {
						serverShutdownForceParam.GenerateSkeleton = false
						serverShutdownForceParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverShutdownForceParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverShutdownForceParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverShutdownForceParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverShutdownForceParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverShutdownForceParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverShutdownForceParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverShutdownForceParam.Selector) == 0 || hasTags(&v, serverShutdownForceParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverShutdownForceParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("shutdown-force", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverShutdownForceParam.SetId(id)
						p := *serverShutdownForceParam // copy struct value
						serverShutdownForceParam := &p
						go func() {
							err := funcs.ServerShutdownForce(ctx, serverShutdownForceParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "reset",
				Usage:     "Reset Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverResetParam.ParamTemplate = c.String("param-template")
					serverResetParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverResetParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewResetServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverResetParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverResetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverResetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverResetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverResetParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverResetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverResetParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverResetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverResetParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverResetParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverResetParam.GenerateSkeleton {
						serverResetParam.GenerateSkeleton = false
						serverResetParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverResetParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverResetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverResetParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverResetParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverResetParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverResetParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverResetParam.Selector) == 0 || hasTags(&v, serverResetParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !serverResetParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("reset", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverResetParam.SetId(id)
						p := *serverResetParam // copy struct value
						serverResetParam := &p
						go func() {
							err := funcs.ServerReset(ctx, serverResetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-boot",
				Usage:     "Wait until boot is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverWaitForBootParam.ParamTemplate = c.String("param-template")
					serverWaitForBootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverWaitForBootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForBootServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverWaitForBootParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverWaitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverWaitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverWaitForBootParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverWaitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverWaitForBootParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverWaitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverWaitForBootParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverWaitForBootParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverWaitForBootParam.GenerateSkeleton {
						serverWaitForBootParam.GenerateSkeleton = false
						serverWaitForBootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverWaitForBootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverWaitForBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverWaitForBootParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverWaitForBootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverWaitForBootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverWaitForBootParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverWaitForBootParam.Selector) == 0 || hasTags(&v, serverWaitForBootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverWaitForBootParam.SetId(id)
						p := *serverWaitForBootParam // copy struct value
						serverWaitForBootParam := &p
						go func() {
							err := funcs.ServerWaitForBoot(ctx, serverWaitForBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-down",
				Usage:     "Wait until shutdown is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverWaitForDownParam.ParamTemplate = c.String("param-template")
					serverWaitForDownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverWaitForDownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForDownServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverWaitForDownParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverWaitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverWaitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverWaitForDownParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverWaitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverWaitForDownParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverWaitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverWaitForDownParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverWaitForDownParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverWaitForDownParam.GenerateSkeleton {
						serverWaitForDownParam.GenerateSkeleton = false
						serverWaitForDownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverWaitForDownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverWaitForDownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverWaitForDownParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverWaitForDownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverWaitForDownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverWaitForDownParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverWaitForDownParam.Selector) == 0 || hasTags(&v, serverWaitForDownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverWaitForDownParam.SetId(id)
						p := *serverWaitForDownParam // copy struct value
						serverWaitForDownParam := &p
						go func() {
							err := funcs.ServerWaitForDown(ctx, serverWaitForDownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "ssh",
				Usage:     "Connect to server by SSH",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "key",
						Aliases: []string{"i"},
						Usage:   "private-key file path",
					},
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "user name",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   22,
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "password(or private-key pass phrase)",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "disable information messages",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverSSHParam.ParamTemplate = c.String("param-template")
					serverSSHParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverSSHParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSSHServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverSSHParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("key") {
						serverSSHParam.Key = c.String("key")
					}
					if c.IsSet("user") {
						serverSSHParam.User = c.String("user")
					}
					if c.IsSet("port") {
						serverSSHParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(serverSSHParam.Password) {
						serverSSHParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						serverSSHParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverSSHParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverSSHParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverSSHParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverSSHParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverSSHParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						serverSSHParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("id") {
						serverSSHParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverSSHParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverSSHParam.GenerateSkeleton {
						serverSSHParam.GenerateSkeleton = false
						serverSSHParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverSSHParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverSSHParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverSSHParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverSSHParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverSSHParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverSSHParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverSSHParam.Selector) == 0 || hasTags(&v, serverSSHParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverSSHParam.SetId(id)
						p := *serverSSHParam // copy struct value
						serverSSHParam := &p
						go func() {
							err := funcs.ServerSSH(ctx, serverSSHParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "ssh-exec",
				Usage:     "Execute command on server connected by SSH",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "key",
						Aliases: []string{"i"},
						Usage:   "private-key file path",
					},
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "user name",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   22,
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "password(or private-key pass phrase)",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "disable information messages",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverSSHExecParam.ParamTemplate = c.String("param-template")
					serverSSHExecParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverSSHExecParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSSHExecServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverSSHExecParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("key") {
						serverSSHExecParam.Key = c.String("key")
					}
					if c.IsSet("user") {
						serverSSHExecParam.User = c.String("user")
					}
					if c.IsSet("port") {
						serverSSHExecParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(serverSSHExecParam.Password) {
						serverSSHExecParam.Password = c.String("password")
					}
					if c.IsSet("param-template") {
						serverSSHExecParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverSSHExecParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverSSHExecParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverSSHExecParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverSSHExecParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						serverSSHExecParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("id") {
						serverSSHExecParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverSSHExecParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverSSHExecParam.GenerateSkeleton {
						serverSSHExecParam.GenerateSkeleton = false
						serverSSHExecParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverSSHExecParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverSSHExecParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverSSHExecParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						return fmt.Errorf("ID or Name argument is required")

					} else {

						arg := c.Args().First()

						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {

									ids = append(ids, v.GetID())

								}
							}
						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverSSHExecParam.SetId(id)
						p := *serverSSHExecParam // copy struct value
						serverSSHExecParam := &p
						go func() {
							err := funcs.ServerSSHExec(ctx, serverSSHExecParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "scp",
				Usage:     "Copy files/directories by SSH",
				ArgsUsage: "[ServerID:]<FROM> [ServerID:]<TO>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "key",
						Aliases: []string{"i"},
						Usage:   "private-key file path",
					},
					&cli.BoolFlag{
						Name:    "recursive",
						Aliases: []string{"r"},
						Usage:   "set recursive copy flag",
					},
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "user name",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   22,
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "password(or private-key pass phrase)",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "disable information messages",
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverScpParam.ParamTemplate = c.String("param-template")
					serverScpParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverScpParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewScpServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverScpParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("key") {
						serverScpParam.Key = c.String("key")
					}
					if c.IsSet("recursive") {
						serverScpParam.Recursive = c.Bool("recursive")
					}
					if c.IsSet("user") {
						serverScpParam.User = c.String("user")
					}
					if c.IsSet("port") {
						serverScpParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(serverScpParam.Password) {
						serverScpParam.Password = c.String("password")
					}
					if c.IsSet("assumeyes") {
						serverScpParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverScpParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverScpParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverScpParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverScpParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverScpParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						serverScpParam.Quiet = c.Bool("quiet")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverScpParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverScpParam.GenerateSkeleton {
						serverScpParam.GenerateSkeleton = false
						serverScpParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverScpParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverScpParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverScpParam)

					// confirm
					if !serverScpParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("scp") {
							return nil
						}
					}

					// Run command with params
					return funcs.ServerScp(ctx, serverScpParam)

				},
			},
			{
				Name:      "vnc",
				Usage:     "Open VNC client using the OS's default application",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverVncParam.ParamTemplate = c.String("param-template")
					serverVncParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverVncParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverVncParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("wait-for-boot") {
						serverVncParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						serverVncParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverVncParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverVncParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverVncParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverVncParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverVncParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverVncParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverVncParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverVncParam.GenerateSkeleton {
						serverVncParam.GenerateSkeleton = false
						serverVncParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverVncParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverVncParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverVncParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverVncParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverVncParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverVncParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverVncParam.Selector) == 0 || hasTags(&v, serverVncParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverVncParam.SetId(id)
						p := *serverVncParam // copy struct value
						serverVncParam := &p
						go func() {
							err := funcs.ServerVnc(ctx, serverVncParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-info",
				Usage:     "Show VNC proxy information",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverVncInfoParam.ParamTemplate = c.String("param-template")
					serverVncInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverVncInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverVncInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("wait-for-boot") {
						serverVncInfoParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						serverVncInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverVncInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverVncInfoParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverVncInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverVncInfoParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverVncInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverVncInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverVncInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverVncInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverVncInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverVncInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverVncInfoParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverVncInfoParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverVncInfoParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverVncInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverVncInfoParam.GenerateSkeleton {
						serverVncInfoParam.GenerateSkeleton = false
						serverVncInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverVncInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverVncInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverVncInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverVncInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverVncInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverVncInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverVncInfoParam.Selector) == 0 || hasTags(&v, serverVncInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverVncInfoParam.SetId(id)
						p := *serverVncInfoParam // copy struct value
						serverVncInfoParam := &p
						go func() {
							err := funcs.ServerVncInfo(ctx, serverVncInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-send",
				Usage:     "Send keys over VNC connection",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "command",
						Aliases: []string{"c"},
						Usage:   "command(compatible with HashiCorp Packer's boot_command)",
					},
					&cli.StringFlag{
						Name:    "command-file",
						Aliases: []string{"f"},
						Usage:   "command file(compatible with HashiCorp Packer's boot_command)",
					},
					&cli.BoolFlag{
						Name:  "use-us-keyboard",
						Usage: "use US Keyboard",
					},
					&cli.BoolFlag{
						Name:    "debug",
						Aliases: []string{"d"},
						Usage:   "write debug info",
					},
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverVncSendParam.ParamTemplate = c.String("param-template")
					serverVncSendParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverVncSendParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncSendServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverVncSendParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("command") {
						serverVncSendParam.Command = c.String("command")
					}
					if c.IsSet("command-file") {
						serverVncSendParam.CommandFile = c.String("command-file")
					}
					if c.IsSet("use-us-keyboard") {
						serverVncSendParam.UseUsKeyboard = c.Bool("use-us-keyboard")
					}
					if c.IsSet("debug") {
						serverVncSendParam.Debug = c.Bool("debug")
					}
					if c.IsSet("wait-for-boot") {
						serverVncSendParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						serverVncSendParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverVncSendParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverVncSendParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverVncSendParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverVncSendParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverVncSendParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverVncSendParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverVncSendParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverVncSendParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverVncSendParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverVncSendParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverVncSendParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverVncSendParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverVncSendParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverVncSendParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverVncSendParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverVncSendParam.GenerateSkeleton {
						serverVncSendParam.GenerateSkeleton = false
						serverVncSendParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverVncSendParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverVncSendParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverVncSendParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverVncSendParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverVncSendParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverVncSendParam.Selector)
						}

					} else {

						arg := c.Args().First()

						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									if len(serverVncSendParam.Selector) == 0 || hasTags(&v, serverVncSendParam.Selector) {
										ids = append(ids, v.GetID())
									}
								}
							}
						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverVncSendParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("vnc-send", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverVncSendParam.SetId(id)
						p := *serverVncSendParam // copy struct value
						serverVncSendParam := &p
						go func() {
							err := funcs.ServerVncSend(ctx, serverVncSendParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-snapshot",
				Usage:     "Capture VNC snapshot",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringFlag{
						Name:  "output-path",
						Usage: "snapshot output filepath",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverVncSnapshotParam.ParamTemplate = c.String("param-template")
					serverVncSnapshotParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverVncSnapshotParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncSnapshotServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverVncSnapshotParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("wait-for-boot") {
						serverVncSnapshotParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("output-path") {
						serverVncSnapshotParam.OutputPath = c.String("output-path")
					}
					if c.IsSet("selector") {
						serverVncSnapshotParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverVncSnapshotParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverVncSnapshotParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverVncSnapshotParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverVncSnapshotParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverVncSnapshotParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverVncSnapshotParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverVncSnapshotParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverVncSnapshotParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverVncSnapshotParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverVncSnapshotParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverVncSnapshotParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverVncSnapshotParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverVncSnapshotParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverVncSnapshotParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverVncSnapshotParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverVncSnapshotParam.GenerateSkeleton {
						serverVncSnapshotParam.GenerateSkeleton = false
						serverVncSnapshotParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverVncSnapshotParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverVncSnapshotParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverVncSnapshotParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverVncSnapshotParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverVncSnapshotParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverVncSnapshotParam.Selector)
						}

					} else {

						arg := c.Args().First()

						for _, a := range strings.Split(arg, "\n") {
							idOrName := a
							if id, ok := toSakuraID(idOrName); ok {
								ids = append(ids, id)
							} else {
								apiClient.Reset()
								apiClient.SetFilterBy("Name", idOrName)
								res, err := apiClient.Find()
								if err != nil {
									return fmt.Errorf("Find ID is failed: %s", err)
								}
								if res.Count == 0 {
									return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
								}
								for _, v := range res.Servers {
									if len(serverVncSnapshotParam.Selector) == 0 || hasTags(&v, serverVncSnapshotParam.Selector) {
										ids = append(ids, v.GetID())
									}
								}
							}
						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverVncSnapshotParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("vnc-snapshot", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverVncSnapshotParam.SetId(id)
						p := *serverVncSnapshotParam // copy struct value
						serverVncSnapshotParam := &p
						go func() {
							err := funcs.ServerVncSnapshot(ctx, serverVncSnapshotParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "remote-desktop",
				Aliases:   []string{"rdp"},
				Usage:     "Open RDP client using the OS's default application",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "[Required] user name",
						Value:   "Administrator",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   3389,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverRemoteDesktopParam.ParamTemplate = c.String("param-template")
					serverRemoteDesktopParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverRemoteDesktopParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewRemoteDesktopServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverRemoteDesktopParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("user") {
						serverRemoteDesktopParam.User = c.String("user")
					}
					if c.IsSet("port") {
						serverRemoteDesktopParam.Port = c.Int("port")
					}
					if c.IsSet("selector") {
						serverRemoteDesktopParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverRemoteDesktopParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverRemoteDesktopParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverRemoteDesktopParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverRemoteDesktopParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverRemoteDesktopParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverRemoteDesktopParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverRemoteDesktopParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverRemoteDesktopParam.GenerateSkeleton {
						serverRemoteDesktopParam.GenerateSkeleton = false
						serverRemoteDesktopParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverRemoteDesktopParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverRemoteDesktopParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverRemoteDesktopParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverRemoteDesktopParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverRemoteDesktopParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverRemoteDesktopParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverRemoteDesktopParam.Selector) == 0 || hasTags(&v, serverRemoteDesktopParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverRemoteDesktopParam.SetId(id)
						p := *serverRemoteDesktopParam // copy struct value
						serverRemoteDesktopParam := &p
						go func() {
							err := funcs.ServerRemoteDesktop(ctx, serverRemoteDesktopParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "remote-desktop-info",
				Aliases:   []string{"rdp-info"},
				Usage:     "Show RDP information(.rdp)",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "[Required] user name",
						Value:   "Administrator",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   3389,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverRemoteDesktopInfoParam.ParamTemplate = c.String("param-template")
					serverRemoteDesktopInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverRemoteDesktopInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewRemoteDesktopInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverRemoteDesktopInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("user") {
						serverRemoteDesktopInfoParam.User = c.String("user")
					}
					if c.IsSet("port") {
						serverRemoteDesktopInfoParam.Port = c.Int("port")
					}
					if c.IsSet("selector") {
						serverRemoteDesktopInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverRemoteDesktopInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverRemoteDesktopInfoParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverRemoteDesktopInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverRemoteDesktopInfoParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverRemoteDesktopInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverRemoteDesktopInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverRemoteDesktopInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverRemoteDesktopInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverRemoteDesktopInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverRemoteDesktopInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverRemoteDesktopInfoParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverRemoteDesktopInfoParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverRemoteDesktopInfoParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverRemoteDesktopInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverRemoteDesktopInfoParam.GenerateSkeleton {
						serverRemoteDesktopInfoParam.GenerateSkeleton = false
						serverRemoteDesktopInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverRemoteDesktopInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverRemoteDesktopInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverRemoteDesktopInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverRemoteDesktopInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverRemoteDesktopInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverRemoteDesktopInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverRemoteDesktopInfoParam.Selector) == 0 || hasTags(&v, serverRemoteDesktopInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverRemoteDesktopInfoParam.SetId(id)
						p := *serverRemoteDesktopInfoParam // copy struct value
						serverRemoteDesktopInfoParam := &p
						go func() {
							err := funcs.ServerRemoteDesktopInfo(ctx, serverRemoteDesktopInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-info",
				Aliases:   []string{"disk-list"},
				Usage:     "Show information of disk(s) connected to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverDiskInfoParam.ParamTemplate = c.String("param-template")
					serverDiskInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverDiskInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDiskInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverDiskInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverDiskInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverDiskInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverDiskInfoParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverDiskInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverDiskInfoParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverDiskInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverDiskInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverDiskInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverDiskInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverDiskInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverDiskInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverDiskInfoParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverDiskInfoParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverDiskInfoParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverDiskInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverDiskInfoParam.GenerateSkeleton {
						serverDiskInfoParam.GenerateSkeleton = false
						serverDiskInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverDiskInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverDiskInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverDiskInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverDiskInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverDiskInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverDiskInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverDiskInfoParam.Selector) == 0 || hasTags(&v, serverDiskInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverDiskInfoParam.SetId(id)
						p := *serverDiskInfoParam // copy struct value
						serverDiskInfoParam := &p
						go func() {
							err := funcs.ServerDiskInfo(ctx, serverDiskInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-connect",
				Usage:     "Connect disk to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "disk-id",
						Usage: "[Required] set target disk ID",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverDiskConnectParam.ParamTemplate = c.String("param-template")
					serverDiskConnectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverDiskConnectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDiskConnectServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverDiskConnectParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("disk-id") {
						serverDiskConnectParam.DiskId = sacloud.ID(c.Int64("disk-id"))
					}
					if c.IsSet("selector") {
						serverDiskConnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverDiskConnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverDiskConnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverDiskConnectParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverDiskConnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverDiskConnectParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverDiskConnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverDiskConnectParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverDiskConnectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverDiskConnectParam.GenerateSkeleton {
						serverDiskConnectParam.GenerateSkeleton = false
						serverDiskConnectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverDiskConnectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverDiskConnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverDiskConnectParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverDiskConnectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverDiskConnectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverDiskConnectParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverDiskConnectParam.Selector) == 0 || hasTags(&v, serverDiskConnectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverDiskConnectParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("disk-connect", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverDiskConnectParam.SetId(id)
						p := *serverDiskConnectParam // copy struct value
						serverDiskConnectParam := &p
						go func() {
							err := funcs.ServerDiskConnect(ctx, serverDiskConnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-disconnect",
				Usage:     "Disconnect disk from server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "disk-id",
						Usage: "[Required] set target disk ID",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverDiskDisconnectParam.ParamTemplate = c.String("param-template")
					serverDiskDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverDiskDisconnectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDiskDisconnectServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverDiskDisconnectParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("disk-id") {
						serverDiskDisconnectParam.DiskId = sacloud.ID(c.Int64("disk-id"))
					}
					if c.IsSet("selector") {
						serverDiskDisconnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverDiskDisconnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverDiskDisconnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverDiskDisconnectParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverDiskDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverDiskDisconnectParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverDiskDisconnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverDiskDisconnectParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverDiskDisconnectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverDiskDisconnectParam.GenerateSkeleton {
						serverDiskDisconnectParam.GenerateSkeleton = false
						serverDiskDisconnectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverDiskDisconnectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverDiskDisconnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverDiskDisconnectParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverDiskDisconnectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverDiskDisconnectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverDiskDisconnectParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverDiskDisconnectParam.Selector) == 0 || hasTags(&v, serverDiskDisconnectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverDiskDisconnectParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("disk-disconnect", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverDiskDisconnectParam.SetId(id)
						p := *serverDiskDisconnectParam // copy struct value
						serverDiskDisconnectParam := &p
						go func() {
							err := funcs.ServerDiskDisconnect(ctx, serverDiskDisconnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-info",
				Aliases:   []string{"interface-list"},
				Usage:     "Show information of NIC(s) connected to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverInterfaceInfoParam.ParamTemplate = c.String("param-template")
					serverInterfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverInterfaceInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverInterfaceInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverInterfaceInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverInterfaceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverInterfaceInfoParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverInterfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverInterfaceInfoParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverInterfaceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverInterfaceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverInterfaceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverInterfaceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverInterfaceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverInterfaceInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverInterfaceInfoParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverInterfaceInfoParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverInterfaceInfoParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverInterfaceInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverInterfaceInfoParam.GenerateSkeleton {
						serverInterfaceInfoParam.GenerateSkeleton = false
						serverInterfaceInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverInterfaceInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverInterfaceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverInterfaceInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverInterfaceInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverInterfaceInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverInterfaceInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverInterfaceInfoParam.Selector) == 0 || hasTags(&v, serverInterfaceInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverInterfaceInfoParam.SetId(id)
						p := *serverInterfaceInfoParam // copy struct value
						serverInterfaceInfoParam := &p
						go func() {
							err := funcs.ServerInterfaceInfo(ctx, serverInterfaceInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-internet",
				Usage:     "Create and connect NIC connected to the internet",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "without-disk-edit",
						Usage: "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverInterfaceAddForInternetParam.ParamTemplate = c.String("param-template")
					serverInterfaceAddForInternetParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverInterfaceAddForInternetParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddForInternetServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverInterfaceAddForInternetParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("without-disk-edit") {
						serverInterfaceAddForInternetParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("selector") {
						serverInterfaceAddForInternetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverInterfaceAddForInternetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverInterfaceAddForInternetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverInterfaceAddForInternetParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverInterfaceAddForInternetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverInterfaceAddForInternetParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverInterfaceAddForInternetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverInterfaceAddForInternetParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverInterfaceAddForInternetParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverInterfaceAddForInternetParam.GenerateSkeleton {
						serverInterfaceAddForInternetParam.GenerateSkeleton = false
						serverInterfaceAddForInternetParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverInterfaceAddForInternetParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverInterfaceAddForInternetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverInterfaceAddForInternetParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverInterfaceAddForInternetParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverInterfaceAddForInternetParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverInterfaceAddForInternetParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverInterfaceAddForInternetParam.Selector) == 0 || hasTags(&v, serverInterfaceAddForInternetParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverInterfaceAddForInternetParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-add-for-internet", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverInterfaceAddForInternetParam.SetId(id)
						p := *serverInterfaceAddForInternetParam // copy struct value
						serverInterfaceAddForInternetParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForInternet(ctx, serverInterfaceAddForInternetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-router",
				Usage:     "Create and connect NIC connected to the router",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "[Required] set connect switch(connected to router) ID",
					},
					&cli.BoolFlag{
						Name:  "without-disk-edit",
						Usage: "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.StringFlag{
						Name:    "default-route",
						Aliases: []string{"gateway"},
						Usage:   "set default gateway",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress  prefix",
						Value:   24,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverInterfaceAddForRouterParam.ParamTemplate = c.String("param-template")
					serverInterfaceAddForRouterParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverInterfaceAddForRouterParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddForRouterServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverInterfaceAddForRouterParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("switch-id") {
						serverInterfaceAddForRouterParam.SwitchId = sacloud.ID(c.Int64("switch-id"))
					}
					if c.IsSet("without-disk-edit") {
						serverInterfaceAddForRouterParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("ipaddress") {
						serverInterfaceAddForRouterParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("default-route") {
						serverInterfaceAddForRouterParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("nw-masklen") {
						serverInterfaceAddForRouterParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						serverInterfaceAddForRouterParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverInterfaceAddForRouterParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverInterfaceAddForRouterParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverInterfaceAddForRouterParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverInterfaceAddForRouterParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverInterfaceAddForRouterParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverInterfaceAddForRouterParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverInterfaceAddForRouterParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverInterfaceAddForRouterParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverInterfaceAddForRouterParam.GenerateSkeleton {
						serverInterfaceAddForRouterParam.GenerateSkeleton = false
						serverInterfaceAddForRouterParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverInterfaceAddForRouterParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverInterfaceAddForRouterParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverInterfaceAddForRouterParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverInterfaceAddForRouterParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverInterfaceAddForRouterParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverInterfaceAddForRouterParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverInterfaceAddForRouterParam.Selector) == 0 || hasTags(&v, serverInterfaceAddForRouterParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverInterfaceAddForRouterParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-add-for-router", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverInterfaceAddForRouterParam.SetId(id)
						p := *serverInterfaceAddForRouterParam // copy struct value
						serverInterfaceAddForRouterParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForRouter(ctx, serverInterfaceAddForRouterParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-switch",
				Usage:     "Create and connect NIC connected to the switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "[Required] set connect switch ID",
					},
					&cli.BoolFlag{
						Name:  "without-disk-edit",
						Usage: "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.StringFlag{
						Name:    "default-route",
						Aliases: []string{"gateway"},
						Usage:   "set default gateway",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress  prefix",
						Value:   24,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverInterfaceAddForSwitchParam.ParamTemplate = c.String("param-template")
					serverInterfaceAddForSwitchParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverInterfaceAddForSwitchParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddForSwitchServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverInterfaceAddForSwitchParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("switch-id") {
						serverInterfaceAddForSwitchParam.SwitchId = sacloud.ID(c.Int64("switch-id"))
					}
					if c.IsSet("without-disk-edit") {
						serverInterfaceAddForSwitchParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("ipaddress") {
						serverInterfaceAddForSwitchParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("default-route") {
						serverInterfaceAddForSwitchParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("nw-masklen") {
						serverInterfaceAddForSwitchParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						serverInterfaceAddForSwitchParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverInterfaceAddForSwitchParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverInterfaceAddForSwitchParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverInterfaceAddForSwitchParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverInterfaceAddForSwitchParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverInterfaceAddForSwitchParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverInterfaceAddForSwitchParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverInterfaceAddForSwitchParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverInterfaceAddForSwitchParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverInterfaceAddForSwitchParam.GenerateSkeleton {
						serverInterfaceAddForSwitchParam.GenerateSkeleton = false
						serverInterfaceAddForSwitchParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverInterfaceAddForSwitchParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverInterfaceAddForSwitchParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverInterfaceAddForSwitchParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverInterfaceAddForSwitchParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverInterfaceAddForSwitchParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverInterfaceAddForSwitchParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverInterfaceAddForSwitchParam.Selector) == 0 || hasTags(&v, serverInterfaceAddForSwitchParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverInterfaceAddForSwitchParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-add-for-switch", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverInterfaceAddForSwitchParam.SetId(id)
						p := *serverInterfaceAddForSwitchParam // copy struct value
						serverInterfaceAddForSwitchParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForSwitch(ctx, serverInterfaceAddForSwitchParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-disconnected",
				Usage:     "Create and connect a disconnected NIC",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverInterfaceAddDisconnectedParam.ParamTemplate = c.String("param-template")
					serverInterfaceAddDisconnectedParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverInterfaceAddDisconnectedParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddDisconnectedServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverInterfaceAddDisconnectedParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverInterfaceAddDisconnectedParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverInterfaceAddDisconnectedParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverInterfaceAddDisconnectedParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverInterfaceAddDisconnectedParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverInterfaceAddDisconnectedParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverInterfaceAddDisconnectedParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverInterfaceAddDisconnectedParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverInterfaceAddDisconnectedParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverInterfaceAddDisconnectedParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverInterfaceAddDisconnectedParam.GenerateSkeleton {
						serverInterfaceAddDisconnectedParam.GenerateSkeleton = false
						serverInterfaceAddDisconnectedParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverInterfaceAddDisconnectedParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverInterfaceAddDisconnectedParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverInterfaceAddDisconnectedParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverInterfaceAddDisconnectedParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverInterfaceAddDisconnectedParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverInterfaceAddDisconnectedParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverInterfaceAddDisconnectedParam.Selector) == 0 || hasTags(&v, serverInterfaceAddDisconnectedParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverInterfaceAddDisconnectedParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("interface-add-disconnected", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverInterfaceAddDisconnectedParam.SetId(id)
						p := *serverInterfaceAddDisconnectedParam // copy struct value
						serverInterfaceAddDisconnectedParam := &p
						go func() {
							err := funcs.ServerInterfaceAddDisconnected(ctx, serverInterfaceAddDisconnectedParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-info",
				Usage:     "Show information of ISO-Image inserted to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverISOInfoParam.ParamTemplate = c.String("param-template")
					serverISOInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverISOInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewISOInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverISOInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverISOInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverISOInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverISOInfoParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverISOInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverISOInfoParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverISOInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverISOInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverISOInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverISOInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverISOInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverISOInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverISOInfoParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverISOInfoParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverISOInfoParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverISOInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverISOInfoParam.GenerateSkeleton {
						serverISOInfoParam.GenerateSkeleton = false
						serverISOInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverISOInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverISOInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverISOInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverISOInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverISOInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverISOInfoParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverISOInfoParam.Selector) == 0 || hasTags(&v, serverISOInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverISOInfoParam.SetId(id)
						p := *serverISOInfoParam // copy struct value
						serverISOInfoParam := &p
						go func() {
							err := funcs.ServerISOInfo(ctx, serverISOInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-insert",
				Usage:     "Insert ISO-Image to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "iso-image-id",
						Usage: "set iso-image ID",
					},
					&cli.IntFlag{
						Name:  "size",
						Usage: "set iso size(GB)",
						Value: 5,
					},
					&cli.StringFlag{
						Name:  "iso-file",
						Usage: "set iso image file",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverISOInsertParam.ParamTemplate = c.String("param-template")
					serverISOInsertParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverISOInsertParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewISOInsertServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverISOInsertParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("iso-image-id") {
						serverISOInsertParam.ISOImageId = sacloud.ID(c.Int64("iso-image-id"))
					}
					if c.IsSet("size") {
						serverISOInsertParam.Size = c.Int("size")
					}
					if c.IsSet("iso-file") {
						serverISOInsertParam.ISOFile = c.String("iso-file")
					}
					if c.IsSet("name") {
						serverISOInsertParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						serverISOInsertParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						serverISOInsertParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						serverISOInsertParam.IconId = sacloud.ID(c.Int64("icon-id"))
					}
					if c.IsSet("selector") {
						serverISOInsertParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverISOInsertParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverISOInsertParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverISOInsertParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverISOInsertParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverISOInsertParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverISOInsertParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverISOInsertParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverISOInsertParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverISOInsertParam.GenerateSkeleton {
						serverISOInsertParam.GenerateSkeleton = false
						serverISOInsertParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverISOInsertParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverISOInsertParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverISOInsertParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverISOInsertParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverISOInsertParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverISOInsertParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverISOInsertParam.Selector) == 0 || hasTags(&v, serverISOInsertParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverISOInsertParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("iso-insert", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverISOInsertParam.SetId(id)
						p := *serverISOInsertParam // copy struct value
						serverISOInsertParam := &p
						go func() {
							err := funcs.ServerISOInsert(ctx, serverISOInsertParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-eject",
				Usage:     "Eject ISO-Image from server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverISOEjectParam.ParamTemplate = c.String("param-template")
					serverISOEjectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverISOEjectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewISOEjectServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverISOEjectParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("selector") {
						serverISOEjectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						serverISOEjectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						serverISOEjectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverISOEjectParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverISOEjectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverISOEjectParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverISOEjectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						serverISOEjectParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverISOEjectParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverISOEjectParam.GenerateSkeleton {
						serverISOEjectParam.GenerateSkeleton = false
						serverISOEjectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverISOEjectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverISOEjectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverISOEjectParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverISOEjectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverISOEjectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverISOEjectParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverISOEjectParam.Selector) == 0 || hasTags(&v, serverISOEjectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !serverISOEjectParam.Assumeyes {
						if !isTerminal() {
							return fmt.Errorf("When using redirect/pipe, specify --assumeyes(-y) option")
						}
						if !command.ConfirmContinue("iso-eject", ids...) {
							return nil
						}
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverISOEjectParam.SetId(id)
						p := *serverISOEjectParam // copy struct value
						serverISOEjectParam := &p
						go func() {
							err := funcs.ServerISOEject(ctx, serverISOEjectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-cpu",
				Usage:     "Collect CPU monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.server.{{.ID}}.cpu",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverMonitorCPUParam.ParamTemplate = c.String("param-template")
					serverMonitorCPUParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverMonitorCPUParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorCPUServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverMonitorCPUParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("start") {
						serverMonitorCPUParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						serverMonitorCPUParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						serverMonitorCPUParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						serverMonitorCPUParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverMonitorCPUParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverMonitorCPUParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverMonitorCPUParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverMonitorCPUParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverMonitorCPUParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverMonitorCPUParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverMonitorCPUParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverMonitorCPUParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverMonitorCPUParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverMonitorCPUParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverMonitorCPUParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverMonitorCPUParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverMonitorCPUParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverMonitorCPUParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverMonitorCPUParam.GenerateSkeleton {
						serverMonitorCPUParam.GenerateSkeleton = false
						serverMonitorCPUParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverMonitorCPUParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverMonitorCPUParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverMonitorCPUParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverMonitorCPUParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverMonitorCPUParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverMonitorCPUParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverMonitorCPUParam.Selector) == 0 || hasTags(&v, serverMonitorCPUParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverMonitorCPUParam.SetId(id)
						p := *serverMonitorCPUParam // copy struct value
						serverMonitorCPUParam := &p
						go func() {
							err := funcs.ServerMonitorCPU(ctx, serverMonitorCPUParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-nic",
				Usage:     "Collect NIC(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.Int64SliceFlag{
						Name:  "index",
						Usage: "target index(es)",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.server.{{.ID}}.nic.{{.Index}}",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverMonitorNicParam.ParamTemplate = c.String("param-template")
					serverMonitorNicParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverMonitorNicParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorNicServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverMonitorNicParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("start") {
						serverMonitorNicParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						serverMonitorNicParam.End = c.String("end")
					}
					if c.IsSet("index") {
						serverMonitorNicParam.Index = c.Int64Slice("index")
					}
					if c.IsSet("key-format") {
						serverMonitorNicParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						serverMonitorNicParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverMonitorNicParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverMonitorNicParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverMonitorNicParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverMonitorNicParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverMonitorNicParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverMonitorNicParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverMonitorNicParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverMonitorNicParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverMonitorNicParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverMonitorNicParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverMonitorNicParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverMonitorNicParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverMonitorNicParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverMonitorNicParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverMonitorNicParam.GenerateSkeleton {
						serverMonitorNicParam.GenerateSkeleton = false
						serverMonitorNicParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverMonitorNicParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverMonitorNicParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverMonitorNicParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverMonitorNicParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverMonitorNicParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverMonitorNicParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverMonitorNicParam.Selector) == 0 || hasTags(&v, serverMonitorNicParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverMonitorNicParam.SetId(id)
						p := *serverMonitorNicParam // copy struct value
						serverMonitorNicParam := &p
						go func() {
							err := funcs.ServerMonitorNic(ctx, serverMonitorNicParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-disk",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.Int64SliceFlag{
						Name:  "index",
						Usage: "target index(es)",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.server.{{.ID}}.disk.{{.Index}}",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverMonitorDiskParam.ParamTemplate = c.String("param-template")
					serverMonitorDiskParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverMonitorDiskParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorDiskServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverMonitorDiskParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("start") {
						serverMonitorDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						serverMonitorDiskParam.End = c.String("end")
					}
					if c.IsSet("index") {
						serverMonitorDiskParam.Index = c.Int64Slice("index")
					}
					if c.IsSet("key-format") {
						serverMonitorDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						serverMonitorDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						serverMonitorDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverMonitorDiskParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverMonitorDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverMonitorDiskParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverMonitorDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverMonitorDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverMonitorDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverMonitorDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverMonitorDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverMonitorDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverMonitorDiskParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverMonitorDiskParam.QueryFile = c.String("query-file")
					}
					if c.IsSet("id") {
						serverMonitorDiskParam.Id = sacloud.ID(c.Int64("id"))
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverMonitorDiskParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverMonitorDiskParam.GenerateSkeleton {
						serverMonitorDiskParam.GenerateSkeleton = false
						serverMonitorDiskParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverMonitorDiskParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverMonitorDiskParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverMonitorDiskParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []sacloud.ID{}

					if c.NArg() == 0 {

						if len(serverMonitorDiskParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, serverMonitorDiskParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", serverMonitorDiskParam.Selector)
						}

					} else {

						for _, arg := range c.Args().Slice() {

							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(serverMonitorDiskParam.Selector) == 0 || hasTags(&v, serverMonitorDiskParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}

						}

					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						serverMonitorDiskParam.SetId(id)
						p := *serverMonitorDiskParam // copy struct value
						serverMonitorDiskParam := &p
						go func() {
							err := funcs.ServerMonitorDisk(ctx, serverMonitorDiskParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:  "maintenance-info",
				Usage: "MaintenanceInfo Server",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "parameters",
						Usage: "Set input parameters from JSON string",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.StringFlag{
						Name:  "parameter-file",
						Usage: "Set input parameters from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out", "o"},
						Usage:   "Output type [table/json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "query",
						Usage: "JMESPath query(using when '--output-type' is json only)",
					},
					&cli.StringFlag{
						Name:  "query-file",
						Usage: "JMESPath query from file(using when '--output-type' is json only)",
					},
				},
				Action: func(c *cli.Context) error {

					if err := checkConfigVersion(); err != nil {
						return err
					}
					if err := applyConfigFromFile(c); err != nil {
						return err
					}

					serverMaintenanceInfoParam.ParamTemplate = c.String("param-template")
					serverMaintenanceInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(serverMaintenanceInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMaintenanceInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.Merge(serverMaintenanceInfoParam, p, mergo.WithOverride)
					}

					// Set option values
					if c.IsSet("param-template") {
						serverMaintenanceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("parameters") {
						serverMaintenanceInfoParam.Parameters = c.String("parameters")
					}
					if c.IsSet("param-template-file") {
						serverMaintenanceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("parameter-file") {
						serverMaintenanceInfoParam.ParameterFile = c.String("parameter-file")
					}
					if c.IsSet("generate-skeleton") {
						serverMaintenanceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						serverMaintenanceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						serverMaintenanceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						serverMaintenanceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						serverMaintenanceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						serverMaintenanceInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("query") {
						serverMaintenanceInfoParam.Query = c.String("query")
					}
					if c.IsSet("query-file") {
						serverMaintenanceInfoParam.QueryFile = c.String("query-file")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					var outputTypeHolder interface{} = serverMaintenanceInfoParam
					if v, ok := outputTypeHolder.(command.OutputTypeHolder); ok {
						if v.GetOutputType() == "" {
							v.SetOutputType(command.GlobalOption.DefaultOutputType)
						}
					}

					// Experiment warning
					printWarning("")

					// Generate skeleton
					if serverMaintenanceInfoParam.GenerateSkeleton {
						serverMaintenanceInfoParam.GenerateSkeleton = false
						serverMaintenanceInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(serverMaintenanceInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := serverMaintenanceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), serverMaintenanceInfoParam)

					// Run command with params
					return funcs.ServerMaintenanceInfo(ctx, serverMaintenanceInfoParam)

				},
			},
		},
	}

	// build Category-Resource mapping
	AppendResourceCategoryMap("server", &schema.Category{
		Key:         "computing",
		DisplayName: "Computing",
		Order:       10,
	})

	// build Category-Command mapping

	AppendCommandCategoryMap("server", "boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "build", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "delete", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "disk-connect", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "disk-disconnect", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "disk-info", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "interface-add-disconnected", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-internet", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-router", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-switch", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-info", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "iso-eject", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "iso-info", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "iso-insert", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "list", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "maintenance-info", &schema.Category{
		Key:         "other",
		DisplayName: "Other",
		Order:       1000,
	})
	AppendCommandCategoryMap("server", "monitor-cpu", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "monitor-disk", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "monitor-nic", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "plan-change", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "read", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "remote-desktop", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "remote-desktop-info", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "reset", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "scp", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "shutdown", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "shutdown-force", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "ssh", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "ssh-exec", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "update", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "vnc", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-info", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-send", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-snapshot", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "wait-for-boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "wait-for-down", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})

	// build Category-Param mapping

	AppendFlagCategoryMap("server", "boot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "build", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "commitment", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "core", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "default-route", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "description", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "disable-boot-after-create", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "build", "disable-password-auth", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "disk-connection", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-mode", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-plan", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-size", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "distant-from", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "hostname", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "icon-id", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "interface-driver", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "ipaddress", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "iso-image-id", &schema.Category{
		Key:         "iso-image",
		DisplayName: "For ISO image options",
		Order:       25,
	})
	AppendFlagCategoryMap("server", "build", "memory", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "name", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "network-mode", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "nw-masklen", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "os-type", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "packet-filter-id", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "password", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "private-host-id", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "source-archive-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "source-disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-description", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-ephemeral", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-ids", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-mode", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-name", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-pass-phrase", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-private-key-output", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-public-key-files", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-public-keys", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "startup-script-ids", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "startup-scripts", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "startup-scripts-ephemeral", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "switch-id", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "tags", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "us-keyboard", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "force", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "delete", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "delete", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "delete", "without-disk", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-connect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "Disk options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-connect", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-connect", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "Disk options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "disk-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "default-route", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "ipaddress", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "nw-masklen", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "switch-id", &schema.Category{
		Key:         "connect",
		DisplayName: "Connect options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "default-route", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "ipaddress", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "nw-masklen", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "switch-id", &schema.Category{
		Key:         "connect",
		DisplayName: "Connect options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-eject", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-eject", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-insert", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "description", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "icon-id", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-insert", "iso-file", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "iso-image-id", &schema.Category{
		Key:         "ISO-insert",
		DisplayName: "ISO-Insert options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "name", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-insert", "size", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "tags", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "list", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "from", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("server", "list", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "id", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "list", "max", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("server", "list", "name", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "list", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "sort", &schema.Category{
		Key:         "sort",
		DisplayName: "Sort options",
		Order:       2147483607,
	})
	AppendFlagCategoryMap("server", "list", "tags", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "commitment", &schema.Category{
		Key:         "server-plan",
		DisplayName: "Server-Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "core", &schema.Category{
		Key:         "plan",
		DisplayName: "Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "plan-change", "memory", &schema.Category{
		Key:         "plan",
		DisplayName: "Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "read", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "read", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "remote-desktop", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "remote-desktop-info", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "reset", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "reset", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "scp", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "scp", "recursive", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "shutdown", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "shutdown", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "ssh", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "ssh", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "ssh", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "update", "interface-driver", &schema.Category{
		Key:         "network",
		DisplayName: "Network options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "update", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "update", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "vnc", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc-info", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "command", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "command-file", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "debug", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-send", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc-send", "use-us-keyboard", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "output-path", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "query", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "query-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc-snapshot", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "parameter-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "parameters", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})

	// append command to GlobalContext
	Commands = append(Commands, cliCommand)
}
