// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cli

import (
	"encoding/json"
	"fmt"
	"github.com/imdario/mergo"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/completion"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/schema"
	"gopkg.in/urfave/cli.v2"
	"strings"
	"sync"
)

func init() {
	listParam := params.NewListServerParam()
	buildParam := params.NewBuildServerParam()
	readParam := params.NewReadServerParam()
	updateParam := params.NewUpdateServerParam()
	deleteParam := params.NewDeleteServerParam()
	planChangeParam := params.NewPlanChangeServerParam()
	bootParam := params.NewBootServerParam()
	shutdownParam := params.NewShutdownServerParam()
	shutdownForceParam := params.NewShutdownForceServerParam()
	resetParam := params.NewResetServerParam()
	waitForBootParam := params.NewWaitForBootServerParam()
	waitForDownParam := params.NewWaitForDownServerParam()
	sshParam := params.NewSshServerParam()
	sshExecParam := params.NewSshExecServerParam()
	scpParam := params.NewScpServerParam()
	vncParam := params.NewVncServerParam()
	vncInfoParam := params.NewVncInfoServerParam()
	vncSendParam := params.NewVncSendServerParam()
	diskInfoParam := params.NewDiskInfoServerParam()
	diskConnectParam := params.NewDiskConnectServerParam()
	diskDisconnectParam := params.NewDiskDisconnectServerParam()
	interfaceInfoParam := params.NewInterfaceInfoServerParam()
	interfaceAddForInternetParam := params.NewInterfaceAddForInternetServerParam()
	interfaceAddForRouterParam := params.NewInterfaceAddForRouterServerParam()
	interfaceAddForSwitchParam := params.NewInterfaceAddForSwitchServerParam()
	interfaceAddDisconnectedParam := params.NewInterfaceAddDisconnectedServerParam()
	isoInfoParam := params.NewIsoInfoServerParam()
	isoInsertParam := params.NewIsoInsertServerParam()
	isoEjectParam := params.NewIsoEjectServerParam()
	monitorCpuParam := params.NewMonitorCpuServerParam()
	monitorNicParam := params.NewMonitorNicServerParam()
	monitorDiskParam := params.NewMonitorDiskServerParam()
	maintenanceInfoParam := params.NewMaintenanceInfoServerParam()

	cliCommand := &cli.Command{
		Name:  "server",
		Usage: "A manage commands of Server",
		Subcommands: []*cli.Command{
			{
				Name:    "list",
				Aliases: []string{"ls", "find", "selector"},
				Usage:   "List Server",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "name",
						Usage: "set filter by name(s)",
					},
					&cli.Int64SliceFlag{
						Name:  "id",
						Usage: "set filter by id(s)",
					},
					&cli.StringSliceFlag{
						Name:    "tags",
						Aliases: []string{"selector"},
						Usage:   "set filter by tags(AND)",
					},
					&cli.IntFlag{
						Name:    "from",
						Aliases: []string{"offset"},
						Usage:   "set offset",
					},
					&cli.IntFlag{
						Name:    "max",
						Aliases: []string{"limit"},
						Usage:   "set limit",
					},
					&cli.StringSliceFlag{
						Name:  "sort",
						Usage: "set field(s) for sort",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, listParam)

					// Set option values
					if c.IsSet("name") {
						listParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						listParam.Id = c.Int64Slice("id")
					}
					if c.IsSet("tags") {
						listParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						listParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						listParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						listParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						listParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						listParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						listParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						listParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						listParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						listParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						listParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						listParam.FormatFile = c.String("format-file")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerListCompleteArgs(ctx, listParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerListCompleteArgs(ctx, listParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerListCompleteFlags(ctx, listParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerListCompleteArgs(ctx, listParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					listParam.ParamTemplate = c.String("param-template")
					listParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(listParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewListServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(listParam, p)
					}

					// Set option values
					if c.IsSet("name") {
						listParam.Name = c.StringSlice("name")
					}
					if c.IsSet("id") {
						listParam.Id = c.Int64Slice("id")
					}
					if c.IsSet("tags") {
						listParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("from") {
						listParam.From = c.Int("from")
					}
					if c.IsSet("max") {
						listParam.Max = c.Int("max")
					}
					if c.IsSet("sort") {
						listParam.Sort = c.StringSlice("sort")
					}
					if c.IsSet("param-template") {
						listParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						listParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						listParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						listParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						listParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						listParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						listParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						listParam.FormatFile = c.String("format-file")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if listParam.GenerateSkeleton {
						listParam.GenerateSkeleton = false
						listParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(listParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := listParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), listParam)

					// Run command with params
					return funcs.ServerList(ctx, listParam)

				},
			},
			{
				Name:  "build",
				Usage: "Build Server",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "core",
						Usage: "[Required] set CPU core count",
						Value: 1,
					},
					&cli.IntFlag{
						Name:  "memory",
						Usage: "[Required] set memory size(GB)",
						Value: 1,
					},
					&cli.StringFlag{
						Name:  "disk-mode",
						Usage: "[Required] disk create mode[create/connect/diskless]",
						Value: "create",
					},
					&cli.StringFlag{
						Name:  "os-type",
						Usage: "set source OS type",
					},
					&cli.StringFlag{
						Name:  "disk-plan",
						Usage: "set disk plan('hdd' or 'ssd')",
						Value: "ssd",
					},
					&cli.StringFlag{
						Name:  "disk-connection",
						Usage: "set disk connection('virtio' or 'ide')",
						Value: "virtio",
					},
					&cli.IntFlag{
						Name:  "disk-size",
						Usage: "set disk size(GB)",
						Value: 20,
					},
					&cli.Int64Flag{
						Name:  "source-archive-id",
						Usage: "set source disk ID",
					},
					&cli.Int64Flag{
						Name:  "source-disk-id",
						Usage: "set source disk ID",
					},
					&cli.Int64SliceFlag{
						Name:  "distant-from",
						Usage: "set distant from disk IDs",
					},
					&cli.Int64Flag{
						Name:  "disk-id",
						Usage: "set connect disk ID",
					},
					&cli.Int64Flag{
						Name:  "iso-image-id",
						Usage: "set iso-image ID",
					},
					&cli.StringFlag{
						Name:  "network-mode",
						Usage: "[Required] network connection mode[shared/switch/disconnect/none]",
						Value: "shared",
					},
					&cli.BoolFlag{
						Name:  "use-nic-virtio",
						Usage: "use virtio on nic",
						Value: true,
					},
					&cli.Int64Flag{
						Name:  "packet-filter-id",
						Usage: "set packet filter ID",
					},
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "set connect switch ID",
					},
					&cli.StringFlag{
						Name:  "hostname",
						Usage: "set hostname",
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "set password",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.BoolFlag{
						Name:    "disable-password-auth",
						Aliases: []string{"disable-pw-auth"},
						Usage:   "disable password auth on SSH",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress  prefix",
						Value:   24,
					},
					&cli.StringFlag{
						Name:    "default-route",
						Aliases: []string{"gateway"},
						Usage:   "set default gateway",
					},
					&cli.StringSliceFlag{
						Name:    "startup-scripts",
						Aliases: []string{"notes"},
						Usage:   "set startup script(s)",
					},
					&cli.Int64SliceFlag{
						Name:    "startup-script-ids",
						Aliases: []string{"note-ids"},
						Usage:   "set startup script ID(s)",
					},
					&cli.BoolFlag{
						Name:  "startup-scripts-ephemeral",
						Usage: "set startup script persist mode",
						Value: true,
					},
					&cli.StringFlag{
						Name:  "ssh-key-mode",
						Usage: "ssh-key mode[none/id/generate/upload]",
					},
					&cli.StringFlag{
						Name:  "ssh-key-name",
						Usage: "set ssh-key name",
					},
					&cli.Int64SliceFlag{
						Name:  "ssh-key-ids",
						Usage: "set ssh-key ID(s)",
					},
					&cli.StringFlag{
						Name:  "ssh-key-pass-phrase",
						Usage: "set ssh-key pass phrase",
					},
					&cli.StringFlag{
						Name:  "ssh-key-description",
						Usage: "set ssh-key description",
					},
					&cli.StringFlag{
						Name:  "ssh-key-private-key-output",
						Usage: "set ssh-key privatekey output path",
					},
					&cli.StringSliceFlag{
						Name:  "ssh-key-public-keys",
						Usage: "set ssh-key public key ",
					},
					&cli.StringSliceFlag{
						Name:  "ssh-key-public-key-files",
						Usage: "set ssh-key public key file",
					},
					&cli.BoolFlag{
						Name:  "ssh-key-ephemeral",
						Usage: "set ssh-key persist mode",
						Value: true,
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "[Required] set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.BoolFlag{
						Name:  "us-keyboard",
						Usage: "use us-keyboard",
					},
					&cli.BoolFlag{
						Name:  "disable-boot-after-create",
						Usage: "boot after create",
						Value: false,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, buildParam)

					// Set option values
					if c.IsSet("core") {
						buildParam.Core = c.Int("core")
					}
					if c.IsSet("memory") {
						buildParam.Memory = c.Int("memory")
					}
					if c.IsSet("disk-mode") {
						buildParam.DiskMode = c.String("disk-mode")
					}
					if c.IsSet("os-type") {
						buildParam.OsType = c.String("os-type")
					}
					if c.IsSet("disk-plan") {
						buildParam.DiskPlan = c.String("disk-plan")
					}
					if c.IsSet("disk-connection") {
						buildParam.DiskConnection = c.String("disk-connection")
					}
					if c.IsSet("disk-size") {
						buildParam.DiskSize = c.Int("disk-size")
					}
					if c.IsSet("source-archive-id") {
						buildParam.SourceArchiveId = c.Int64("source-archive-id")
					}
					if c.IsSet("source-disk-id") {
						buildParam.SourceDiskId = c.Int64("source-disk-id")
					}
					if c.IsSet("distant-from") {
						buildParam.DistantFrom = c.Int64Slice("distant-from")
					}
					if c.IsSet("disk-id") {
						buildParam.DiskId = c.Int64("disk-id")
					}
					if c.IsSet("iso-image-id") {
						buildParam.IsoImageId = c.Int64("iso-image-id")
					}
					if c.IsSet("network-mode") {
						buildParam.NetworkMode = c.String("network-mode")
					}
					if c.IsSet("use-nic-virtio") {
						buildParam.UseNicVirtio = c.Bool("use-nic-virtio")
					}
					if c.IsSet("packet-filter-id") {
						buildParam.PacketFilterId = c.Int64("packet-filter-id")
					}
					if c.IsSet("switch-id") {
						buildParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("hostname") {
						buildParam.Hostname = c.String("hostname")
					}
					if c.IsSet("password") || command.IsEmpty(buildParam.Password) {
						buildParam.Password = c.String("password")
					}
					if c.IsSet("disable-password-auth") {
						buildParam.DisablePasswordAuth = c.Bool("disable-password-auth")
					}
					if c.IsSet("ipaddress") {
						buildParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("nw-masklen") {
						buildParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("default-route") {
						buildParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("startup-scripts") {
						buildParam.StartupScripts = c.StringSlice("startup-scripts")
					}
					if c.IsSet("startup-script-ids") {
						buildParam.StartupScriptIds = c.Int64Slice("startup-script-ids")
					}
					if c.IsSet("startup-scripts-ephemeral") {
						buildParam.StartupScriptsEphemeral = c.Bool("startup-scripts-ephemeral")
					}
					if c.IsSet("ssh-key-mode") {
						buildParam.SshKeyMode = c.String("ssh-key-mode")
					}
					if c.IsSet("ssh-key-name") {
						buildParam.SshKeyName = c.String("ssh-key-name")
					}
					if c.IsSet("ssh-key-ids") {
						buildParam.SshKeyIds = c.Int64Slice("ssh-key-ids")
					}
					if c.IsSet("ssh-key-pass-phrase") {
						buildParam.SshKeyPassPhrase = c.String("ssh-key-pass-phrase")
					}
					if c.IsSet("ssh-key-description") {
						buildParam.SshKeyDescription = c.String("ssh-key-description")
					}
					if c.IsSet("ssh-key-private-key-output") {
						buildParam.SshKeyPrivateKeyOutput = c.String("ssh-key-private-key-output")
					}
					if c.IsSet("ssh-key-public-keys") {
						buildParam.SshKeyPublicKeys = c.StringSlice("ssh-key-public-keys")
					}
					if c.IsSet("ssh-key-public-key-files") {
						buildParam.SshKeyPublicKeyFiles = c.StringSlice("ssh-key-public-key-files")
					}
					if c.IsSet("ssh-key-ephemeral") {
						buildParam.SshKeyEphemeral = c.Bool("ssh-key-ephemeral")
					}
					if c.IsSet("name") {
						buildParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						buildParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						buildParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						buildParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						buildParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						buildParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						buildParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						buildParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						buildParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						buildParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						buildParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						buildParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						buildParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("us-keyboard") {
						buildParam.UsKeyboard = c.Bool("us-keyboard")
					}
					if c.IsSet("disable-boot-after-create") {
						buildParam.DisableBootAfterCreate = c.Bool("disable-boot-after-create")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerBuildCompleteArgs(ctx, buildParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerBuildCompleteArgs(ctx, buildParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerBuildCompleteFlags(ctx, buildParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerBuildCompleteArgs(ctx, buildParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					buildParam.ParamTemplate = c.String("param-template")
					buildParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(buildParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBuildServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(buildParam, p)
					}

					// Set option values
					if c.IsSet("core") {
						buildParam.Core = c.Int("core")
					}
					if c.IsSet("memory") {
						buildParam.Memory = c.Int("memory")
					}
					if c.IsSet("disk-mode") {
						buildParam.DiskMode = c.String("disk-mode")
					}
					if c.IsSet("os-type") {
						buildParam.OsType = c.String("os-type")
					}
					if c.IsSet("disk-plan") {
						buildParam.DiskPlan = c.String("disk-plan")
					}
					if c.IsSet("disk-connection") {
						buildParam.DiskConnection = c.String("disk-connection")
					}
					if c.IsSet("disk-size") {
						buildParam.DiskSize = c.Int("disk-size")
					}
					if c.IsSet("source-archive-id") {
						buildParam.SourceArchiveId = c.Int64("source-archive-id")
					}
					if c.IsSet("source-disk-id") {
						buildParam.SourceDiskId = c.Int64("source-disk-id")
					}
					if c.IsSet("distant-from") {
						buildParam.DistantFrom = c.Int64Slice("distant-from")
					}
					if c.IsSet("disk-id") {
						buildParam.DiskId = c.Int64("disk-id")
					}
					if c.IsSet("iso-image-id") {
						buildParam.IsoImageId = c.Int64("iso-image-id")
					}
					if c.IsSet("network-mode") {
						buildParam.NetworkMode = c.String("network-mode")
					}
					if c.IsSet("use-nic-virtio") {
						buildParam.UseNicVirtio = c.Bool("use-nic-virtio")
					}
					if c.IsSet("packet-filter-id") {
						buildParam.PacketFilterId = c.Int64("packet-filter-id")
					}
					if c.IsSet("switch-id") {
						buildParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("hostname") {
						buildParam.Hostname = c.String("hostname")
					}
					if c.IsSet("password") || command.IsEmpty(buildParam.Password) {
						buildParam.Password = c.String("password")
					}
					if c.IsSet("disable-password-auth") {
						buildParam.DisablePasswordAuth = c.Bool("disable-password-auth")
					}
					if c.IsSet("ipaddress") {
						buildParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("nw-masklen") {
						buildParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("default-route") {
						buildParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("startup-scripts") {
						buildParam.StartupScripts = c.StringSlice("startup-scripts")
					}
					if c.IsSet("startup-script-ids") {
						buildParam.StartupScriptIds = c.Int64Slice("startup-script-ids")
					}
					if c.IsSet("startup-scripts-ephemeral") {
						buildParam.StartupScriptsEphemeral = c.Bool("startup-scripts-ephemeral")
					}
					if c.IsSet("ssh-key-mode") {
						buildParam.SshKeyMode = c.String("ssh-key-mode")
					}
					if c.IsSet("ssh-key-name") {
						buildParam.SshKeyName = c.String("ssh-key-name")
					}
					if c.IsSet("ssh-key-ids") {
						buildParam.SshKeyIds = c.Int64Slice("ssh-key-ids")
					}
					if c.IsSet("ssh-key-pass-phrase") {
						buildParam.SshKeyPassPhrase = c.String("ssh-key-pass-phrase")
					}
					if c.IsSet("ssh-key-description") {
						buildParam.SshKeyDescription = c.String("ssh-key-description")
					}
					if c.IsSet("ssh-key-private-key-output") {
						buildParam.SshKeyPrivateKeyOutput = c.String("ssh-key-private-key-output")
					}
					if c.IsSet("ssh-key-public-keys") {
						buildParam.SshKeyPublicKeys = c.StringSlice("ssh-key-public-keys")
					}
					if c.IsSet("ssh-key-public-key-files") {
						buildParam.SshKeyPublicKeyFiles = c.StringSlice("ssh-key-public-key-files")
					}
					if c.IsSet("ssh-key-ephemeral") {
						buildParam.SshKeyEphemeral = c.Bool("ssh-key-ephemeral")
					}
					if c.IsSet("name") {
						buildParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						buildParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						buildParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						buildParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						buildParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						buildParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						buildParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						buildParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						buildParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						buildParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						buildParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						buildParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						buildParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("us-keyboard") {
						buildParam.UsKeyboard = c.Bool("us-keyboard")
					}
					if c.IsSet("disable-boot-after-create") {
						buildParam.DisableBootAfterCreate = c.Bool("disable-boot-after-create")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if buildParam.GenerateSkeleton {
						buildParam.GenerateSkeleton = false
						buildParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(buildParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := buildParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), buildParam)

					// confirm
					if !buildParam.Assumeyes && !command.ConfirmContinue("build") {
						return nil
					}

					// Run command with params
					return funcs.ServerBuild(ctx, buildParam)

				},
			},
			{
				Name:      "read",
				Usage:     "Read Server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, readParam)

					// Set option values
					if c.IsSet("selector") {
						readParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						readParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						readParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						readParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						readParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						readParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						readParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						readParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						readParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						readParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerReadCompleteArgs(ctx, readParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerReadCompleteArgs(ctx, readParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerReadCompleteFlags(ctx, readParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerReadCompleteArgs(ctx, readParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					readParam.ParamTemplate = c.String("param-template")
					readParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(readParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewReadServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(readParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						readParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						readParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						readParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						readParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						readParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						readParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						readParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						readParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						readParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						readParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if readParam.GenerateSkeleton {
						readParam.GenerateSkeleton = false
						readParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(readParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := readParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), readParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(readParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, readParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", readParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(readParam.Selector) == 0 || hasTags(&v, readParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						readParam.SetId(id)
						p := *readParam // copy struct value
						readParam := &p
						go func() {
							err := funcs.ServerRead(ctx, readParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "update",
				Usage:     "Update Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, updateParam)

					// Set option values
					if c.IsSet("selector") {
						updateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						updateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						updateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						updateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						updateParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						updateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						updateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						updateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						updateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						updateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						updateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						updateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						updateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						updateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						updateParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerUpdateCompleteFlags(ctx, updateParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerUpdateCompleteArgs(ctx, updateParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					updateParam.ParamTemplate = c.String("param-template")
					updateParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(updateParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewUpdateServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(updateParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						updateParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("name") {
						updateParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						updateParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						updateParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						updateParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("assumeyes") {
						updateParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						updateParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						updateParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						updateParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						updateParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						updateParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						updateParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						updateParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						updateParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						updateParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if updateParam.GenerateSkeleton {
						updateParam.GenerateSkeleton = false
						updateParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(updateParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := updateParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), updateParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(updateParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, updateParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", updateParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(updateParam.Selector) == 0 || hasTags(&v, updateParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !updateParam.Assumeyes && !command.ConfirmContinue("update", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						updateParam.SetId(id)
						p := *updateParam // copy struct value
						updateParam := &p
						go func() {
							err := funcs.ServerUpdate(ctx, updateParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "delete",
				Aliases:   []string{"rm"},
				Usage:     "Delete Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:    "force",
						Aliases: []string{"f"},
						Usage:   "forced-shutdown flag if server is running",
					},
					&cli.BoolFlag{
						Name:  "without-disk",
						Usage: "don't delete connected disks with server",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, deleteParam)

					// Set option values
					if c.IsSet("force") {
						deleteParam.Force = c.Bool("force")
					}
					if c.IsSet("without-disk") {
						deleteParam.WithoutDisk = c.Bool("without-disk")
					}
					if c.IsSet("selector") {
						deleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						deleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						deleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						deleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						deleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						deleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						deleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						deleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						deleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						deleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						deleteParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDeleteCompleteFlags(ctx, deleteParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDeleteCompleteArgs(ctx, deleteParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					deleteParam.ParamTemplate = c.String("param-template")
					deleteParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(deleteParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDeleteServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(deleteParam, p)
					}

					// Set option values
					if c.IsSet("force") {
						deleteParam.Force = c.Bool("force")
					}
					if c.IsSet("without-disk") {
						deleteParam.WithoutDisk = c.Bool("without-disk")
					}
					if c.IsSet("selector") {
						deleteParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						deleteParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						deleteParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						deleteParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						deleteParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						deleteParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						deleteParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						deleteParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						deleteParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						deleteParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						deleteParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if deleteParam.GenerateSkeleton {
						deleteParam.GenerateSkeleton = false
						deleteParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(deleteParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := deleteParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), deleteParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(deleteParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, deleteParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", deleteParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(deleteParam.Selector) == 0 || hasTags(&v, deleteParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !deleteParam.Assumeyes && !command.ConfirmContinue("delete", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						deleteParam.SetId(id)
						p := *deleteParam // copy struct value
						deleteParam := &p
						go func() {
							err := funcs.ServerDelete(ctx, deleteParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "plan-change",
				Usage:     "Change server plan(core/memory)",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.IntFlag{
						Name:  "core",
						Usage: "[Required] set CPU core count",
					},
					&cli.IntFlag{
						Name:  "memory",
						Usage: "[Required] set memory size(GB)",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, planChangeParam)

					// Set option values
					if c.IsSet("core") {
						planChangeParam.Core = c.Int("core")
					}
					if c.IsSet("memory") {
						planChangeParam.Memory = c.Int("memory")
					}
					if c.IsSet("selector") {
						planChangeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						planChangeParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						planChangeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						planChangeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						planChangeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						planChangeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						planChangeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						planChangeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						planChangeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						planChangeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						planChangeParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerPlanChangeCompleteArgs(ctx, planChangeParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerPlanChangeCompleteArgs(ctx, planChangeParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerPlanChangeCompleteFlags(ctx, planChangeParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerPlanChangeCompleteArgs(ctx, planChangeParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					planChangeParam.ParamTemplate = c.String("param-template")
					planChangeParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(planChangeParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewPlanChangeServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(planChangeParam, p)
					}

					// Set option values
					if c.IsSet("core") {
						planChangeParam.Core = c.Int("core")
					}
					if c.IsSet("memory") {
						planChangeParam.Memory = c.Int("memory")
					}
					if c.IsSet("selector") {
						planChangeParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						planChangeParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						planChangeParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						planChangeParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						planChangeParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						planChangeParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						planChangeParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						planChangeParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						planChangeParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						planChangeParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						planChangeParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if planChangeParam.GenerateSkeleton {
						planChangeParam.GenerateSkeleton = false
						planChangeParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(planChangeParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := planChangeParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), planChangeParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(planChangeParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, planChangeParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", planChangeParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(planChangeParam.Selector) == 0 || hasTags(&v, planChangeParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !planChangeParam.Assumeyes && !command.ConfirmContinue("plan-change", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						planChangeParam.SetId(id)
						p := *planChangeParam // copy struct value
						planChangeParam := &p
						go func() {
							err := funcs.ServerPlanChange(ctx, planChangeParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "boot",
				Aliases:   []string{"power-on"},
				Usage:     "Boot Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, bootParam)

					// Set option values
					if c.IsSet("selector") {
						bootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						bootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						bootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						bootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						bootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						bootParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerBootCompleteFlags(ctx, bootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerBootCompleteArgs(ctx, bootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					bootParam.ParamTemplate = c.String("param-template")
					bootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(bootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewBootServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(bootParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						bootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						bootParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						bootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						bootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						bootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						bootParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if bootParam.GenerateSkeleton {
						bootParam.GenerateSkeleton = false
						bootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(bootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := bootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), bootParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(bootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, bootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", bootParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(bootParam.Selector) == 0 || hasTags(&v, bootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !bootParam.Assumeyes && !command.ConfirmContinue("boot", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						bootParam.SetId(id)
						p := *bootParam // copy struct value
						bootParam := &p
						go func() {
							err := funcs.ServerBoot(ctx, bootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown",
				Aliases:   []string{"power-off"},
				Usage:     "Shutdown Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownParam)

					// Set option values
					if c.IsSet("selector") {
						shutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerShutdownCompleteFlags(ctx, shutdownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerShutdownCompleteArgs(ctx, shutdownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					shutdownParam.ParamTemplate = c.String("param-template")
					shutdownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(shutdownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(shutdownParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						shutdownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if shutdownParam.GenerateSkeleton {
						shutdownParam.GenerateSkeleton = false
						shutdownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(shutdownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := shutdownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(shutdownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, shutdownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", shutdownParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(shutdownParam.Selector) == 0 || hasTags(&v, shutdownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !shutdownParam.Assumeyes && !command.ConfirmContinue("shutdown", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownParam.SetId(id)
						p := *shutdownParam // copy struct value
						shutdownParam := &p
						go func() {
							err := funcs.ServerShutdown(ctx, shutdownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "shutdown-force",
				Aliases:   []string{"stop"},
				Usage:     "ShutdownForce Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, shutdownForceParam)

					// Set option values
					if c.IsSet("selector") {
						shutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownForceParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerShutdownForceCompleteFlags(ctx, shutdownForceParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerShutdownForceCompleteArgs(ctx, shutdownForceParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					shutdownForceParam.ParamTemplate = c.String("param-template")
					shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(shutdownForceParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewShutdownForceServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(shutdownForceParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						shutdownForceParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						shutdownForceParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						shutdownForceParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						shutdownForceParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						shutdownForceParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						shutdownForceParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if shutdownForceParam.GenerateSkeleton {
						shutdownForceParam.GenerateSkeleton = false
						shutdownForceParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(shutdownForceParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := shutdownForceParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), shutdownForceParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(shutdownForceParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, shutdownForceParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", shutdownForceParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(shutdownForceParam.Selector) == 0 || hasTags(&v, shutdownForceParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !shutdownForceParam.Assumeyes && !command.ConfirmContinue("shutdown-force", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						shutdownForceParam.SetId(id)
						p := *shutdownForceParam // copy struct value
						shutdownForceParam := &p
						go func() {
							err := funcs.ServerShutdownForce(ctx, shutdownForceParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "reset",
				Usage:     "Reset Server",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, resetParam)

					// Set option values
					if c.IsSet("selector") {
						resetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						resetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						resetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						resetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						resetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						resetParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerResetCompleteFlags(ctx, resetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerResetCompleteArgs(ctx, resetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					resetParam.ParamTemplate = c.String("param-template")
					resetParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(resetParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewResetServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(resetParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						resetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						resetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						resetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						resetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						resetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						resetParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if resetParam.GenerateSkeleton {
						resetParam.GenerateSkeleton = false
						resetParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(resetParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := resetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), resetParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(resetParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, resetParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", resetParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(resetParam.Selector) == 0 || hasTags(&v, resetParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !resetParam.Assumeyes && !command.ConfirmContinue("reset", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						resetParam.SetId(id)
						p := *resetParam // copy struct value
						resetParam := &p
						go func() {
							err := funcs.ServerReset(ctx, resetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-boot",
				Usage:     "Wait until boot is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForBootParam)

					// Set option values
					if c.IsSet("selector") {
						waitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForBootParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerWaitForBootCompleteFlags(ctx, waitForBootParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerWaitForBootCompleteArgs(ctx, waitForBootParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					waitForBootParam.ParamTemplate = c.String("param-template")
					waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(waitForBootParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForBootServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(waitForBootParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						waitForBootParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForBootParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForBootParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForBootParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForBootParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if waitForBootParam.GenerateSkeleton {
						waitForBootParam.GenerateSkeleton = false
						waitForBootParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(waitForBootParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := waitForBootParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForBootParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(waitForBootParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, waitForBootParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", waitForBootParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(waitForBootParam.Selector) == 0 || hasTags(&v, waitForBootParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForBootParam.SetId(id)
						p := *waitForBootParam // copy struct value
						waitForBootParam := &p
						go func() {
							err := funcs.ServerWaitForBoot(ctx, waitForBootParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "wait-for-down",
				Usage:     "Wait until shutdown is completed",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, waitForDownParam)

					// Set option values
					if c.IsSet("selector") {
						waitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForDownParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerWaitForDownCompleteFlags(ctx, waitForDownParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerWaitForDownCompleteArgs(ctx, waitForDownParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					waitForDownParam.ParamTemplate = c.String("param-template")
					waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(waitForDownParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewWaitForDownServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(waitForDownParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						waitForDownParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						waitForDownParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						waitForDownParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						waitForDownParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						waitForDownParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if waitForDownParam.GenerateSkeleton {
						waitForDownParam.GenerateSkeleton = false
						waitForDownParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(waitForDownParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := waitForDownParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), waitForDownParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(waitForDownParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, waitForDownParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", waitForDownParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(waitForDownParam.Selector) == 0 || hasTags(&v, waitForDownParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						waitForDownParam.SetId(id)
						p := *waitForDownParam // copy struct value
						waitForDownParam := &p
						go func() {
							err := funcs.ServerWaitForDown(ctx, waitForDownParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "ssh",
				Usage:     "Connect to server by SSH",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "key",
						Aliases: []string{"i"},
						Usage:   "private-key file path",
					},
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "user name",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   22,
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "password(or private-key pass phrase)",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "disable information messages",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, sshParam)

					// Set option values
					if c.IsSet("key") {
						sshParam.Key = c.String("key")
					}
					if c.IsSet("user") {
						sshParam.User = c.String("user")
					}
					if c.IsSet("port") {
						sshParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(sshParam.Password) {
						sshParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						sshParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						sshParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						sshParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						sshParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						sshParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("id") {
						sshParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerSshCompleteArgs(ctx, sshParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerSshCompleteArgs(ctx, sshParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerSshCompleteFlags(ctx, sshParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerSshCompleteArgs(ctx, sshParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					sshParam.ParamTemplate = c.String("param-template")
					sshParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(sshParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSshServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(sshParam, p)
					}

					// Set option values
					if c.IsSet("key") {
						sshParam.Key = c.String("key")
					}
					if c.IsSet("user") {
						sshParam.User = c.String("user")
					}
					if c.IsSet("port") {
						sshParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(sshParam.Password) {
						sshParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						sshParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						sshParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						sshParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						sshParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						sshParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("id") {
						sshParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if sshParam.GenerateSkeleton {
						sshParam.GenerateSkeleton = false
						sshParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(sshParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := sshParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), sshParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(sshParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, sshParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", sshParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(sshParam.Selector) == 0 || hasTags(&v, sshParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						sshParam.SetId(id)
						p := *sshParam // copy struct value
						sshParam := &p
						go func() {
							err := funcs.ServerSsh(ctx, sshParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "ssh-exec",
				Usage:     "Execute command on server connected by SSH",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "key",
						Aliases: []string{"i"},
						Usage:   "private-key file path",
					},
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "user name",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   22,
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "password(or private-key pass phrase)",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "disable information messages",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, sshExecParam)

					// Set option values
					if c.IsSet("key") {
						sshExecParam.Key = c.String("key")
					}
					if c.IsSet("user") {
						sshExecParam.User = c.String("user")
					}
					if c.IsSet("port") {
						sshExecParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(sshExecParam.Password) {
						sshExecParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						sshExecParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						sshExecParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						sshExecParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						sshExecParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						sshExecParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("id") {
						sshExecParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerSshExecCompleteArgs(ctx, sshExecParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerSshExecCompleteArgs(ctx, sshExecParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerSshExecCompleteFlags(ctx, sshExecParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerSshExecCompleteArgs(ctx, sshExecParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					sshExecParam.ParamTemplate = c.String("param-template")
					sshExecParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(sshExecParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewSshExecServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(sshExecParam, p)
					}

					// Set option values
					if c.IsSet("key") {
						sshExecParam.Key = c.String("key")
					}
					if c.IsSet("user") {
						sshExecParam.User = c.String("user")
					}
					if c.IsSet("port") {
						sshExecParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(sshExecParam.Password) {
						sshExecParam.Password = c.String("password")
					}
					if c.IsSet("selector") {
						sshExecParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						sshExecParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						sshExecParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						sshExecParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						sshExecParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("id") {
						sshExecParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if sshExecParam.GenerateSkeleton {
						sshExecParam.GenerateSkeleton = false
						sshExecParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(sshExecParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := sshExecParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), sshExecParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(sshExecParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, sshExecParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", sshExecParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(sshExecParam.Selector) == 0 || hasTags(&v, sshExecParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						sshExecParam.SetId(id)
						p := *sshExecParam // copy struct value
						sshExecParam := &p
						go func() {
							err := funcs.ServerSshExec(ctx, sshExecParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "scp",
				Usage:     "Copy files/directories by SSH",
				ArgsUsage: "[ServerID:]<FROM> [ServerID:]<TO>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "key",
						Aliases: []string{"i"},
						Usage:   "private-key file path",
					},
					&cli.BoolFlag{
						Name:    "recursive",
						Aliases: []string{"r"},
						Usage:   "set recursive copy flag",
					},
					&cli.StringFlag{
						Name:    "user",
						Aliases: []string{"l"},
						Usage:   "user name",
					},
					&cli.IntFlag{
						Name:    "port",
						Aliases: []string{"p"},
						Usage:   "[Required] port",
						Value:   22,
					},
					&cli.StringFlag{
						Name:    "password",
						Usage:   "password(or private-key pass phrase)",
						EnvVars: []string{"SAKURACLOUD_SERVER_PASSWORD"},
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "disable information messages",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, scpParam)

					// Set option values
					if c.IsSet("key") {
						scpParam.Key = c.String("key")
					}
					if c.IsSet("recursive") {
						scpParam.Recursive = c.Bool("recursive")
					}
					if c.IsSet("user") {
						scpParam.User = c.String("user")
					}
					if c.IsSet("port") {
						scpParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(scpParam.Password) {
						scpParam.Password = c.String("password")
					}
					if c.IsSet("assumeyes") {
						scpParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						scpParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						scpParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						scpParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						scpParam.Quiet = c.Bool("quiet")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerScpCompleteArgs(ctx, scpParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerScpCompleteArgs(ctx, scpParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerScpCompleteFlags(ctx, scpParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerScpCompleteArgs(ctx, scpParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					scpParam.ParamTemplate = c.String("param-template")
					scpParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(scpParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewScpServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(scpParam, p)
					}

					// Set option values
					if c.IsSet("key") {
						scpParam.Key = c.String("key")
					}
					if c.IsSet("recursive") {
						scpParam.Recursive = c.Bool("recursive")
					}
					if c.IsSet("user") {
						scpParam.User = c.String("user")
					}
					if c.IsSet("port") {
						scpParam.Port = c.Int("port")
					}
					if c.IsSet("password") || command.IsEmpty(scpParam.Password) {
						scpParam.Password = c.String("password")
					}
					if c.IsSet("assumeyes") {
						scpParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						scpParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						scpParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						scpParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("quiet") {
						scpParam.Quiet = c.Bool("quiet")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if scpParam.GenerateSkeleton {
						scpParam.GenerateSkeleton = false
						scpParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(scpParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := scpParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), scpParam)

					// confirm
					if !scpParam.Assumeyes && !command.ConfirmContinue("scp") {
						return nil
					}

					// Run command with params
					return funcs.ServerScp(ctx, scpParam)

				},
			},
			{
				Name:      "vnc",
				Usage:     "Open VNC client using the OS's default application",
				ArgsUsage: "<ID or Name(allow multiple target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, vncParam)

					// Set option values
					if c.IsSet("wait-for-boot") {
						vncParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						vncParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						vncParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						vncParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						vncParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						vncParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						vncParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerVncCompleteArgs(ctx, vncParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerVncCompleteArgs(ctx, vncParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerVncCompleteFlags(ctx, vncParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerVncCompleteArgs(ctx, vncParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					vncParam.ParamTemplate = c.String("param-template")
					vncParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(vncParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(vncParam, p)
					}

					// Set option values
					if c.IsSet("wait-for-boot") {
						vncParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						vncParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						vncParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						vncParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						vncParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						vncParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						vncParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if vncParam.GenerateSkeleton {
						vncParam.GenerateSkeleton = false
						vncParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(vncParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := vncParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), vncParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(vncParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, vncParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", vncParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(vncParam.Selector) == 0 || hasTags(&v, vncParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					// confirm
					if !vncParam.Assumeyes && !command.ConfirmContinue("open VNC client", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						vncParam.SetId(id)
						p := *vncParam // copy struct value
						vncParam := &p
						go func() {
							err := funcs.ServerVnc(ctx, vncParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-info",
				Usage:     "Show VNC proxy information",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, vncInfoParam)

					// Set option values
					if c.IsSet("wait-for-boot") {
						vncInfoParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						vncInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						vncInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						vncInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						vncInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						vncInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						vncInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						vncInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						vncInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						vncInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						vncInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerVncInfoCompleteArgs(ctx, vncInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerVncInfoCompleteArgs(ctx, vncInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerVncInfoCompleteFlags(ctx, vncInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerVncInfoCompleteArgs(ctx, vncInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					vncInfoParam.ParamTemplate = c.String("param-template")
					vncInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(vncInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(vncInfoParam, p)
					}

					// Set option values
					if c.IsSet("wait-for-boot") {
						vncInfoParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						vncInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						vncInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						vncInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						vncInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						vncInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						vncInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						vncInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						vncInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						vncInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						vncInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if vncInfoParam.GenerateSkeleton {
						vncInfoParam.GenerateSkeleton = false
						vncInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(vncInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := vncInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), vncInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(vncInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, vncInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", vncInfoParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(vncInfoParam.Selector) == 0 || hasTags(&v, vncInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						vncInfoParam.SetId(id)
						p := *vncInfoParam // copy struct value
						vncInfoParam := &p
						go func() {
							err := funcs.ServerVncInfo(ctx, vncInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "vnc-send",
				Usage:     "Send keys over VNC connection",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:    "command",
						Aliases: []string{"c"},
						Usage:   "command(compatible with HashiCorp Packer's boot_command)",
					},
					&cli.StringFlag{
						Name:    "command-file",
						Aliases: []string{"f"},
						Usage:   "command file(compatible with HashiCorp Packer's boot_command)",
					},
					&cli.BoolFlag{
						Name:  "use-us-keyboard",
						Usage: "use US Keyboard",
					},
					&cli.BoolFlag{
						Name:    "debug",
						Aliases: []string{"d"},
						Usage:   "write debug info",
					},
					&cli.BoolFlag{
						Name:  "wait-for-boot",
						Usage: "wait until the server starts up",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, vncSendParam)

					// Set option values
					if c.IsSet("command") {
						vncSendParam.Command = c.String("command")
					}
					if c.IsSet("command-file") {
						vncSendParam.CommandFile = c.String("command-file")
					}
					if c.IsSet("use-us-keyboard") {
						vncSendParam.UseUsKeyboard = c.Bool("use-us-keyboard")
					}
					if c.IsSet("debug") {
						vncSendParam.Debug = c.Bool("debug")
					}
					if c.IsSet("wait-for-boot") {
						vncSendParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						vncSendParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						vncSendParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						vncSendParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						vncSendParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						vncSendParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						vncSendParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						vncSendParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						vncSendParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						vncSendParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						vncSendParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						vncSendParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerVncSendCompleteArgs(ctx, vncSendParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerVncSendCompleteArgs(ctx, vncSendParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerVncSendCompleteFlags(ctx, vncSendParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerVncSendCompleteArgs(ctx, vncSendParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					vncSendParam.ParamTemplate = c.String("param-template")
					vncSendParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(vncSendParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewVncSendServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(vncSendParam, p)
					}

					// Set option values
					if c.IsSet("command") {
						vncSendParam.Command = c.String("command")
					}
					if c.IsSet("command-file") {
						vncSendParam.CommandFile = c.String("command-file")
					}
					if c.IsSet("use-us-keyboard") {
						vncSendParam.UseUsKeyboard = c.Bool("use-us-keyboard")
					}
					if c.IsSet("debug") {
						vncSendParam.Debug = c.Bool("debug")
					}
					if c.IsSet("wait-for-boot") {
						vncSendParam.WaitForBoot = c.Bool("wait-for-boot")
					}
					if c.IsSet("selector") {
						vncSendParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						vncSendParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						vncSendParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						vncSendParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						vncSendParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						vncSendParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						vncSendParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						vncSendParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						vncSendParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						vncSendParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						vncSendParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if vncSendParam.GenerateSkeleton {
						vncSendParam.GenerateSkeleton = false
						vncSendParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(vncSendParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := vncSendParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), vncSendParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(vncSendParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, vncSendParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", vncSendParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(vncSendParam.Selector) == 0 || hasTags(&v, vncSendParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !vncSendParam.Assumeyes && !command.ConfirmContinue("vnc-send", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						vncSendParam.SetId(id)
						p := *vncSendParam // copy struct value
						vncSendParam := &p
						go func() {
							err := funcs.ServerVncSend(ctx, vncSendParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-info",
				Aliases:   []string{"disk-list"},
				Usage:     "Show information of disk(s) connected to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, diskInfoParam)

					// Set option values
					if c.IsSet("selector") {
						diskInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						diskInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						diskInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						diskInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						diskInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						diskInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						diskInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						diskInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						diskInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						diskInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDiskInfoCompleteArgs(ctx, diskInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDiskInfoCompleteArgs(ctx, diskInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDiskInfoCompleteFlags(ctx, diskInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDiskInfoCompleteArgs(ctx, diskInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					diskInfoParam.ParamTemplate = c.String("param-template")
					diskInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(diskInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDiskInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(diskInfoParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						diskInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						diskInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						diskInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						diskInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						diskInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						diskInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						diskInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						diskInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						diskInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						diskInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if diskInfoParam.GenerateSkeleton {
						diskInfoParam.GenerateSkeleton = false
						diskInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(diskInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := diskInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), diskInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(diskInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, diskInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", diskInfoParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(diskInfoParam.Selector) == 0 || hasTags(&v, diskInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						diskInfoParam.SetId(id)
						p := *diskInfoParam // copy struct value
						diskInfoParam := &p
						go func() {
							err := funcs.ServerDiskInfo(ctx, diskInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-connect",
				Usage:     "Connect disk to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "disk-id",
						Usage: "[Required] set target disk ID",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, diskConnectParam)

					// Set option values
					if c.IsSet("disk-id") {
						diskConnectParam.DiskId = c.Int64("disk-id")
					}
					if c.IsSet("selector") {
						diskConnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						diskConnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						diskConnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						diskConnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						diskConnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						diskConnectParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDiskConnectCompleteArgs(ctx, diskConnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDiskConnectCompleteArgs(ctx, diskConnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDiskConnectCompleteFlags(ctx, diskConnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDiskConnectCompleteArgs(ctx, diskConnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					diskConnectParam.ParamTemplate = c.String("param-template")
					diskConnectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(diskConnectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDiskConnectServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(diskConnectParam, p)
					}

					// Set option values
					if c.IsSet("disk-id") {
						diskConnectParam.DiskId = c.Int64("disk-id")
					}
					if c.IsSet("selector") {
						diskConnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						diskConnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						diskConnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						diskConnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						diskConnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						diskConnectParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if diskConnectParam.GenerateSkeleton {
						diskConnectParam.GenerateSkeleton = false
						diskConnectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(diskConnectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := diskConnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), diskConnectParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(diskConnectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, diskConnectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", diskConnectParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(diskConnectParam.Selector) == 0 || hasTags(&v, diskConnectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !diskConnectParam.Assumeyes && !command.ConfirmContinue("disk-connect", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						diskConnectParam.SetId(id)
						p := *diskConnectParam // copy struct value
						diskConnectParam := &p
						go func() {
							err := funcs.ServerDiskConnect(ctx, diskConnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "disk-disconnect",
				Usage:     "Disconnect disk from server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "disk-id",
						Usage: "[Required] set target disk ID",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, diskDisconnectParam)

					// Set option values
					if c.IsSet("disk-id") {
						diskDisconnectParam.DiskId = c.Int64("disk-id")
					}
					if c.IsSet("selector") {
						diskDisconnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						diskDisconnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						diskDisconnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						diskDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						diskDisconnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						diskDisconnectParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerDiskDisconnectCompleteArgs(ctx, diskDisconnectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerDiskDisconnectCompleteArgs(ctx, diskDisconnectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerDiskDisconnectCompleteFlags(ctx, diskDisconnectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerDiskDisconnectCompleteArgs(ctx, diskDisconnectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					diskDisconnectParam.ParamTemplate = c.String("param-template")
					diskDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(diskDisconnectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewDiskDisconnectServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(diskDisconnectParam, p)
					}

					// Set option values
					if c.IsSet("disk-id") {
						diskDisconnectParam.DiskId = c.Int64("disk-id")
					}
					if c.IsSet("selector") {
						diskDisconnectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						diskDisconnectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						diskDisconnectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						diskDisconnectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						diskDisconnectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						diskDisconnectParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if diskDisconnectParam.GenerateSkeleton {
						diskDisconnectParam.GenerateSkeleton = false
						diskDisconnectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(diskDisconnectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := diskDisconnectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), diskDisconnectParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(diskDisconnectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, diskDisconnectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", diskDisconnectParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(diskDisconnectParam.Selector) == 0 || hasTags(&v, diskDisconnectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !diskDisconnectParam.Assumeyes && !command.ConfirmContinue("disk-disconnect", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						diskDisconnectParam.SetId(id)
						p := *diskDisconnectParam // copy struct value
						diskDisconnectParam := &p
						go func() {
							err := funcs.ServerDiskDisconnect(ctx, diskDisconnectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-info",
				Aliases:   []string{"interface-list"},
				Usage:     "Show information of NIC(s) connected to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceInfoParam)

					// Set option values
					if c.IsSet("selector") {
						interfaceInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						interfaceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						interfaceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						interfaceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						interfaceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						interfaceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						interfaceInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						interfaceInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceInfoCompleteFlags(ctx, interfaceInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceInfoCompleteArgs(ctx, interfaceInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					interfaceInfoParam.ParamTemplate = c.String("param-template")
					interfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(interfaceInfoParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						interfaceInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						interfaceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						interfaceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						interfaceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						interfaceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						interfaceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						interfaceInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						interfaceInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if interfaceInfoParam.GenerateSkeleton {
						interfaceInfoParam.GenerateSkeleton = false
						interfaceInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, interfaceInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceInfoParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(interfaceInfoParam.Selector) == 0 || hasTags(&v, interfaceInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceInfoParam.SetId(id)
						p := *interfaceInfoParam // copy struct value
						interfaceInfoParam := &p
						go func() {
							err := funcs.ServerInterfaceInfo(ctx, interfaceInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-internet",
				Usage:     "Create and connect NIC connected to the internet",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.BoolFlag{
						Name:  "without-disk-edit",
						Usage: "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddForInternetParam)

					// Set option values
					if c.IsSet("without-disk-edit") {
						interfaceAddForInternetParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("selector") {
						interfaceAddForInternetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddForInternetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddForInternetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddForInternetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddForInternetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddForInternetParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddForInternetCompleteArgs(ctx, interfaceAddForInternetParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddForInternetCompleteArgs(ctx, interfaceAddForInternetParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddForInternetCompleteFlags(ctx, interfaceAddForInternetParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddForInternetCompleteArgs(ctx, interfaceAddForInternetParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					interfaceAddForInternetParam.ParamTemplate = c.String("param-template")
					interfaceAddForInternetParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceAddForInternetParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddForInternetServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(interfaceAddForInternetParam, p)
					}

					// Set option values
					if c.IsSet("without-disk-edit") {
						interfaceAddForInternetParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("selector") {
						interfaceAddForInternetParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddForInternetParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddForInternetParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddForInternetParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddForInternetParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddForInternetParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if interfaceAddForInternetParam.GenerateSkeleton {
						interfaceAddForInternetParam.GenerateSkeleton = false
						interfaceAddForInternetParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceAddForInternetParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceAddForInternetParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddForInternetParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceAddForInternetParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, interfaceAddForInternetParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceAddForInternetParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(interfaceAddForInternetParam.Selector) == 0 || hasTags(&v, interfaceAddForInternetParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddForInternetParam.Assumeyes && !command.ConfirmContinue("interface-add-for-internet", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddForInternetParam.SetId(id)
						p := *interfaceAddForInternetParam // copy struct value
						interfaceAddForInternetParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForInternet(ctx, interfaceAddForInternetParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-router",
				Usage:     "Create and connect NIC connected to the router",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "[Required] set connect switch(connected to router) ID",
					},
					&cli.BoolFlag{
						Name:  "without-disk-edit",
						Usage: "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.StringFlag{
						Name:    "default-route",
						Aliases: []string{"gateway"},
						Usage:   "set default gateway",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress  prefix",
						Value:   24,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddForRouterParam)

					// Set option values
					if c.IsSet("switch-id") {
						interfaceAddForRouterParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("without-disk-edit") {
						interfaceAddForRouterParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("ipaddress") {
						interfaceAddForRouterParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("default-route") {
						interfaceAddForRouterParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("nw-masklen") {
						interfaceAddForRouterParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceAddForRouterParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddForRouterParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddForRouterParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddForRouterParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddForRouterParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddForRouterParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddForRouterCompleteArgs(ctx, interfaceAddForRouterParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddForRouterCompleteArgs(ctx, interfaceAddForRouterParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddForRouterCompleteFlags(ctx, interfaceAddForRouterParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddForRouterCompleteArgs(ctx, interfaceAddForRouterParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					interfaceAddForRouterParam.ParamTemplate = c.String("param-template")
					interfaceAddForRouterParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceAddForRouterParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddForRouterServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(interfaceAddForRouterParam, p)
					}

					// Set option values
					if c.IsSet("switch-id") {
						interfaceAddForRouterParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("without-disk-edit") {
						interfaceAddForRouterParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("ipaddress") {
						interfaceAddForRouterParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("default-route") {
						interfaceAddForRouterParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("nw-masklen") {
						interfaceAddForRouterParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceAddForRouterParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddForRouterParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddForRouterParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddForRouterParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddForRouterParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddForRouterParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if interfaceAddForRouterParam.GenerateSkeleton {
						interfaceAddForRouterParam.GenerateSkeleton = false
						interfaceAddForRouterParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceAddForRouterParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceAddForRouterParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddForRouterParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceAddForRouterParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, interfaceAddForRouterParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceAddForRouterParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(interfaceAddForRouterParam.Selector) == 0 || hasTags(&v, interfaceAddForRouterParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddForRouterParam.Assumeyes && !command.ConfirmContinue("interface-add-for-router", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddForRouterParam.SetId(id)
						p := *interfaceAddForRouterParam // copy struct value
						interfaceAddForRouterParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForRouter(ctx, interfaceAddForRouterParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-for-switch",
				Usage:     "Create and connect NIC connected to the switch",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "switch-id",
						Usage: "[Required] set connect switch ID",
					},
					&cli.BoolFlag{
						Name:  "without-disk-edit",
						Usage: "set skip edit-disk flag. if true, don't call DiskEdit API after interface added",
					},
					&cli.StringFlag{
						Name:    "ipaddress",
						Aliases: []string{"ip"},
						Usage:   "set ipaddress",
					},
					&cli.StringFlag{
						Name:    "default-route",
						Aliases: []string{"gateway"},
						Usage:   "set default gateway",
					},
					&cli.IntFlag{
						Name:    "nw-masklen",
						Aliases: []string{"network-masklen"},
						Usage:   "set ipaddress  prefix",
						Value:   24,
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddForSwitchParam)

					// Set option values
					if c.IsSet("switch-id") {
						interfaceAddForSwitchParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("without-disk-edit") {
						interfaceAddForSwitchParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("ipaddress") {
						interfaceAddForSwitchParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("default-route") {
						interfaceAddForSwitchParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("nw-masklen") {
						interfaceAddForSwitchParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceAddForSwitchParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddForSwitchParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddForSwitchParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddForSwitchParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddForSwitchParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddForSwitchParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddForSwitchCompleteArgs(ctx, interfaceAddForSwitchParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddForSwitchCompleteArgs(ctx, interfaceAddForSwitchParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddForSwitchCompleteFlags(ctx, interfaceAddForSwitchParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddForSwitchCompleteArgs(ctx, interfaceAddForSwitchParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					interfaceAddForSwitchParam.ParamTemplate = c.String("param-template")
					interfaceAddForSwitchParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceAddForSwitchParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddForSwitchServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(interfaceAddForSwitchParam, p)
					}

					// Set option values
					if c.IsSet("switch-id") {
						interfaceAddForSwitchParam.SwitchId = c.Int64("switch-id")
					}
					if c.IsSet("without-disk-edit") {
						interfaceAddForSwitchParam.WithoutDiskEdit = c.Bool("without-disk-edit")
					}
					if c.IsSet("ipaddress") {
						interfaceAddForSwitchParam.Ipaddress = c.String("ipaddress")
					}
					if c.IsSet("default-route") {
						interfaceAddForSwitchParam.DefaultRoute = c.String("default-route")
					}
					if c.IsSet("nw-masklen") {
						interfaceAddForSwitchParam.NwMasklen = c.Int("nw-masklen")
					}
					if c.IsSet("selector") {
						interfaceAddForSwitchParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddForSwitchParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddForSwitchParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddForSwitchParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddForSwitchParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddForSwitchParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if interfaceAddForSwitchParam.GenerateSkeleton {
						interfaceAddForSwitchParam.GenerateSkeleton = false
						interfaceAddForSwitchParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceAddForSwitchParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceAddForSwitchParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddForSwitchParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceAddForSwitchParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, interfaceAddForSwitchParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceAddForSwitchParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(interfaceAddForSwitchParam.Selector) == 0 || hasTags(&v, interfaceAddForSwitchParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddForSwitchParam.Assumeyes && !command.ConfirmContinue("interface-add-for-switch", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddForSwitchParam.SetId(id)
						p := *interfaceAddForSwitchParam // copy struct value
						interfaceAddForSwitchParam := &p
						go func() {
							err := funcs.ServerInterfaceAddForSwitch(ctx, interfaceAddForSwitchParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "interface-add-disconnected",
				Usage:     "Create and connect a disconnected NIC",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, interfaceAddDisconnectedParam)

					// Set option values
					if c.IsSet("selector") {
						interfaceAddDisconnectedParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddDisconnectedParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddDisconnectedParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddDisconnectedParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddDisconnectedParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddDisconnectedParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerInterfaceAddDisconnectedCompleteArgs(ctx, interfaceAddDisconnectedParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerInterfaceAddDisconnectedCompleteArgs(ctx, interfaceAddDisconnectedParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerInterfaceAddDisconnectedCompleteFlags(ctx, interfaceAddDisconnectedParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerInterfaceAddDisconnectedCompleteArgs(ctx, interfaceAddDisconnectedParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					interfaceAddDisconnectedParam.ParamTemplate = c.String("param-template")
					interfaceAddDisconnectedParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(interfaceAddDisconnectedParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewInterfaceAddDisconnectedServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(interfaceAddDisconnectedParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						interfaceAddDisconnectedParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						interfaceAddDisconnectedParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						interfaceAddDisconnectedParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						interfaceAddDisconnectedParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						interfaceAddDisconnectedParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						interfaceAddDisconnectedParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if interfaceAddDisconnectedParam.GenerateSkeleton {
						interfaceAddDisconnectedParam.GenerateSkeleton = false
						interfaceAddDisconnectedParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(interfaceAddDisconnectedParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := interfaceAddDisconnectedParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), interfaceAddDisconnectedParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(interfaceAddDisconnectedParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, interfaceAddDisconnectedParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", interfaceAddDisconnectedParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(interfaceAddDisconnectedParam.Selector) == 0 || hasTags(&v, interfaceAddDisconnectedParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !interfaceAddDisconnectedParam.Assumeyes && !command.ConfirmContinue("interface-add-disconnected", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						interfaceAddDisconnectedParam.SetId(id)
						p := *interfaceAddDisconnectedParam // copy struct value
						interfaceAddDisconnectedParam := &p
						go func() {
							err := funcs.ServerInterfaceAddDisconnected(ctx, interfaceAddDisconnectedParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-info",
				Usage:     "Show information of ISO-Image inserted to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, isoInfoParam)

					// Set option values
					if c.IsSet("selector") {
						isoInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						isoInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						isoInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						isoInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						isoInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						isoInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						isoInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						isoInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						isoInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						isoInfoParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerIsoInfoCompleteArgs(ctx, isoInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerIsoInfoCompleteArgs(ctx, isoInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerIsoInfoCompleteFlags(ctx, isoInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerIsoInfoCompleteArgs(ctx, isoInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					isoInfoParam.ParamTemplate = c.String("param-template")
					isoInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(isoInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewIsoInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(isoInfoParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						isoInfoParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						isoInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						isoInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						isoInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						isoInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						isoInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						isoInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						isoInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						isoInfoParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						isoInfoParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if isoInfoParam.GenerateSkeleton {
						isoInfoParam.GenerateSkeleton = false
						isoInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(isoInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := isoInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), isoInfoParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(isoInfoParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, isoInfoParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", isoInfoParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(isoInfoParam.Selector) == 0 || hasTags(&v, isoInfoParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						isoInfoParam.SetId(id)
						p := *isoInfoParam // copy struct value
						isoInfoParam := &p
						go func() {
							err := funcs.ServerIsoInfo(ctx, isoInfoParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-insert",
				Usage:     "Insert ISO-Image to server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.Int64Flag{
						Name:  "iso-image-id",
						Usage: "set iso-image ID",
					},
					&cli.IntFlag{
						Name:  "size",
						Usage: "set iso size(GB)",
						Value: 5,
					},
					&cli.StringFlag{
						Name:  "iso-file",
						Usage: "set iso image file",
					},
					&cli.StringFlag{
						Name:  "name",
						Usage: "set resource display name",
					},
					&cli.StringFlag{
						Name:    "description",
						Aliases: []string{"desc"},
						Usage:   "set resource description",
					},
					&cli.StringSliceFlag{
						Name:  "tags",
						Usage: "set resource tags",
					},
					&cli.Int64Flag{
						Name:  "icon-id",
						Usage: "set Icon ID",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, isoInsertParam)

					// Set option values
					if c.IsSet("iso-image-id") {
						isoInsertParam.IsoImageId = c.Int64("iso-image-id")
					}
					if c.IsSet("size") {
						isoInsertParam.Size = c.Int("size")
					}
					if c.IsSet("iso-file") {
						isoInsertParam.IsoFile = c.String("iso-file")
					}
					if c.IsSet("name") {
						isoInsertParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						isoInsertParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						isoInsertParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						isoInsertParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("selector") {
						isoInsertParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						isoInsertParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						isoInsertParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						isoInsertParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						isoInsertParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						isoInsertParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerIsoInsertCompleteArgs(ctx, isoInsertParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerIsoInsertCompleteArgs(ctx, isoInsertParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerIsoInsertCompleteFlags(ctx, isoInsertParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerIsoInsertCompleteArgs(ctx, isoInsertParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					isoInsertParam.ParamTemplate = c.String("param-template")
					isoInsertParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(isoInsertParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewIsoInsertServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(isoInsertParam, p)
					}

					// Set option values
					if c.IsSet("iso-image-id") {
						isoInsertParam.IsoImageId = c.Int64("iso-image-id")
					}
					if c.IsSet("size") {
						isoInsertParam.Size = c.Int("size")
					}
					if c.IsSet("iso-file") {
						isoInsertParam.IsoFile = c.String("iso-file")
					}
					if c.IsSet("name") {
						isoInsertParam.Name = c.String("name")
					}
					if c.IsSet("description") {
						isoInsertParam.Description = c.String("description")
					}
					if c.IsSet("tags") {
						isoInsertParam.Tags = c.StringSlice("tags")
					}
					if c.IsSet("icon-id") {
						isoInsertParam.IconId = c.Int64("icon-id")
					}
					if c.IsSet("selector") {
						isoInsertParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						isoInsertParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						isoInsertParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						isoInsertParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						isoInsertParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						isoInsertParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if isoInsertParam.GenerateSkeleton {
						isoInsertParam.GenerateSkeleton = false
						isoInsertParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(isoInsertParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := isoInsertParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), isoInsertParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(isoInsertParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, isoInsertParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", isoInsertParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(isoInsertParam.Selector) == 0 || hasTags(&v, isoInsertParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !isoInsertParam.Assumeyes && !command.ConfirmContinue("iso-insert", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						isoInsertParam.SetId(id)
						p := *isoInsertParam // copy struct value
						isoInsertParam := &p
						go func() {
							err := funcs.ServerIsoInsert(ctx, isoInsertParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "iso-eject",
				Usage:     "Eject ISO-Image from server",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.BoolFlag{
						Name:    "assumeyes",
						Aliases: []string{"y"},
						Usage:   "Assume that the answer to any question which would be asked is yes",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, isoEjectParam)

					// Set option values
					if c.IsSet("selector") {
						isoEjectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						isoEjectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						isoEjectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						isoEjectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						isoEjectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						isoEjectParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerIsoEjectCompleteArgs(ctx, isoEjectParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerIsoEjectCompleteArgs(ctx, isoEjectParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerIsoEjectCompleteFlags(ctx, isoEjectParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerIsoEjectCompleteArgs(ctx, isoEjectParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					isoEjectParam.ParamTemplate = c.String("param-template")
					isoEjectParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(isoEjectParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewIsoEjectServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(isoEjectParam, p)
					}

					// Set option values
					if c.IsSet("selector") {
						isoEjectParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("assumeyes") {
						isoEjectParam.Assumeyes = c.Bool("assumeyes")
					}
					if c.IsSet("param-template") {
						isoEjectParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						isoEjectParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						isoEjectParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("id") {
						isoEjectParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if isoEjectParam.GenerateSkeleton {
						isoEjectParam.GenerateSkeleton = false
						isoEjectParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(isoEjectParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := isoEjectParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), isoEjectParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(isoEjectParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, isoEjectParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", isoEjectParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(isoEjectParam.Selector) == 0 || hasTags(&v, isoEjectParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					// confirm
					if !isoEjectParam.Assumeyes && !command.ConfirmContinue("iso-eject", ids...) {
						return nil
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						isoEjectParam.SetId(id)
						p := *isoEjectParam // copy struct value
						isoEjectParam := &p
						go func() {
							err := funcs.ServerIsoEject(ctx, isoEjectParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-cpu",
				Usage:     "Collect CPU monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.{{.ID}}.cpu",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorCpuParam)

					// Set option values
					if c.IsSet("start") {
						monitorCpuParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorCpuParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorCpuParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorCpuParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorCpuParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorCpuParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorCpuParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorCpuParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorCpuParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorCpuParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorCpuParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorCpuParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorCpuParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMonitorCpuCompleteFlags(ctx, monitorCpuParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMonitorCpuCompleteArgs(ctx, monitorCpuParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorCpuParam.ParamTemplate = c.String("param-template")
					monitorCpuParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorCpuParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorCpuServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorCpuParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorCpuParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorCpuParam.End = c.String("end")
					}
					if c.IsSet("key-format") {
						monitorCpuParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorCpuParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorCpuParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorCpuParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorCpuParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorCpuParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorCpuParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorCpuParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorCpuParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorCpuParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorCpuParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorCpuParam.GenerateSkeleton {
						monitorCpuParam.GenerateSkeleton = false
						monitorCpuParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorCpuParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorCpuParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorCpuParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorCpuParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, monitorCpuParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorCpuParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(monitorCpuParam.Selector) == 0 || hasTags(&v, monitorCpuParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorCpuParam.SetId(id)
						p := *monitorCpuParam // copy struct value
						monitorCpuParam := &p
						go func() {
							err := funcs.ServerMonitorCpu(ctx, monitorCpuParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-nic",
				Usage:     "Collect NIC(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.Int64SliceFlag{
						Name:  "index",
						Usage: "target index(es)",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.{{.ID}}.nic.{{.Index}}",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorNicParam)

					// Set option values
					if c.IsSet("start") {
						monitorNicParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorNicParam.End = c.String("end")
					}
					if c.IsSet("index") {
						monitorNicParam.Index = c.Int64Slice("index")
					}
					if c.IsSet("key-format") {
						monitorNicParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorNicParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorNicParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorNicParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorNicParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorNicParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorNicParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorNicParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorNicParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorNicParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorNicParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMonitorNicCompleteFlags(ctx, monitorNicParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMonitorNicCompleteArgs(ctx, monitorNicParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorNicParam.ParamTemplate = c.String("param-template")
					monitorNicParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorNicParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorNicServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorNicParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorNicParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorNicParam.End = c.String("end")
					}
					if c.IsSet("index") {
						monitorNicParam.Index = c.Int64Slice("index")
					}
					if c.IsSet("key-format") {
						monitorNicParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorNicParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorNicParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorNicParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorNicParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorNicParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorNicParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorNicParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorNicParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorNicParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorNicParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorNicParam.GenerateSkeleton {
						monitorNicParam.GenerateSkeleton = false
						monitorNicParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorNicParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorNicParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorNicParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorNicParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, monitorNicParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorNicParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(monitorNicParam.Selector) == 0 || hasTags(&v, monitorNicParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorNicParam.SetId(id)
						p := *monitorNicParam // copy struct value
						monitorNicParam := &p
						go func() {
							err := funcs.ServerMonitorNic(ctx, monitorNicParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:      "monitor-disk",
				Usage:     "Collect Disk(s) monitor values",
				ArgsUsage: "<ID or Name(only single target)>",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "start",
						Usage: "set start-time",
					},
					&cli.StringFlag{
						Name:  "end",
						Usage: "set end-time",
					},
					&cli.Int64SliceFlag{
						Name:  "index",
						Usage: "target index(es)",
					},
					&cli.StringFlag{
						Name:  "key-format",
						Usage: "[Required] set monitoring value key-format",
						Value: "sakuracloud.{{.ID}}.disk.{{.Index}}",
					},
					&cli.StringSliceFlag{
						Name:  "selector",
						Usage: "Set target filter by tag",
					},
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
					&cli.Int64Flag{
						Name:   "id",
						Usage:  "Set target ID",
						Hidden: true,
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, monitorDiskParam)

					// Set option values
					if c.IsSet("start") {
						monitorDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorDiskParam.End = c.String("end")
					}
					if c.IsSet("index") {
						monitorDiskParam.Index = c.Int64Slice("index")
					}
					if c.IsSet("key-format") {
						monitorDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorDiskParam.Id = c.Int64("id")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMonitorDiskCompleteArgs(ctx, monitorDiskParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMonitorDiskCompleteArgs(ctx, monitorDiskParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMonitorDiskCompleteFlags(ctx, monitorDiskParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMonitorDiskCompleteArgs(ctx, monitorDiskParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					monitorDiskParam.ParamTemplate = c.String("param-template")
					monitorDiskParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(monitorDiskParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMonitorDiskServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(monitorDiskParam, p)
					}

					// Set option values
					if c.IsSet("start") {
						monitorDiskParam.Start = c.String("start")
					}
					if c.IsSet("end") {
						monitorDiskParam.End = c.String("end")
					}
					if c.IsSet("index") {
						monitorDiskParam.Index = c.Int64Slice("index")
					}
					if c.IsSet("key-format") {
						monitorDiskParam.KeyFormat = c.String("key-format")
					}
					if c.IsSet("selector") {
						monitorDiskParam.Selector = c.StringSlice("selector")
					}
					if c.IsSet("param-template") {
						monitorDiskParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						monitorDiskParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						monitorDiskParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						monitorDiskParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						monitorDiskParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						monitorDiskParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						monitorDiskParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						monitorDiskParam.FormatFile = c.String("format-file")
					}
					if c.IsSet("id") {
						monitorDiskParam.Id = c.Int64("id")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if monitorDiskParam.GenerateSkeleton {
						monitorDiskParam.GenerateSkeleton = false
						monitorDiskParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(monitorDiskParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := monitorDiskParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), monitorDiskParam)

					apiClient := ctx.GetAPIClient().Server
					ids := []int64{}

					if c.NArg() == 0 {

						if len(monitorDiskParam.Selector) == 0 {
							return fmt.Errorf("ID or Name argument or --selector option is required")
						}
						apiClient.Reset()
						res, err := apiClient.Find()
						if err != nil {
							return fmt.Errorf("Find ID is failed: %s", err)
						}
						for _, v := range res.Servers {
							if hasTags(&v, monitorDiskParam.Selector) {
								ids = append(ids, v.GetID())
							}
						}
						if len(ids) == 0 {
							return fmt.Errorf("Find ID is failed: Not Found[with search param tags=%s]", monitorDiskParam.Selector)
						}

					} else {
						for _, arg := range c.Args().Slice() {
							for _, a := range strings.Split(arg, "\n") {
								idOrName := a
								if id, ok := toSakuraID(idOrName); ok {
									ids = append(ids, id)
								} else {
									apiClient.Reset()
									apiClient.SetFilterBy("Name", idOrName)
									res, err := apiClient.Find()
									if err != nil {
										return fmt.Errorf("Find ID is failed: %s", err)
									}
									if res.Count == 0 {
										return fmt.Errorf("Find ID is failed: Not Found[with search param %q]", idOrName)
									}
									for _, v := range res.Servers {
										if len(monitorDiskParam.Selector) == 0 || hasTags(&v, monitorDiskParam.Selector) {
											ids = append(ids, v.GetID())
										}
									}
								}
							}
						}
					}

					ids = command.UniqIDs(ids)
					if len(ids) == 0 {
						return fmt.Errorf("Target resource is not found")
					}

					if len(ids) != 1 {
						return fmt.Errorf("Can't run with multiple targets: %v", ids)
					}

					wg := sync.WaitGroup{}
					errs := []error{}

					for _, id := range ids {
						wg.Add(1)
						monitorDiskParam.SetId(id)
						p := *monitorDiskParam // copy struct value
						monitorDiskParam := &p
						go func() {
							err := funcs.ServerMonitorDisk(ctx, monitorDiskParam)
							if err != nil {
								errs = append(errs, err)
							}
							wg.Done()
						}()
					}
					wg.Wait()
					return command.FlattenErrors(errs)

				},
			},
			{
				Name:  "maintenance-info",
				Usage: "MaintenanceInfo Server",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "param-template",
						Usage: "Set input parameter from string(JSON)",
					},
					&cli.StringFlag{
						Name:  "param-template-file",
						Usage: "Set input parameter from file",
					},
					&cli.BoolFlag{
						Name:  "generate-skeleton",
						Usage: "Output skelton of parameter JSON",
					},
					&cli.StringFlag{
						Name:    "output-type",
						Aliases: []string{"out"},
						Usage:   "Output type [json/csv/tsv]",
					},
					&cli.StringSliceFlag{
						Name:    "column",
						Aliases: []string{"col"},
						Usage:   "Output columns(using when '--output-type' is in [csv/tsv] only)",
					},
					&cli.BoolFlag{
						Name:    "quiet",
						Aliases: []string{"q"},
						Usage:   "Only display IDs",
					},
					&cli.StringFlag{
						Name:    "format",
						Aliases: []string{"fmt"},
						Usage:   "Output format(see text/template package document for detail)",
					},
					&cli.StringFlag{
						Name:  "format-file",
						Usage: "Output format from file(see text/template package document for detail)",
					},
				},
				ShellComplete: func(c *cli.Context) {

					if c.NArg() < 3 { // invalid args
						return
					}

					// c.Args() == arg1 arg2 arg3 -- [cur] [prev] [commandName]
					args := c.Args().Slice()
					commandName := args[c.NArg()-1]
					prev := args[c.NArg()-2]
					cur := args[c.NArg()-3]

					// set real args
					realArgs := args[0 : c.NArg()-3]

					// Validate global params
					command.GlobalOption.Validate(false)

					// build command context
					ctx := command.NewContext(c, realArgs, maintenanceInfoParam)

					// Set option values
					if c.IsSet("param-template") {
						maintenanceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						maintenanceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						maintenanceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						maintenanceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						maintenanceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						maintenanceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						maintenanceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						maintenanceInfoParam.FormatFile = c.String("format-file")
					}

					if strings.HasPrefix(prev, "-") {
						// prev if flag , is values setted?
						if strings.Contains(prev, "=") {
							if strings.HasPrefix(cur, "-") {
								completion.FlagNames(c, commandName)
								return
							} else {
								completion.ServerMaintenanceInfoCompleteArgs(ctx, maintenanceInfoParam, cur, prev, commandName)
								return
							}
						}

						// cleanup flag name
						name := prev
						for {
							if !strings.HasPrefix(name, "-") {
								break
							}
							name = strings.Replace(name, "-", "", 1)
						}

						// flag is exists? , is BoolFlag?
						exists := false
						for _, flag := range c.App.Command(commandName).Flags {

							for _, n := range flag.Names() {
								if n == name {
									exists = true
									break
								}
							}

							if exists {
								if _, ok := flag.(*cli.BoolFlag); ok {
									if strings.HasPrefix(cur, "-") {
										completion.FlagNames(c, commandName)
										return
									} else {
										completion.ServerMaintenanceInfoCompleteArgs(ctx, maintenanceInfoParam, cur, prev, commandName)
										return
									}
								} else {
									// prev is flag , call completion func of each flags
									completion.ServerMaintenanceInfoCompleteFlags(ctx, maintenanceInfoParam, name, cur)
									return
								}
							}
						}
						// here, prev is wrong, so noop.
					} else {
						if strings.HasPrefix(cur, "-") {
							completion.FlagNames(c, commandName)
							return
						} else {
							completion.ServerMaintenanceInfoCompleteArgs(ctx, maintenanceInfoParam, cur, prev, commandName)
							return
						}
					}
				},
				Action: func(c *cli.Context) error {

					maintenanceInfoParam.ParamTemplate = c.String("param-template")
					maintenanceInfoParam.ParamTemplateFile = c.String("param-template-file")
					strInput, err := command.GetParamTemplateValue(maintenanceInfoParam)
					if err != nil {
						return err
					}
					if strInput != "" {
						p := params.NewMaintenanceInfoServerParam()
						err := json.Unmarshal([]byte(strInput), p)
						if err != nil {
							return fmt.Errorf("Failed to parse JSON: %s", err)
						}
						mergo.MergeWithOverwrite(maintenanceInfoParam, p)
					}

					// Set option values
					if c.IsSet("param-template") {
						maintenanceInfoParam.ParamTemplate = c.String("param-template")
					}
					if c.IsSet("param-template-file") {
						maintenanceInfoParam.ParamTemplateFile = c.String("param-template-file")
					}
					if c.IsSet("generate-skeleton") {
						maintenanceInfoParam.GenerateSkeleton = c.Bool("generate-skeleton")
					}
					if c.IsSet("output-type") {
						maintenanceInfoParam.OutputType = c.String("output-type")
					}
					if c.IsSet("column") {
						maintenanceInfoParam.Column = c.StringSlice("column")
					}
					if c.IsSet("quiet") {
						maintenanceInfoParam.Quiet = c.Bool("quiet")
					}
					if c.IsSet("format") {
						maintenanceInfoParam.Format = c.String("format")
					}
					if c.IsSet("format-file") {
						maintenanceInfoParam.FormatFile = c.String("format-file")
					}

					// Validate global params
					if errors := command.GlobalOption.Validate(false); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "GlobalOptions")
					}

					// Generate skeleton
					if maintenanceInfoParam.GenerateSkeleton {
						maintenanceInfoParam.GenerateSkeleton = false
						maintenanceInfoParam.FillValueToSkeleton()
						d, err := json.MarshalIndent(maintenanceInfoParam, "", "\t")
						if err != nil {
							return fmt.Errorf("Failed to Marshal JSON: %s", err)
						}
						fmt.Fprintln(command.GlobalOption.Out, string(d))
						return nil
					}

					// Validate specific for each command params
					if errors := maintenanceInfoParam.Validate(); len(errors) > 0 {
						return command.FlattenErrorsWithPrefix(errors, "Options")
					}

					// create command context
					ctx := command.NewContext(c, c.Args().Slice(), maintenanceInfoParam)

					// Run command with params
					return funcs.ServerMaintenanceInfo(ctx, maintenanceInfoParam)

				},
			},
		},
	}

	// build Category-Resource mapping
	AppendResourceCategoryMap("server", &schema.Category{
		Key:         "computing",
		DisplayName: "Computing",
		Order:       10,
	})

	// build Category-Command mapping

	AppendCommandCategoryMap("server", "boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "build", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "delete", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "disk-connect", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "disk-disconnect", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "disk-info", &schema.Category{
		Key:         "disks",
		DisplayName: "Disk(s) Management",
		Order:       40,
	})
	AppendCommandCategoryMap("server", "interface-add-disconnected", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-internet", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-router", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-add-for-switch", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "interface-info", &schema.Category{
		Key:         "network",
		DisplayName: "Network Management",
		Order:       50,
	})
	AppendCommandCategoryMap("server", "iso-eject", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "iso-info", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "iso-insert", &schema.Category{
		Key:         "iso",
		DisplayName: "ISO Image Management",
		Order:       60,
	})
	AppendCommandCategoryMap("server", "list", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "maintenance-info", &schema.Category{
		Key:         "other",
		DisplayName: "Other",
		Order:       1000,
	})
	AppendCommandCategoryMap("server", "monitor-cpu", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "monitor-disk", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "monitor-nic", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitoring",
		Order:       70,
	})
	AppendCommandCategoryMap("server", "plan-change", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "read", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "reset", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "scp", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "shutdown", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "shutdown-force", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "ssh", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "ssh-exec", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "update", &schema.Category{
		Key:         "basics",
		DisplayName: "Basics",
		Order:       10,
	})
	AppendCommandCategoryMap("server", "vnc", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-info", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "vnc-send", &schema.Category{
		Key:         "connect",
		DisplayName: "SSH/SCP/VNC",
		Order:       30,
	})
	AppendCommandCategoryMap("server", "wait-for-boot", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})
	AppendCommandCategoryMap("server", "wait-for-down", &schema.Category{
		Key:         "power",
		DisplayName: "Power Management",
		Order:       20,
	})

	// build Category-Param mapping

	AppendFlagCategoryMap("server", "boot", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "build", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "core", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "default-route", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "description", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "disable-boot-after-create", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "build", "disable-password-auth", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "disk-connection", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-mode", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-plan", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "disk-size", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "distant-from", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "hostname", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "icon-id", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "ipaddress", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "iso-image-id", &schema.Category{
		Key:         "iso-image",
		DisplayName: "For ISO image options",
		Order:       25,
	})
	AppendFlagCategoryMap("server", "build", "memory", &schema.Category{
		Key:         "server-plan",
		DisplayName: "For server-plan options",
		Order:       10,
	})
	AppendFlagCategoryMap("server", "build", "name", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "network-mode", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "nw-masklen", &schema.Category{
		Key:         "edit-disk-network",
		DisplayName: "For edit-disk(network settings) options",
		Order:       41,
	})
	AppendFlagCategoryMap("server", "build", "os-type", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "packet-filter-id", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "build", "password", &schema.Category{
		Key:         "edit-disk",
		DisplayName: "For edit-disk options",
		Order:       40,
	})
	AppendFlagCategoryMap("server", "build", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "build", "source-archive-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "source-disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "For disk options",
		Order:       20,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-description", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-ephemeral", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-ids", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-mode", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-name", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-pass-phrase", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-private-key-output", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-public-key-files", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "ssh-key-public-keys", &schema.Category{
		Key:         "edit-disk-ssh-key",
		DisplayName: "For edit-disk(ssh-key) options",
		Order:       43,
	})
	AppendFlagCategoryMap("server", "build", "startup-script-ids", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "startup-scripts", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "startup-scripts-ephemeral", &schema.Category{
		Key:         "edit-disk-startup-script",
		DisplayName: "For edit-disk(startup-script) options",
		Order:       42,
	})
	AppendFlagCategoryMap("server", "build", "switch-id", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "build", "tags", &schema.Category{
		Key:         "server-info",
		DisplayName: "For server-info options",
		Order:       50,
	})
	AppendFlagCategoryMap("server", "build", "us-keyboard", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "build", "use-nic-virtio", &schema.Category{
		Key:         "network",
		DisplayName: "For network options",
		Order:       30,
	})
	AppendFlagCategoryMap("server", "delete", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "force", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "delete", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "delete", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "delete", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "delete", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "delete", "without-disk", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-connect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "Disk options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-connect", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-connect", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-connect", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "disk-id", &schema.Category{
		Key:         "disk",
		DisplayName: "Disk options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-disconnect", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "disk-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "disk-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "disk-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "disk-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-disconnected", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-internet", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "default-route", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "ipaddress", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "nw-masklen", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "switch-id", &schema.Category{
		Key:         "connect",
		DisplayName: "Connect options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-router", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "default-route", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "ipaddress", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "nw-masklen", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "switch-id", &schema.Category{
		Key:         "connect",
		DisplayName: "Connect options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-add-for-switch", "without-disk-edit", &schema.Category{
		Key:         "disk-edit",
		DisplayName: "Disk-Edit options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "interface-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "interface-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "interface-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "interface-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-eject", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-eject", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-eject", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "iso-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-insert", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "description", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "icon-id", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "iso-insert", "iso-file", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "iso-image-id", &schema.Category{
		Key:         "ISO-insert",
		DisplayName: "ISO-Insert options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "name", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "iso-insert", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "iso-insert", "size", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "iso-insert", "tags", &schema.Category{
		Key:         "ISO-upload",
		DisplayName: "ISO-Upload options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "list", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "from", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("server", "list", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "id", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "list", "max", &schema.Category{
		Key:         "limit-offset",
		DisplayName: "Limit/Offset options",
		Order:       2147483597,
	})
	AppendFlagCategoryMap("server", "list", "name", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "list", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "list", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "list", "sort", &schema.Category{
		Key:         "sort",
		DisplayName: "Sort options",
		Order:       2147483607,
	})
	AppendFlagCategoryMap("server", "list", "tags", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "maintenance-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-cpu", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-disk", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "end", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "index", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "key-format", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "monitor-nic", "start", &schema.Category{
		Key:         "monitor",
		DisplayName: "Monitor options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "core", &schema.Category{
		Key:         "plan",
		DisplayName: "Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "plan-change", "memory", &schema.Category{
		Key:         "plan",
		DisplayName: "Plan options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "plan-change", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "plan-change", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "plan-change", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "read", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "read", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "read", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "read", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "reset", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "reset", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "reset", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "scp", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "scp", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "scp", "recursive", &schema.Category{
		Key:         "operation",
		DisplayName: "Operation options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "scp", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "shutdown", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "shutdown", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "shutdown-force", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "ssh", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "ssh", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "ssh", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "key", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "password", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "port", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "ssh-exec", "user", &schema.Category{
		Key:         "auth",
		DisplayName: "Auth options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "update", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "description", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "icon-id", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "update", "name", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "update", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "update", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "update", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "update", "tags", &schema.Category{
		Key:         "common",
		DisplayName: "Common options",
		Order:       2147483617,
	})
	AppendFlagCategoryMap("server", "vnc", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-info", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-info", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-info", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-info", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc-info", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "assumeyes", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "column", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "command", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "command-file", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "debug", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "format", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "format-file", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "vnc-send", "output-type", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "vnc-send", "quiet", &schema.Category{
		Key:         "output",
		DisplayName: "Output options",
		Order:       2147483637,
	})
	AppendFlagCategoryMap("server", "vnc-send", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "vnc-send", "use-us-keyboard", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "vnc-send", "wait-for-boot", &schema.Category{
		Key:         "VNC",
		DisplayName: "VNC options",
		Order:       1,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-boot", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "generate-skeleton", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "id", &schema.Category{
		Key:         "default",
		DisplayName: "Other options",
		Order:       2147483647,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "param-template", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "param-template-file", &schema.Category{
		Key:         "Input",
		DisplayName: "Input options",
		Order:       2147483627,
	})
	AppendFlagCategoryMap("server", "wait-for-down", "selector", &schema.Category{
		Key:         "filter",
		DisplayName: "Filter options",
		Order:       2147483587,
	})

	// append command to GlobalContext
	Commands = append(Commands, cliCommand)
}
