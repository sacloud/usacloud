// Code generated by 'github.com/sacloud/usacloud/tools/gen-command-completion'; DO NOT EDIT

package completion

import (
	"fmt"

	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/params"
	"github.com/sacloud/usacloud/define"
	"github.com/sacloud/usacloud/schema"
)

func NFSListCompleteFlags(ctx command.Context, params *params.ListNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "name":
		param := define.Resources["NFS"].Commands["list"].BuildedParams().Get("name")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["list"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "tags", "selector":
		param := define.Resources["NFS"].Commands["list"].BuildedParams().Get("tags")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "from", "offset":
		param := define.Resources["NFS"].Commands["list"].BuildedParams().Get("from")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "max", "limit":
		param := define.Resources["NFS"].Commands["list"].BuildedParams().Get("max")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "sort":
		param := define.Resources["NFS"].Commands["list"].BuildedParams().Get("sort")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSCreateCompleteFlags(ctx command.Context, params *params.CreateNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "switch-id":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("switch-id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "plan":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("plan")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "ipaddress", "ip":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("ipaddress")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "nw-mask-len":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("nw-mask-len")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "default-route":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("default-route")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "name":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("name")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "description", "desc":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("description")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "tags":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("tags")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "icon-id":
		param := define.Resources["NFS"].Commands["create"].BuildedParams().Get("icon-id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSReadCompleteFlags(ctx command.Context, params *params.ReadNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["read"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["read"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSUpdateCompleteFlags(ctx command.Context, params *params.UpdateNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["update"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "name":
		param := define.Resources["NFS"].Commands["update"].BuildedParams().Get("name")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "description", "desc":
		param := define.Resources["NFS"].Commands["update"].BuildedParams().Get("description")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "tags":
		param := define.Resources["NFS"].Commands["update"].BuildedParams().Get("tags")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "icon-id":
		param := define.Resources["NFS"].Commands["update"].BuildedParams().Get("icon-id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["update"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSDeleteCompleteFlags(ctx command.Context, params *params.DeleteNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "force", "f":
		param := define.Resources["NFS"].Commands["delete"].BuildedParams().Get("force")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "selector":
		param := define.Resources["NFS"].Commands["delete"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["delete"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSBootCompleteFlags(ctx command.Context, params *params.BootNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["boot"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["boot"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSShutdownCompleteFlags(ctx command.Context, params *params.ShutdownNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["shutdown"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["shutdown"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSShutdownForceCompleteFlags(ctx command.Context, params *params.ShutdownForceNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["shutdown-force"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["shutdown-force"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSResetCompleteFlags(ctx command.Context, params *params.ResetNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["reset"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["reset"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSWaitForBootCompleteFlags(ctx command.Context, params *params.WaitForBootNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["wait-for-boot"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["wait-for-boot"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSWaitForDownCompleteFlags(ctx command.Context, params *params.WaitForDownNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "selector":
		param := define.Resources["NFS"].Commands["wait-for-down"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["wait-for-down"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSMonitorNicCompleteFlags(ctx command.Context, params *params.MonitorNicNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "start":
		param := define.Resources["NFS"].Commands["monitor-nic"].BuildedParams().Get("start")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "end":
		param := define.Resources["NFS"].Commands["monitor-nic"].BuildedParams().Get("end")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "key-format":
		param := define.Resources["NFS"].Commands["monitor-nic"].BuildedParams().Get("key-format")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "selector":
		param := define.Resources["NFS"].Commands["monitor-nic"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["monitor-nic"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}

func NFSMonitorFreeDiskSizeCompleteFlags(ctx command.Context, params *params.MonitorFreeDiskSizeNFSParam, flagName string, currentValue string) {
	var comp schema.CompletionFunc

	switch flagName {
	case "start":
		param := define.Resources["NFS"].Commands["monitor-free-disk-size"].BuildedParams().Get("start")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "end":
		param := define.Resources["NFS"].Commands["monitor-free-disk-size"].BuildedParams().Get("end")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "key-format":
		param := define.Resources["NFS"].Commands["monitor-free-disk-size"].BuildedParams().Get("key-format")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "selector":
		param := define.Resources["NFS"].Commands["monitor-free-disk-size"].BuildedParams().Get("selector")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "id":
		param := define.Resources["NFS"].Commands["monitor-free-disk-size"].BuildedParams().Get("id")
		if param != nil {
			comp = param.Param.CompleteFunc
		}
	case "output-type", "out":
		comp = schema.CompleteInStrValues("json", "csv", "tsv")
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}
