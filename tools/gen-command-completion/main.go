package main

import (
	"bytes"
	"fmt"
	"github.com/sacloud/usacloud/schema"
	"github.com/sacloud/usacloud/tools"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	destination = "src/github.com/sacloud/usacloud/command"
	ctx         = tools.NewGenerateContext()
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tgen-command-completion\n")
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen-command-funcs: ")

	for k, r := range ctx.ResourceDef {
		ctx.SetCurrentR(k)

		err := generateResource(r)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
}

func generateResource(resource *schema.Resource) error {

	// build commands
	for _, comm := range resource.SortedCommands() {
		c := comm.Command
		k := comm.CommandKey
		ctx.C = k

		// generate args completion
		src, err := generateArgsComplete(c)
		if err != nil {
			return err
		}

		// Write to file.
		// like 'comp_switch_list_args.go'
		baseName := ctx.CommandArgsCompletionFileName(c.UseCustomArgCompletion)
		outputName := filepath.Join(ctx.Gopath(), destination, baseName)

		// target file is exist?
		_, err = os.Stat(outputName)
		if !c.UseCustomArgCompletion || err != nil {
			err = ioutil.WriteFile(outputName, tools.Sformat([]byte(src)), 0644)
			if err != nil {
				return err
			}
			fmt.Printf("generated: %s\n", filepath.Join(destination, baseName))
		}

		// generate flags completion
		src, err = generateFlagsComplete(c)
		if err != nil {
			return err
		}

		// Write to file.
		// like 'comp_switch_list_flags.go'
		baseName = ctx.CommandFlagsCompletionFileName(c.UseCustomFlagsCompletion)
		outputName = filepath.Join(ctx.Gopath(), destination, baseName)

		// target file is exist?
		_, err = os.Stat(outputName)
		if !c.UseCustomFlagsCompletion || err != nil {
			err = ioutil.WriteFile(outputName, tools.Sformat([]byte(src)), 0644)
			if err != nil {
				return err
			}
			fmt.Printf("generated: %s\n", filepath.Join(destination, baseName))
		}
	}

	return nil
}

func generateArgsComplete(command *schema.Command) (string, error) {
	b := bytes.NewBufferString("")
	t := template.New("c")
	template.Must(t.Parse(completeArgsTemplate))

	action, err := generateArgsCompleteAction(command)
	if err != nil {
		return "", err
	}

	err = t.Execute(b, map[string]interface{}{
		"FuncName":             ctx.CompleteArgsFuncName(),
		"ParamName":            ctx.InputModelTypeName(),
		"Action":               action,
		"NeedDonotEditComment": !command.UseCustomArgCompletion,
		"UseImport":            action != "",
	})

	return b.String(), err
}

func generateArgsCompleteAction(command *schema.Command) (string, error) {

	var res string
	var err error

	if command.Type.IsRequiredIDType() {
		res, err = generateIDCompletion(command)
	} else {
		res, err = "", nil
	}

	return res, err
}

func generateIDCompletion(command *schema.Command) (string, error) {
	b := bytes.NewBufferString("")
	t := template.New("c")
	template.Must(t.Parse(completeIDTemplate))

	err := t.Execute(b, map[string]interface{}{
		"FinderFieldName": ctx.CommandResourceName(),
		"ListResultField": ctx.FindResultFieldName(),
	})
	return b.String(), err
}

func generateFlagsComplete(command *schema.Command) (string, error) {
	b := bytes.NewBufferString("")
	t := template.New("c")
	t.Funcs(template.FuncMap{
		"join": strings.Join,
	})
	template.Must(t.Parse(completeFlagsTemplate))

	flags := []map[string]interface{}{}
	for _, param := range command.SortedParams() {
		p := param.Param
		ctx.P = param.ParamKey

		names := []string{param.ParamKey}
		names = append(names, p.Aliases...)
		for i := range names {
			names[i] = fmt.Sprintf("%q", names[i])
		}

		flags = append(flags, map[string]interface{}{
			"ResourceKey": ctx.R,
			"CommandKey":  ctx.C,
			"ParamKey":    ctx.P,
			"Names":       names,
		})
	}

	err := t.Execute(b, map[string]interface{}{
		"FuncName":             ctx.CompleteFlagsFuncName(),
		"ParamName":            ctx.InputModelTypeName(),
		"Flags":                flags,
		"NeedDonotEditComment": !command.UseCustomFlagsCompletion,
		"UseImport":            len(flags) > 0,
	})

	return b.String(), err
}

var completeArgsTemplate = `{{ if .NeedDonotEditComment }}// Code generated by 'github.com/sacloud/usacloud/tools/gen-command-completion'; DO NOT EDIT{{ end }}

package command

{{if .UseImport}}import (
    "fmt"
){{end}}

func {{.FuncName}}(ctx Context, params *{{.ParamName}}, cur, prev, commandName string) {
    {{.Action}}
}
`

var completeIDTemplate = `
	if !GlobalOption.Valid {
		return
	}

	client := ctx.GetAPIClient()
	finder := client.Get{{.FinderFieldName}}API()
	finder.SetEmpty()

	// call Find()
	res, err := finder.Find()
	if err != nil {
		return
	}
	for i := range res.{{.ListResultField}} {
		fmt.Println(res.{{.ListResultField}}[i].ID)
	}
`

var completeFlagsTemplate = `{{ if .NeedDonotEditComment }}// Code generated by 'github.com/sacloud/usacloud/tools/gen-command-completion'; DO NOT EDIT{{ end }}

package command

import (
	"github.com/sacloud/usacloud/schema"{{if .UseImport}}
	"github.com/sacloud/usacloud/define"{{end}}
	"fmt"
)

func {{.FuncName}}(ctx Context, params *{{.ParamName}} , flagName string , currentValue string) {
    	var comp schema.SchemaCompletionFunc

	switch flagName { {{range .Flags}}
	case {{join .Names ", "}}:
		comp = define.Resources["{{.ResourceKey}}"].Commands["{{.CommandKey}}"].Params["{{.ParamKey}}"].CompleteFunc{{end}}
	}

	if comp != nil {
		words := comp(ctx, currentValue)
		for _, w := range words {
			fmt.Println(w)
		}
	}
}
`
