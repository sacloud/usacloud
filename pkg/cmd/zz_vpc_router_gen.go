// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cmd

import (
	"errors"
	"sync"

	"github.com/sacloud/libsacloud/sacloud"
	"github.com/sacloud/usacloud/pkg/cli"
	"github.com/sacloud/usacloud/pkg/funcs"
	"github.com/sacloud/usacloud/pkg/params"
	"github.com/sacloud/usacloud/pkg/utils"
	"github.com/spf13/cobra"
)

// vpcRouterCmd represents the command to manage SAKURA Cloud VPCRouter
func vpcRouterCmd() *cobra.Command {
	return &cobra.Command{
		Use: "vpc-router",

		Short: "A manage commands of VPCRouter",
		Long:  `A manage commands of VPCRouter`,
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.HelpFunc()(cmd, args)
			return nil
		},
	}
}

func vpcRouterListCmd() *cobra.Command {
	vpcRouterListParam := params.NewListVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "list",
		Aliases:      []string{"ls", "find", "select"},
		Short:        "List VPCRouter",
		Long:         `List VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterListParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterListParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterListParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterListParam)
			}

			return funcs.VPCRouterList(ctx, vpcRouterListParam)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterListParam.Name, "name", "", []string{}, "set filter by name(s)")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &vpcRouterListParam.Id), "id", "", "set filter by id(s)")
	fs.StringSliceVarP(&vpcRouterListParam.Tags, "tags", "", []string{}, "set filter by tags(AND) (aliases: selector)")
	fs.IntVarP(&vpcRouterListParam.From, "from", "", 0, "set offset (aliases: offset)")
	fs.IntVarP(&vpcRouterListParam.Max, "max", "", 0, "set limit (aliases: limit)")
	fs.StringSliceVarP(&vpcRouterListParam.Sort, "sort", "", []string{}, "set field(s) for sort")
	fs.StringVarP(&vpcRouterListParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterListParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterListParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterListParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterListParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterListParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterListParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterListParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterListParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterListParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterListParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterListParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.SetNormalizeFunc(vpcRouterListNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterListFlagOrder(cmd))
	return cmd
}

func vpcRouterCreateCmd() *cobra.Command {
	vpcRouterCreateParam := params.NewCreateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "create",

		Short:        "Create VPCRouter",
		Long:         `Create VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterCreateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterCreateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterCreateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterCreateParam)
			}

			// confirm
			if !vpcRouterCreateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("create", ctx.IO().In(), ctx.IO().Out())
				if err != nil || !result {
					return err
				}
			}

			return funcs.VPCRouterCreate(ctx, vpcRouterCreateParam)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterCreateParam.Plan, "plan", "", "standard", "set plan[standard/premium/highspec/highspec1600/highspec4000]")
	fs.VarP(newIDValue(0, &vpcRouterCreateParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.IntVarP(&vpcRouterCreateParam.Vrid, "vrid", "", 1, "set VRID (aliases: VRID)")
	fs.StringVarP(&vpcRouterCreateParam.Vip, "vip", "", "", "set virtual ipddress()")
	fs.StringVarP(&vpcRouterCreateParam.Ipaddress1, "ipaddress-1", "", "", "set ipaddress(#1) (aliases: ip1)")
	fs.StringVarP(&vpcRouterCreateParam.Ipaddress2, "ipaddress-2", "", "", "set ipaddress(#2) (aliases: ip2)")
	fs.BoolVarP(&vpcRouterCreateParam.DisableInternetConnection, "disable-internet-connection", "", false, "disable internet connection from VPCRouter")
	fs.BoolVarP(&vpcRouterCreateParam.BootAfterCreate, "boot-after-create", "", false, "boot after create")
	fs.StringVarP(&vpcRouterCreateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&vpcRouterCreateParam.Description, "description", "", "", "set resource description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterCreateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &vpcRouterCreateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&vpcRouterCreateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterCreateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterCreateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterCreateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterCreateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterCreateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterCreateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterCreateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterCreateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterCreateParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterCreateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterCreateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterCreateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.SetNormalizeFunc(vpcRouterCreateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterCreateFlagOrder(cmd))
	return cmd
}

func vpcRouterReadCmd() *cobra.Command {
	vpcRouterReadParam := params.NewReadVPCRouterParam()
	cmd := &cobra.Command{
		Use: "read",

		Short:        "Read VPCRouter",
		Long:         `Read VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterReadParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterReadParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterReadParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterReadParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterReadTargets(ctx, vpcRouterReadParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterReadParam.SetId(id)
				go func(p *params.ReadVPCRouterParam) {
					err := funcs.VPCRouterRead(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterReadParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterReadParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterReadParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterReadParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterReadParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterReadParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterReadParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterReadParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterReadParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterReadParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterReadParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterReadParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterReadParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterReadParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterReadParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterReadNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterReadFlagOrder(cmd))
	return cmd
}

func vpcRouterUpdateCmd() *cobra.Command {
	vpcRouterUpdateParam := params.NewUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "update",

		Short:        "Update VPCRouter",
		Long:         `Update VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterUpdateTargets(ctx, vpcRouterUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterUpdateParam.SetId(id)
				go func(p *params.UpdateVPCRouterParam) {
					err := funcs.VPCRouterUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterUpdateParam.SyslogHost, "syslog-host", "", "", "set syslog host IPAddress")
	fs.BoolVarP(&vpcRouterUpdateParam.InternetConnection, "internet-connection", "", false, "set internet connection from VPCRouter")
	fs.StringSliceVarP(&vpcRouterUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterUpdateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&vpcRouterUpdateParam.Description, "description", "", "", "set resource description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterUpdateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &vpcRouterUpdateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&vpcRouterUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterDeleteCmd() *cobra.Command {
	vpcRouterDeleteParam := params.NewDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "delete",
		Aliases:      []string{"rm"},
		Short:        "Delete VPCRouter",
		Long:         `Delete VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDeleteTargets(ctx, vpcRouterDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDeleteParam.SetId(id)
				go func(p *params.DeleteVPCRouterParam) {
					err := funcs.VPCRouterDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&vpcRouterDeleteParam.Force, "force", "f", false, "forced-shutdown flag if server is running")
	fs.StringSliceVarP(&vpcRouterDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterBootCmd() *cobra.Command {
	vpcRouterBootParam := params.NewBootVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "boot",
		Aliases:      []string{"power-on"},
		Short:        "Boot VPCRouter",
		Long:         `Boot VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterBootParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterBootParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterBootParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterBootParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterBootTargets(ctx, vpcRouterBootParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterBootParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("boot", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterBootParam.SetId(id)
				go func(p *params.BootVPCRouterParam) {
					err := funcs.VPCRouterBoot(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterBootParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterBootParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterBootParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterBootParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterBootParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterBootParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterBootParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterBootParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterBootParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterBootNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterBootFlagOrder(cmd))
	return cmd
}

func vpcRouterShutdownCmd() *cobra.Command {
	vpcRouterShutdownParam := params.NewShutdownVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "shutdown",
		Aliases:      []string{"power-off"},
		Short:        "Shutdown VPCRouter",
		Long:         `Shutdown VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterShutdownParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterShutdownParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterShutdownParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterShutdownParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterShutdownTargets(ctx, vpcRouterShutdownParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterShutdownParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("shutdown", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterShutdownParam.SetId(id)
				go func(p *params.ShutdownVPCRouterParam) {
					err := funcs.VPCRouterShutdown(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterShutdownParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterShutdownParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterShutdownParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterShutdownParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterShutdownParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterShutdownParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterShutdownParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterShutdownParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterShutdownParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterShutdownNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterShutdownFlagOrder(cmd))
	return cmd
}

func vpcRouterShutdownForceCmd() *cobra.Command {
	vpcRouterShutdownForceParam := params.NewShutdownForceVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "shutdown-force",
		Aliases:      []string{"stop"},
		Short:        "ShutdownForce VPCRouter",
		Long:         `ShutdownForce VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterShutdownForceParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterShutdownForceParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterShutdownForceParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterShutdownForceParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterShutdownForceTargets(ctx, vpcRouterShutdownForceParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterShutdownForceParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("shutdown-force", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterShutdownForceParam.SetId(id)
				go func(p *params.ShutdownForceVPCRouterParam) {
					err := funcs.VPCRouterShutdownForce(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterShutdownForceParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterShutdownForceParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterShutdownForceParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterShutdownForceParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterShutdownForceParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterShutdownForceParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterShutdownForceParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterShutdownForceParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterShutdownForceParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterShutdownForceNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterShutdownForceFlagOrder(cmd))
	return cmd
}

func vpcRouterResetCmd() *cobra.Command {
	vpcRouterResetParam := params.NewResetVPCRouterParam()
	cmd := &cobra.Command{
		Use: "reset",

		Short:        "Reset VPCRouter",
		Long:         `Reset VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterResetParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterResetParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterResetParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterResetParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterResetTargets(ctx, vpcRouterResetParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterResetParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("reset", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterResetParam.SetId(id)
				go func(p *params.ResetVPCRouterParam) {
					err := funcs.VPCRouterReset(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterResetParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterResetParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterResetParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterResetParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterResetParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterResetParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterResetParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterResetParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterResetParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterResetNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterResetFlagOrder(cmd))
	return cmd
}

func vpcRouterWaitForBootCmd() *cobra.Command {
	vpcRouterWaitForBootParam := params.NewWaitForBootVPCRouterParam()
	cmd := &cobra.Command{
		Use: "wait-for-boot",

		Short:        "Wait until boot is completed",
		Long:         `Wait until boot is completed`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterWaitForBootParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterWaitForBootParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterWaitForBootParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterWaitForBootParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterWaitForBootTargets(ctx, vpcRouterWaitForBootParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterWaitForBootParam.SetId(id)
				go func(p *params.WaitForBootVPCRouterParam) {
					err := funcs.VPCRouterWaitForBoot(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterWaitForBootParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterWaitForBootParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterWaitForBootParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterWaitForBootParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterWaitForBootParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterWaitForBootParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterWaitForBootParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterWaitForBootParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterWaitForBootNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterWaitForBootFlagOrder(cmd))
	return cmd
}

func vpcRouterWaitForDownCmd() *cobra.Command {
	vpcRouterWaitForDownParam := params.NewWaitForDownVPCRouterParam()
	cmd := &cobra.Command{
		Use: "wait-for-down",

		Short:        "Wait until shutdown is completed",
		Long:         `Wait until shutdown is completed`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterWaitForDownParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterWaitForDownParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterWaitForDownParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterWaitForDownParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterWaitForDownTargets(ctx, vpcRouterWaitForDownParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterWaitForDownParam.SetId(id)
				go func(p *params.WaitForDownVPCRouterParam) {
					err := funcs.VPCRouterWaitForDown(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterWaitForDownParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterWaitForDownParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterWaitForDownParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterWaitForDownParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterWaitForDownParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterWaitForDownParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterWaitForDownParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterWaitForDownParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterWaitForDownNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterWaitForDownFlagOrder(cmd))
	return cmd
}

func vpcRouterEnableInternetConnectionCmd() *cobra.Command {
	vpcRouterEnableInternetConnectionParam := params.NewEnableInternetConnectionVPCRouterParam()
	cmd := &cobra.Command{
		Use: "enable-internet-connection",

		Short:        "Enable internet connection from VPCRouter",
		Long:         `Enable internet connection from VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterEnableInternetConnectionParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterEnableInternetConnectionParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterEnableInternetConnectionParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterEnableInternetConnectionParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterEnableInternetConnectionTargets(ctx, vpcRouterEnableInternetConnectionParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterEnableInternetConnectionParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("enable-internet-connection", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterEnableInternetConnectionParam.SetId(id)
				go func(p *params.EnableInternetConnectionVPCRouterParam) {
					err := funcs.VPCRouterEnableInternetConnection(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterEnableInternetConnectionParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterEnableInternetConnectionParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterEnableInternetConnectionParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterEnableInternetConnectionParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterEnableInternetConnectionParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterEnableInternetConnectionParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterEnableInternetConnectionParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterEnableInternetConnectionParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterEnableInternetConnectionParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterEnableInternetConnectionNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterEnableInternetConnectionFlagOrder(cmd))
	return cmd
}

func vpcRouterDisableInternetConnectionCmd() *cobra.Command {
	vpcRouterDisableInternetConnectionParam := params.NewDisableInternetConnectionVPCRouterParam()
	cmd := &cobra.Command{
		Use: "disable-internet-connection",

		Short:        "Enable internet connection from VPCRouter",
		Long:         `Enable internet connection from VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDisableInternetConnectionParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDisableInternetConnectionParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDisableInternetConnectionParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDisableInternetConnectionParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDisableInternetConnectionTargets(ctx, vpcRouterDisableInternetConnectionParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDisableInternetConnectionParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("disable-internet-connection", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDisableInternetConnectionParam.SetId(id)
				go func(p *params.DisableInternetConnectionVPCRouterParam) {
					err := funcs.VPCRouterDisableInternetConnection(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDisableInternetConnectionParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterDisableInternetConnectionParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDisableInternetConnectionParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDisableInternetConnectionParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDisableInternetConnectionParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDisableInternetConnectionParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDisableInternetConnectionParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDisableInternetConnectionParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDisableInternetConnectionParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDisableInternetConnectionNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDisableInternetConnectionFlagOrder(cmd))
	return cmd
}

func vpcRouterInterfaceInfoCmd() *cobra.Command {
	vpcRouterInterfaceInfoParam := params.NewInterfaceInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "interface-info",
		Aliases:      []string{"interface-list"},
		Short:        "Show information of NIC(s) connected to vpc-router",
		Long:         `Show information of NIC(s) connected to vpc-router`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterInterfaceInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterInterfaceInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterInterfaceInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterInterfaceInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterInterfaceInfoTargets(ctx, vpcRouterInterfaceInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterInterfaceInfoParam.SetId(id)
				go func(p *params.InterfaceInfoVPCRouterParam) {
					err := funcs.VPCRouterInterfaceInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterInterfaceInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterInterfaceInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterInterfaceInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterInterfaceInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterInterfaceInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterInterfaceInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterInterfaceInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterInterfaceInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterInterfaceInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterInterfaceConnectCmd() *cobra.Command {
	vpcRouterInterfaceConnectParam := params.NewInterfaceConnectVPCRouterParam()
	cmd := &cobra.Command{
		Use: "interface-connect",

		Short:        "Connected to switch",
		Long:         `Connected to switch`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterInterfaceConnectParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterInterfaceConnectParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterInterfaceConnectParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterInterfaceConnectParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterInterfaceConnectTargets(ctx, vpcRouterInterfaceConnectParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterInterfaceConnectParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-connect", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterInterfaceConnectParam.SetId(id)
				go func(p *params.InterfaceConnectVPCRouterParam) {
					err := funcs.VPCRouterInterfaceConnect(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterInterfaceConnectParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterInterfaceConnectParam.Interface, "interface", "", "", "index of target private-interface")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.Ipaddress, "ipaddress", "", "", "set (virtual)ipaddress (aliases: ip, vip)")
	fs.BoolVarP(&vpcRouterInterfaceConnectParam.WithReboot, "with-reboot", "", false, "reboot after connect")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.Ipaddress1, "ipaddress-1", "", "", "set ipaddress(#1) (aliases: ip1)")
	fs.VarP(newIDValue(0, &vpcRouterInterfaceConnectParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.Ipaddress2, "ipaddress-2", "", "", "set ipaddress(#2) (aliases: ip2)")
	fs.IntVarP(&vpcRouterInterfaceConnectParam.NwMasklen, "nw-masklen", "", 24, "set ipaddress prefix (aliases: network-masklen)")
	fs.StringSliceVarP(&vpcRouterInterfaceConnectParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterInterfaceConnectParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterInterfaceConnectParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterInterfaceConnectParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterInterfaceConnectParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterInterfaceConnectNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterInterfaceConnectFlagOrder(cmd))
	return cmd
}

func vpcRouterInterfaceUpdateCmd() *cobra.Command {
	vpcRouterInterfaceUpdateParam := params.NewInterfaceUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "interface-update",

		Short:        "Update interface",
		Long:         `Update interface`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterInterfaceUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterInterfaceUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterInterfaceUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterInterfaceUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterInterfaceUpdateTargets(ctx, vpcRouterInterfaceUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterInterfaceUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterInterfaceUpdateParam.SetId(id)
				go func(p *params.InterfaceUpdateVPCRouterParam) {
					err := funcs.VPCRouterInterfaceUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterInterfaceUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.Interface, "interface", "", "", "index of target interface")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.Ipaddress, "ipaddress", "", "", "set (virtual)ipaddress (aliases: ip, vip)")
	fs.BoolVarP(&vpcRouterInterfaceUpdateParam.WithReboot, "with-reboot", "", false, "reboot after connect")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.Ipaddress1, "ipaddress-1", "", "", "set ipaddress(#1) (aliases: ip1)")
	fs.VarP(newIDValue(0, &vpcRouterInterfaceUpdateParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.Ipaddress2, "ipaddress-2", "", "", "set ipaddress(#2) (aliases: ip2)")
	fs.StringSliceVarP(&vpcRouterInterfaceUpdateParam.Alias, "alias", "", []string{}, "set ip aliases")
	fs.IntVarP(&vpcRouterInterfaceUpdateParam.NwMasklen, "nw-masklen", "", 24, "set ipaddress prefix (aliases: network-masklen)")
	fs.StringSliceVarP(&vpcRouterInterfaceUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterInterfaceUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterInterfaceUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterInterfaceUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterInterfaceUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterInterfaceUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterInterfaceUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterInterfaceDisconnectCmd() *cobra.Command {
	vpcRouterInterfaceDisconnectParam := params.NewInterfaceDisconnectVPCRouterParam()
	cmd := &cobra.Command{
		Use: "interface-disconnect",

		Short:        "Disconnected to switch",
		Long:         `Disconnected to switch`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterInterfaceDisconnectParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterInterfaceDisconnectParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterInterfaceDisconnectParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterInterfaceDisconnectParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterInterfaceDisconnectTargets(ctx, vpcRouterInterfaceDisconnectParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterInterfaceDisconnectParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-disconnect", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterInterfaceDisconnectParam.SetId(id)
				go func(p *params.InterfaceDisconnectVPCRouterParam) {
					err := funcs.VPCRouterInterfaceDisconnect(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterInterfaceDisconnectParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterInterfaceDisconnectParam.Interface, "interface", "", "", "index of target private-interface")
	fs.BoolVarP(&vpcRouterInterfaceDisconnectParam.WithReboot, "with-reboot", "", false, "reboot after connect")
	fs.StringSliceVarP(&vpcRouterInterfaceDisconnectParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterInterfaceDisconnectParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterInterfaceDisconnectParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterInterfaceDisconnectParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterInterfaceDisconnectParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterInterfaceDisconnectParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterInterfaceDisconnectParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterInterfaceDisconnectParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterInterfaceDisconnectNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterInterfaceDisconnectFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticNatInfoCmd() *cobra.Command {
	vpcRouterStaticNatInfoParam := params.NewStaticNatInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "static-nat-info",
		Aliases:      []string{"static-nat-list"},
		Short:        "Show information of static NAT settings",
		Long:         `Show information of static NAT settings`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticNatInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticNatInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticNatInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticNatInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticNatInfoTargets(ctx, vpcRouterStaticNatInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticNatInfoParam.SetId(id)
				go func(p *params.StaticNatInfoVPCRouterParam) {
					err := funcs.VPCRouterStaticNatInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticNatInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterStaticNatInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticNatInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterStaticNatInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterStaticNatInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterStaticNatInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterStaticNatInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticNatInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticNatInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticNatAddCmd() *cobra.Command {
	vpcRouterStaticNatAddParam := params.NewStaticNatAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "static-nat-add",

		Short:        "Add static NAT",
		Long:         `Add static NAT`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticNatAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticNatAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticNatAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticNatAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticNatAddTargets(ctx, vpcRouterStaticNatAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterStaticNatAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("static-nat-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticNatAddParam.SetId(id)
				go func(p *params.StaticNatAddVPCRouterParam) {
					err := funcs.VPCRouterStaticNatAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticNatAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterStaticNatAddParam.Global, "global", "", "", "set global ipaddress (aliases: global-ip, global-address)")
	fs.StringVarP(&vpcRouterStaticNatAddParam.Private, "private", "", "", "set private ipaddress (aliases: private-ip, private-address)")
	fs.StringVarP(&vpcRouterStaticNatAddParam.Description, "description", "", "", "set description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterStaticNatAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterStaticNatAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterStaticNatAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticNatAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticNatAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticNatAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticNatAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterStaticNatAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticNatAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticNatAddFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticNatUpdateCmd() *cobra.Command {
	vpcRouterStaticNatUpdateParam := params.NewStaticNatUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "static-nat-update",

		Short:        "Update static NAT",
		Long:         `Update static NAT`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticNatUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticNatUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticNatUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticNatUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticNatUpdateTargets(ctx, vpcRouterStaticNatUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterStaticNatUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("static-nat-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticNatUpdateParam.SetId(id)
				go func(p *params.StaticNatUpdateVPCRouterParam) {
					err := funcs.VPCRouterStaticNatUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticNatUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterStaticNatUpdateParam.Index, "index", "", 0, "index of target static NAT")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.Global, "global", "", "", "set global ipaddress (aliases: global-ip, global-address)")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.Private, "private", "", "", "set private ipaddress (aliases: private-ip, private-address)")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.Description, "description", "", "", "set description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterStaticNatUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterStaticNatUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticNatUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticNatUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterStaticNatUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticNatUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticNatUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticNatDeleteCmd() *cobra.Command {
	vpcRouterStaticNatDeleteParam := params.NewStaticNatDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "static-nat-delete",

		Short:        "Delete static NAT",
		Long:         `Delete static NAT`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticNatDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticNatDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticNatDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticNatDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticNatDeleteTargets(ctx, vpcRouterStaticNatDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterStaticNatDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("static-nat-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticNatDeleteParam.SetId(id)
				go func(p *params.StaticNatDeleteVPCRouterParam) {
					err := funcs.VPCRouterStaticNatDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticNatDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterStaticNatDeleteParam.Index, "index", "", 0, "index of target static NAT")
	fs.StringSliceVarP(&vpcRouterStaticNatDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterStaticNatDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterStaticNatDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticNatDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticNatDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticNatDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticNatDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterStaticNatDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticNatDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticNatDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterPortForwardingInfoCmd() *cobra.Command {
	vpcRouterPortForwardingInfoParam := params.NewPortForwardingInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "port-forwarding-info",
		Aliases:      []string{"port-forwarding-list"},
		Short:        "Show information of port-forwarding settings",
		Long:         `Show information of port-forwarding settings`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterPortForwardingInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterPortForwardingInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterPortForwardingInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterPortForwardingInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterPortForwardingInfoTargets(ctx, vpcRouterPortForwardingInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterPortForwardingInfoParam.SetId(id)
				go func(p *params.PortForwardingInfoVPCRouterParam) {
					err := funcs.VPCRouterPortForwardingInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterPortForwardingInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterPortForwardingInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterPortForwardingInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterPortForwardingInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterPortForwardingInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterPortForwardingInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterPortForwardingInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterPortForwardingInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterPortForwardingInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterPortForwardingAddCmd() *cobra.Command {
	vpcRouterPortForwardingAddParam := params.NewPortForwardingAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "port-forwarding-add",

		Short:        "Add port forwarding",
		Long:         `Add port forwarding`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterPortForwardingAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterPortForwardingAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterPortForwardingAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterPortForwardingAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterPortForwardingAddTargets(ctx, vpcRouterPortForwardingAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterPortForwardingAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("port-forwarding-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterPortForwardingAddParam.SetId(id)
				go func(p *params.PortForwardingAddVPCRouterParam) {
					err := funcs.VPCRouterPortForwardingAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterPortForwardingAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterPortForwardingAddParam.Protocol, "protocol", "", "", "set target protocol")
	fs.IntVarP(&vpcRouterPortForwardingAddParam.GlobalPort, "global-port", "", 0, "set global ipaddress")
	fs.StringVarP(&vpcRouterPortForwardingAddParam.PrivateIpaddress, "private-ipaddress", "", "", "set private ipaddress (aliases: private-ip, private-address)")
	fs.IntVarP(&vpcRouterPortForwardingAddParam.PrivatePort, "private-port", "", 0, "set private ipaddress")
	fs.StringVarP(&vpcRouterPortForwardingAddParam.Description, "description", "", "", "set description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterPortForwardingAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterPortForwardingAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterPortForwardingAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterPortForwardingAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterPortForwardingAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterPortForwardingAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterPortForwardingAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterPortForwardingAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterPortForwardingAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterPortForwardingAddFlagOrder(cmd))
	return cmd
}

func vpcRouterPortForwardingUpdateCmd() *cobra.Command {
	vpcRouterPortForwardingUpdateParam := params.NewPortForwardingUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "port-forwarding-update",

		Short:        "Update port forwarding",
		Long:         `Update port forwarding`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterPortForwardingUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterPortForwardingUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterPortForwardingUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterPortForwardingUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterPortForwardingUpdateTargets(ctx, vpcRouterPortForwardingUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterPortForwardingUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("port-forwarding-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterPortForwardingUpdateParam.SetId(id)
				go func(p *params.PortForwardingUpdateVPCRouterParam) {
					err := funcs.VPCRouterPortForwardingUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterPortForwardingUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterPortForwardingUpdateParam.Index, "index", "", 0, "index of target PortForward")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.Protocol, "protocol", "", "", "set target protocol")
	fs.IntVarP(&vpcRouterPortForwardingUpdateParam.GlobalPort, "global-port", "", 0, "set global ipaddress")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.PrivateIpaddress, "private-ipaddress", "", "", "set private ipaddress (aliases: private-ip, private-address)")
	fs.IntVarP(&vpcRouterPortForwardingUpdateParam.PrivatePort, "private-port", "", 0, "set private ipaddress")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.Description, "description", "", "", "set description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterPortForwardingUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterPortForwardingUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterPortForwardingUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterPortForwardingUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterPortForwardingUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterPortForwardingUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterPortForwardingUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterPortForwardingDeleteCmd() *cobra.Command {
	vpcRouterPortForwardingDeleteParam := params.NewPortForwardingDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "port-forwarding-delete",

		Short:        "Delete port forwarding",
		Long:         `Delete port forwarding`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterPortForwardingDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterPortForwardingDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterPortForwardingDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterPortForwardingDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterPortForwardingDeleteTargets(ctx, vpcRouterPortForwardingDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterPortForwardingDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("port-forwarding-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterPortForwardingDeleteParam.SetId(id)
				go func(p *params.PortForwardingDeleteVPCRouterParam) {
					err := funcs.VPCRouterPortForwardingDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterPortForwardingDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterPortForwardingDeleteParam.Index, "index", "", 0, "index of target PortForward")
	fs.StringSliceVarP(&vpcRouterPortForwardingDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterPortForwardingDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterPortForwardingDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterPortForwardingDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterPortForwardingDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterPortForwardingDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterPortForwardingDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterPortForwardingDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterPortForwardingDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterPortForwardingDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterFirewallInfoCmd() *cobra.Command {
	vpcRouterFirewallInfoParam := params.NewFirewallInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "firewall-info",
		Aliases:      []string{"firewall-list"},
		Short:        "Show information of firewall rules",
		Long:         `Show information of firewall rules`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterFirewallInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterFirewallInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterFirewallInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterFirewallInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterFirewallInfoTargets(ctx, vpcRouterFirewallInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterFirewallInfoParam.SetId(id)
				go func(p *params.FirewallInfoVPCRouterParam) {
					err := funcs.VPCRouterFirewallInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterFirewallInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterFirewallInfoParam.Interface, "interface", "", 0, "set target NIC index")
	fs.StringVarP(&vpcRouterFirewallInfoParam.Direction, "direction", "", "receive", "set target direction[send/receive]")
	fs.StringSliceVarP(&vpcRouterFirewallInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterFirewallInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterFirewallInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterFirewallInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterFirewallInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterFirewallInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterFirewallInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterFirewallInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterFirewallInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterFirewallInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterFirewallInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterFirewallInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterFirewallInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterFirewallInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterFirewallInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterFirewallInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterFirewallAddCmd() *cobra.Command {
	vpcRouterFirewallAddParam := params.NewFirewallAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "firewall-add",

		Short:        "Add firewall rule",
		Long:         `Add firewall rule`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterFirewallAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterFirewallAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterFirewallAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterFirewallAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterFirewallAddTargets(ctx, vpcRouterFirewallAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterFirewallAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("firewall-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterFirewallAddParam.SetId(id)
				go func(p *params.FirewallAddVPCRouterParam) {
					err := funcs.VPCRouterFirewallAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterFirewallAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterFirewallAddParam.Interface, "interface", "", 0, "set target NIC index")
	fs.StringVarP(&vpcRouterFirewallAddParam.Direction, "direction", "", "receive", "set target direction[send/receive]")
	fs.StringVarP(&vpcRouterFirewallAddParam.Protocol, "protocol", "", "", "set target protocol")
	fs.StringVarP(&vpcRouterFirewallAddParam.SourceNetwork, "source-network", "", "", "set source ipaddress or network address")
	fs.IntVarP(&vpcRouterFirewallAddParam.SourcePort, "source-port", "", 0, "set source port")
	fs.StringVarP(&vpcRouterFirewallAddParam.DestinationNetwork, "destination-network", "", "", "set destination ipaddress or network address (aliases: dest-network)")
	fs.IntVarP(&vpcRouterFirewallAddParam.DestinationPort, "destination-port", "", 0, "set destination port (aliases: dest-port)")
	fs.StringVarP(&vpcRouterFirewallAddParam.Action, "action", "", "deny", "set action[allow/deny]")
	fs.BoolVarP(&vpcRouterFirewallAddParam.EnableLogging, "enable-logging", "", false, "enable logging")
	fs.StringVarP(&vpcRouterFirewallAddParam.Description, "description", "", "", "set description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterFirewallAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterFirewallAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterFirewallAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterFirewallAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterFirewallAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterFirewallAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterFirewallAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterFirewallAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterFirewallAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterFirewallAddFlagOrder(cmd))
	return cmd
}

func vpcRouterFirewallUpdateCmd() *cobra.Command {
	vpcRouterFirewallUpdateParam := params.NewFirewallUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "firewall-update",

		Short:        "Update firewall rule",
		Long:         `Update firewall rule`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterFirewallUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterFirewallUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterFirewallUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterFirewallUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterFirewallUpdateTargets(ctx, vpcRouterFirewallUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterFirewallUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("firewall-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterFirewallUpdateParam.SetId(id)
				go func(p *params.FirewallUpdateVPCRouterParam) {
					err := funcs.VPCRouterFirewallUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterFirewallUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterFirewallUpdateParam.Interface, "interface", "", 0, "set target NIC index")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.Direction, "direction", "", "receive", "set target direction[send/receive]")
	fs.IntVarP(&vpcRouterFirewallUpdateParam.Index, "index", "", 0, "index of target Firewall rule")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.Protocol, "protocol", "", "", "set target protocol")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.SourceNetwork, "source-network", "", "", "set source ipaddress or network address")
	fs.IntVarP(&vpcRouterFirewallUpdateParam.SourcePort, "source-port", "", 0, "set source port")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.DestinationNetwork, "destination-network", "", "", "set destination ipaddress or network address (aliases: dest-network)")
	fs.IntVarP(&vpcRouterFirewallUpdateParam.DestinationPort, "destination-port", "", 0, "set destination port (aliases: dest-port)")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.Action, "action", "", "deny", "set action[allow/deny]")
	fs.BoolVarP(&vpcRouterFirewallUpdateParam.EnableLogging, "enable-logging", "", false, "enable logging")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.Description, "description", "", "", "set description (aliases: desc)")
	fs.StringSliceVarP(&vpcRouterFirewallUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterFirewallUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterFirewallUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterFirewallUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterFirewallUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterFirewallUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterFirewallUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterFirewallDeleteCmd() *cobra.Command {
	vpcRouterFirewallDeleteParam := params.NewFirewallDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "firewall-delete",

		Short:        "Delete firewall rule",
		Long:         `Delete firewall rule`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterFirewallDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterFirewallDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterFirewallDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterFirewallDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterFirewallDeleteTargets(ctx, vpcRouterFirewallDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterFirewallDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("firewall-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterFirewallDeleteParam.SetId(id)
				go func(p *params.FirewallDeleteVPCRouterParam) {
					err := funcs.VPCRouterFirewallDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterFirewallDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterFirewallDeleteParam.Interface, "interface", "", 0, "set target NIC index")
	fs.StringVarP(&vpcRouterFirewallDeleteParam.Direction, "direction", "", "receive", "set target direction[send/receive]")
	fs.IntVarP(&vpcRouterFirewallDeleteParam.Index, "index", "", 0, "index of target Firewall rule")
	fs.StringSliceVarP(&vpcRouterFirewallDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterFirewallDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterFirewallDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterFirewallDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterFirewallDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterFirewallDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterFirewallDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterFirewallDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterFirewallDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterFirewallDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpServerInfoCmd() *cobra.Command {
	vpcRouterDhcpServerInfoParam := params.NewDhcpServerInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "dhcp-server-info",
		Aliases:      []string{"dhcp-server-list"},
		Short:        "Show information of DHCP servers",
		Long:         `Show information of DHCP servers`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpServerInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpServerInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpServerInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpServerInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpServerInfoTargets(ctx, vpcRouterDhcpServerInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpServerInfoParam.SetId(id)
				go func(p *params.DhcpServerInfoVPCRouterParam) {
					err := funcs.VPCRouterDhcpServerInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpServerInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterDhcpServerInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpServerInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterDhcpServerInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterDhcpServerInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterDhcpServerInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterDhcpServerInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpServerInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpServerInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpServerAddCmd() *cobra.Command {
	vpcRouterDhcpServerAddParam := params.NewDhcpServerAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "dhcp-server-add",

		Short:        "Add DHCP server",
		Long:         `Add DHCP server`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpServerAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpServerAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpServerAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpServerAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpServerAddTargets(ctx, vpcRouterDhcpServerAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDhcpServerAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("dhcp-server-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpServerAddParam.SetId(id)
				go func(p *params.DhcpServerAddVPCRouterParam) {
					err := funcs.VPCRouterDhcpServerAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpServerAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterDhcpServerAddParam.Interface, "interface", "", 0, "set target NIC(private NIC index)")
	fs.StringVarP(&vpcRouterDhcpServerAddParam.RangeStart, "range-start", "", "", "set DHCP IPAddress Range(start)")
	fs.StringVarP(&vpcRouterDhcpServerAddParam.RangeStop, "range-stop", "", "", "set DHCP IPAddress Range(stop) (aliases: range-end)")
	fs.StringSliceVarP(&vpcRouterDhcpServerAddParam.DNSServers, "dns-servers", "", []string{}, "set DNS Server IPAddress")
	fs.StringSliceVarP(&vpcRouterDhcpServerAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDhcpServerAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDhcpServerAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpServerAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpServerAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpServerAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpServerAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDhcpServerAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpServerAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpServerAddFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpServerUpdateCmd() *cobra.Command {
	vpcRouterDhcpServerUpdateParam := params.NewDhcpServerUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "dhcp-server-update",

		Short:        "Update DHCP server",
		Long:         `Update DHCP server`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpServerUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpServerUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpServerUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpServerUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpServerUpdateTargets(ctx, vpcRouterDhcpServerUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDhcpServerUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("dhcp-server-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpServerUpdateParam.SetId(id)
				go func(p *params.DhcpServerUpdateVPCRouterParam) {
					err := funcs.VPCRouterDhcpServerUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpServerUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterDhcpServerUpdateParam.Interface, "interface", "", 0, "set target NIC(private NIC index)")
	fs.StringVarP(&vpcRouterDhcpServerUpdateParam.RangeStart, "range-start", "", "", "set DHCP IPAddress Range(start)")
	fs.StringVarP(&vpcRouterDhcpServerUpdateParam.RangeStop, "range-stop", "", "", "set DHCP IPAddress Range(stop) (aliases: range-end)")
	fs.StringSliceVarP(&vpcRouterDhcpServerUpdateParam.DNSServers, "dns-servers", "", []string{}, "set DNS Server IPAddress")
	fs.StringSliceVarP(&vpcRouterDhcpServerUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDhcpServerUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDhcpServerUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpServerUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpServerUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpServerUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpServerUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDhcpServerUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpServerUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpServerUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpServerDeleteCmd() *cobra.Command {
	vpcRouterDhcpServerDeleteParam := params.NewDhcpServerDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "dhcp-server-delete",

		Short:        "Delete DHCP server",
		Long:         `Delete DHCP server`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpServerDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpServerDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpServerDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpServerDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpServerDeleteTargets(ctx, vpcRouterDhcpServerDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDhcpServerDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("dhcp-server-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpServerDeleteParam.SetId(id)
				go func(p *params.DhcpServerDeleteVPCRouterParam) {
					err := funcs.VPCRouterDhcpServerDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpServerDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterDhcpServerDeleteParam.Interface, "interface", "", 0, "set target NIC(private NIC index)")
	fs.StringSliceVarP(&vpcRouterDhcpServerDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDhcpServerDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDhcpServerDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpServerDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpServerDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpServerDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpServerDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDhcpServerDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpServerDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpServerDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpStaticMappingInfoCmd() *cobra.Command {
	vpcRouterDhcpStaticMappingInfoParam := params.NewDhcpStaticMappingInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "dhcp-static-mapping-info",
		Aliases:      []string{"dhcp-static-mapping-list"},
		Short:        "Show information of DHCP static mapping",
		Long:         `Show information of DHCP static mapping`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpStaticMappingInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpStaticMappingInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpStaticMappingInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpStaticMappingInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpStaticMappingInfoTargets(ctx, vpcRouterDhcpStaticMappingInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpStaticMappingInfoParam.SetId(id)
				go func(p *params.DhcpStaticMappingInfoVPCRouterParam) {
					err := funcs.VPCRouterDhcpStaticMappingInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpStaticMappingInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterDhcpStaticMappingInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterDhcpStaticMappingInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterDhcpStaticMappingInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpStaticMappingInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpStaticMappingInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpStaticMappingAddCmd() *cobra.Command {
	vpcRouterDhcpStaticMappingAddParam := params.NewDhcpStaticMappingAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "dhcp-static-mapping-add",

		Short:        "Add DHCP static mapping",
		Long:         `Add DHCP static mapping`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpStaticMappingAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpStaticMappingAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpStaticMappingAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpStaticMappingAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpStaticMappingAddTargets(ctx, vpcRouterDhcpStaticMappingAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDhcpStaticMappingAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("dhcp-static-mapping-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpStaticMappingAddParam.SetId(id)
				go func(p *params.DhcpStaticMappingAddVPCRouterParam) {
					err := funcs.VPCRouterDhcpStaticMappingAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpStaticMappingAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterDhcpStaticMappingAddParam.Macaddress, "macaddress", "", "", "set mac address (aliases: mac)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingAddParam.Ipaddress, "ipaddress", "", "", "set ipaddress (aliases: ip)")
	fs.StringSliceVarP(&vpcRouterDhcpStaticMappingAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDhcpStaticMappingAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpStaticMappingAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpStaticMappingAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDhcpStaticMappingAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpStaticMappingAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpStaticMappingAddFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpStaticMappingUpdateCmd() *cobra.Command {
	vpcRouterDhcpStaticMappingUpdateParam := params.NewDhcpStaticMappingUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "dhcp-static-mapping-update",

		Short:        "Update DHCP static mapping",
		Long:         `Update DHCP static mapping`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpStaticMappingUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpStaticMappingUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpStaticMappingUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpStaticMappingUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpStaticMappingUpdateTargets(ctx, vpcRouterDhcpStaticMappingUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDhcpStaticMappingUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("dhcp-static-mapping-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpStaticMappingUpdateParam.SetId(id)
				go func(p *params.DhcpStaticMappingUpdateVPCRouterParam) {
					err := funcs.VPCRouterDhcpStaticMappingUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpStaticMappingUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterDhcpStaticMappingUpdateParam.Index, "index", "", 0, "index of target DHCP static mapping")
	fs.StringVarP(&vpcRouterDhcpStaticMappingUpdateParam.Macaddress, "macaddress", "", "", "set mac address (aliases: mac)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingUpdateParam.Ipaddress, "ipaddress", "", "", "set ipaddress (aliases: ip)")
	fs.StringSliceVarP(&vpcRouterDhcpStaticMappingUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDhcpStaticMappingUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpStaticMappingUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpStaticMappingUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDhcpStaticMappingUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpStaticMappingUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpStaticMappingUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterDhcpStaticMappingDeleteCmd() *cobra.Command {
	vpcRouterDhcpStaticMappingDeleteParam := params.NewDhcpStaticMappingDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "dhcp-static-mapping-delete",

		Short:        "Delete DHCP static mapping",
		Long:         `Delete DHCP static mapping`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterDhcpStaticMappingDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterDhcpStaticMappingDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterDhcpStaticMappingDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterDhcpStaticMappingDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterDhcpStaticMappingDeleteTargets(ctx, vpcRouterDhcpStaticMappingDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterDhcpStaticMappingDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("dhcp-static-mapping-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterDhcpStaticMappingDeleteParam.SetId(id)
				go func(p *params.DhcpStaticMappingDeleteVPCRouterParam) {
					err := funcs.VPCRouterDhcpStaticMappingDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterDhcpStaticMappingDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterDhcpStaticMappingDeleteParam.Index, "index", "", 0, "index of target DHCP static mapping")
	fs.StringSliceVarP(&vpcRouterDhcpStaticMappingDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterDhcpStaticMappingDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterDhcpStaticMappingDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterDhcpStaticMappingDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterDhcpStaticMappingDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterDhcpStaticMappingDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterDhcpStaticMappingDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterDhcpStaticMappingDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterDhcpStaticMappingDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterPptpServerInfoCmd() *cobra.Command {
	vpcRouterPptpServerInfoParam := params.NewPptpServerInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use: "pptp-server-info",

		Short:        "Show information of PPTP server",
		Long:         `Show information of PPTP server`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterPptpServerInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterPptpServerInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterPptpServerInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterPptpServerInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterPptpServerInfoTargets(ctx, vpcRouterPptpServerInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterPptpServerInfoParam.SetId(id)
				go func(p *params.PptpServerInfoVPCRouterParam) {
					err := funcs.VPCRouterPptpServerInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterPptpServerInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterPptpServerInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterPptpServerInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterPptpServerInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterPptpServerInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterPptpServerInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterPptpServerInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterPptpServerInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterPptpServerInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterPptpServerUpdateCmd() *cobra.Command {
	vpcRouterPptpServerUpdateParam := params.NewPptpServerUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "pptp-server-update",

		Short:        "Update PPTP server setting",
		Long:         `Update PPTP server setting`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterPptpServerUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterPptpServerUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterPptpServerUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterPptpServerUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterPptpServerUpdateTargets(ctx, vpcRouterPptpServerUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterPptpServerUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("pptp-server-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterPptpServerUpdateParam.SetId(id)
				go func(p *params.PptpServerUpdateVPCRouterParam) {
					err := funcs.VPCRouterPptpServerUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterPptpServerUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&vpcRouterPptpServerUpdateParam.Disabled, "disabled", "", false, "enable/disable PPTP server")
	fs.StringVarP(&vpcRouterPptpServerUpdateParam.RangeStart, "range-start", "", "", "set IPAddress Range(start)")
	fs.StringVarP(&vpcRouterPptpServerUpdateParam.RangeStop, "range-stop", "", "", "set IPAddress Range(stop) (aliases: range-end)")
	fs.StringSliceVarP(&vpcRouterPptpServerUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterPptpServerUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterPptpServerUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterPptpServerUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterPptpServerUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterPptpServerUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterPptpServerUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterPptpServerUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterPptpServerUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterPptpServerUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterL2TPServerInfoCmd() *cobra.Command {
	vpcRouterL2TPServerInfoParam := params.NewL2TPServerInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use: "l2tp-server-info",

		Short:        "Show information of L2TP/IPSec server",
		Long:         `Show information of L2TP/IPSec server`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterL2TPServerInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterL2TPServerInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterL2TPServerInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterL2TPServerInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterL2TPServerInfoTargets(ctx, vpcRouterL2TPServerInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterL2TPServerInfoParam.SetId(id)
				go func(p *params.L2TPServerInfoVPCRouterParam) {
					err := funcs.VPCRouterL2TPServerInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterL2TPServerInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterL2TPServerInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterL2TPServerInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterL2TPServerInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterL2TPServerInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterL2TPServerInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterL2TPServerInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterL2TPServerInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterL2TPServerInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterL2TPServerUpdateCmd() *cobra.Command {
	vpcRouterL2TPServerUpdateParam := params.NewL2TPServerUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "l2tp-server-update",

		Short:        "Update L2TP/IPSec server setting",
		Long:         `Update L2TP/IPSec server setting`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterL2TPServerUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterL2TPServerUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterL2TPServerUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterL2TPServerUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterL2TPServerUpdateTargets(ctx, vpcRouterL2TPServerUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterL2TPServerUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("l2tp-server-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterL2TPServerUpdateParam.SetId(id)
				go func(p *params.L2TPServerUpdateVPCRouterParam) {
					err := funcs.VPCRouterL2TPServerUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterL2TPServerUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&vpcRouterL2TPServerUpdateParam.Disabled, "disabled", "", false, "enable/disable PPTP server")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.RangeStart, "range-start", "", "", "set IPAddress Range(start)")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.RangeStop, "range-stop", "", "", "set IPAddress Range(stop) (aliases: range-end)")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.PreSharedSecret, "pre-shared-secret", "", "", "set PreSharedSecret")
	fs.StringSliceVarP(&vpcRouterL2TPServerUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterL2TPServerUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterL2TPServerUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterL2TPServerUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterL2TPServerUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterL2TPServerUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterL2TPServerUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterUserInfoCmd() *cobra.Command {
	vpcRouterUserInfoParam := params.NewUserInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "user-info",
		Aliases:      []string{"user-list"},
		Short:        "Show information of remote-access users",
		Long:         `Show information of remote-access users`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterUserInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterUserInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterUserInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterUserInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterUserInfoTargets(ctx, vpcRouterUserInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterUserInfoParam.SetId(id)
				go func(p *params.UserInfoVPCRouterParam) {
					err := funcs.VPCRouterUserInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterUserInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterUserInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterUserInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterUserInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterUserInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterUserInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterUserInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterUserInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterUserInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterUserInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterUserInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterUserInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterUserInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterUserInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterUserInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterUserInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterUserInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterUserAddCmd() *cobra.Command {
	vpcRouterUserAddParam := params.NewUserAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "user-add",

		Short:        "Add remote-access user",
		Long:         `Add remote-access user`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterUserAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterUserAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterUserAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterUserAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterUserAddTargets(ctx, vpcRouterUserAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterUserAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("user-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterUserAddParam.SetId(id)
				go func(p *params.UserAddVPCRouterParam) {
					err := funcs.VPCRouterUserAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterUserAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterUserAddParam.Username, "username", "", "", "set remote-access username (aliases: user)")
	fs.StringVarP(&vpcRouterUserAddParam.Password, "password", "", "", "set remote-access password (aliases: pass)")
	fs.StringSliceVarP(&vpcRouterUserAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterUserAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterUserAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterUserAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterUserAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterUserAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterUserAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterUserAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterUserAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterUserAddFlagOrder(cmd))
	return cmd
}

func vpcRouterUserUpdateCmd() *cobra.Command {
	vpcRouterUserUpdateParam := params.NewUserUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "user-update",

		Short:        "Update remote-access user",
		Long:         `Update remote-access user`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterUserUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterUserUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterUserUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterUserUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterUserUpdateTargets(ctx, vpcRouterUserUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterUserUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("user-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterUserUpdateParam.SetId(id)
				go func(p *params.UserUpdateVPCRouterParam) {
					err := funcs.VPCRouterUserUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterUserUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterUserUpdateParam.Index, "index", "", 0, "index of target remote-access user")
	fs.StringVarP(&vpcRouterUserUpdateParam.Username, "username", "", "", "set remote-access username (aliases: user)")
	fs.StringVarP(&vpcRouterUserUpdateParam.Password, "password", "", "", "set remote-access password (aliases: pass)")
	fs.StringSliceVarP(&vpcRouterUserUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterUserUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterUserUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterUserUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterUserUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterUserUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterUserUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterUserUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterUserUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterUserUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterUserDeleteCmd() *cobra.Command {
	vpcRouterUserDeleteParam := params.NewUserDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "user-delete",

		Short:        "Delete remote-access user",
		Long:         `Delete remote-access user`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterUserDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterUserDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterUserDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterUserDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterUserDeleteTargets(ctx, vpcRouterUserDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterUserDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("user-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterUserDeleteParam.SetId(id)
				go func(p *params.UserDeleteVPCRouterParam) {
					err := funcs.VPCRouterUserDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterUserDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterUserDeleteParam.Index, "index", "", 0, "index of target remote-access user")
	fs.StringSliceVarP(&vpcRouterUserDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterUserDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterUserDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterUserDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterUserDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterUserDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterUserDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterUserDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterUserDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterUserDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterSiteToSiteVPNInfoCmd() *cobra.Command {
	vpcRouterSiteToSiteVPNInfoParam := params.NewSiteToSiteVPNInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "site-to-site-vpn-info",
		Aliases:      []string{"site-to-site-vpn-list"},
		Short:        "Show information of site-to-site IPSec VPN settings",
		Long:         `Show information of site-to-site IPSec VPN settings`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterSiteToSiteVPNInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterSiteToSiteVPNInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterSiteToSiteVPNInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterSiteToSiteVPNInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterSiteToSiteVPNInfoTargets(ctx, vpcRouterSiteToSiteVPNInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterSiteToSiteVPNInfoParam.SetId(id)
				go func(p *params.SiteToSiteVPNInfoVPCRouterParam) {
					err := funcs.VPCRouterSiteToSiteVPNInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterSiteToSiteVPNInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterSiteToSiteVPNInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterSiteToSiteVPNInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterSiteToSiteVPNInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterSiteToSiteVPNAddCmd() *cobra.Command {
	vpcRouterSiteToSiteVPNAddParam := params.NewSiteToSiteVPNAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "site-to-site-vpn-add",

		Short:        "Add site-to-site IPSec VPN setting",
		Long:         `Add site-to-site IPSec VPN setting`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterSiteToSiteVPNAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterSiteToSiteVPNAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterSiteToSiteVPNAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterSiteToSiteVPNAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterSiteToSiteVPNAddTargets(ctx, vpcRouterSiteToSiteVPNAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterSiteToSiteVPNAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("site-to-site-vpn-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterSiteToSiteVPNAddParam.SetId(id)
				go func(p *params.SiteToSiteVPNAddVPCRouterParam) {
					err := funcs.VPCRouterSiteToSiteVPNAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterSiteToSiteVPNAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.Peer, "peer", "", "", "set peer address")
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.RemoteId, "remote-id", "", "", "set remote-id")
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.PreSharedSecret, "pre-shared-secret", "", "", "set pre-shared-secret")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNAddParam.Routes, "routes", "", []string{}, "set route list")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNAddParam.LocalPrefix, "local-prefix", "", []string{}, "set local prefix list")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterSiteToSiteVPNAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterSiteToSiteVPNAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterSiteToSiteVPNAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterSiteToSiteVPNAddFlagOrder(cmd))
	return cmd
}

func vpcRouterSiteToSiteVPNUpdateCmd() *cobra.Command {
	vpcRouterSiteToSiteVPNUpdateParam := params.NewSiteToSiteVPNUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "site-to-site-vpn-update",

		Short:        "Update site-to-site IPSec VPN setting",
		Long:         `Update site-to-site IPSec VPN setting`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterSiteToSiteVPNUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterSiteToSiteVPNUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterSiteToSiteVPNUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterSiteToSiteVPNUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterSiteToSiteVPNUpdateTargets(ctx, vpcRouterSiteToSiteVPNUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterSiteToSiteVPNUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("site-to-site-vpn-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterSiteToSiteVPNUpdateParam.SetId(id)
				go func(p *params.SiteToSiteVPNUpdateVPCRouterParam) {
					err := funcs.VPCRouterSiteToSiteVPNUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterSiteToSiteVPNUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterSiteToSiteVPNUpdateParam.Index, "index", "", 0, "index of target remote-access user")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.Peer, "peer", "", "", "set peer address")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.RemoteId, "remote-id", "", "", "set remote-id")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.PreSharedSecret, "pre-shared-secret", "", "", "set pre-shared-secret")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNUpdateParam.Routes, "routes", "", []string{}, "set route list")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNUpdateParam.LocalPrefix, "local-prefix", "", []string{}, "set local prefix list")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterSiteToSiteVPNUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterSiteToSiteVPNUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterSiteToSiteVPNUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterSiteToSiteVPNUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterSiteToSiteVPNDeleteCmd() *cobra.Command {
	vpcRouterSiteToSiteVPNDeleteParam := params.NewSiteToSiteVPNDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "site-to-site-vpn-delete",

		Short:        "Delete site-to-site IPSec VPN setting",
		Long:         `Delete site-to-site IPSec VPN setting`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterSiteToSiteVPNDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterSiteToSiteVPNDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterSiteToSiteVPNDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterSiteToSiteVPNDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterSiteToSiteVPNDeleteTargets(ctx, vpcRouterSiteToSiteVPNDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterSiteToSiteVPNDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("site-to-site-vpn-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterSiteToSiteVPNDeleteParam.SetId(id)
				go func(p *params.SiteToSiteVPNDeleteVPCRouterParam) {
					err := funcs.VPCRouterSiteToSiteVPNDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterSiteToSiteVPNDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterSiteToSiteVPNDeleteParam.Index, "index", "", 0, "index of target remote-access user")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterSiteToSiteVPNDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterSiteToSiteVPNDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterSiteToSiteVPNDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterSiteToSiteVPNDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterSiteToSiteVPNDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterSiteToSiteVPNDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterSiteToSiteVPNPeersCmd() *cobra.Command {
	vpcRouterSiteToSiteVPNPeersParam := params.NewSiteToSiteVPNPeersVPCRouterParam()
	cmd := &cobra.Command{
		Use: "site-to-site-vpn-peers",

		Short:        "Show status of site-to-site IPSec VPN peers",
		Long:         `Show status of site-to-site IPSec VPN peers`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterSiteToSiteVPNPeersParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterSiteToSiteVPNPeersParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterSiteToSiteVPNPeersParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterSiteToSiteVPNPeersParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterSiteToSiteVPNPeersTargets(ctx, vpcRouterSiteToSiteVPNPeersParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterSiteToSiteVPNPeersParam.SetId(id)
				go func(p *params.SiteToSiteVPNPeersVPCRouterParam) {
					err := funcs.VPCRouterSiteToSiteVPNPeers(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterSiteToSiteVPNPeersParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNPeersParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNPeersParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterSiteToSiteVPNPeersParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterSiteToSiteVPNPeersParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterSiteToSiteVPNPeersParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterSiteToSiteVPNPeersParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterSiteToSiteVPNPeersNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterSiteToSiteVPNPeersFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticRouteInfoCmd() *cobra.Command {
	vpcRouterStaticRouteInfoParam := params.NewStaticRouteInfoVPCRouterParam()
	cmd := &cobra.Command{
		Use:          "static-route-info",
		Aliases:      []string{"static-route-list"},
		Short:        "Show information of static-routes",
		Long:         `Show information of static-routes`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticRouteInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticRouteInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticRouteInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticRouteInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticRouteInfoTargets(ctx, vpcRouterStaticRouteInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticRouteInfoParam.SetId(id)
				go func(p *params.StaticRouteInfoVPCRouterParam) {
					err := funcs.VPCRouterStaticRouteInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticRouteInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&vpcRouterStaticRouteInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticRouteInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterStaticRouteInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterStaticRouteInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterStaticRouteInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterStaticRouteInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticRouteInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticRouteInfoFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticRouteAddCmd() *cobra.Command {
	vpcRouterStaticRouteAddParam := params.NewStaticRouteAddVPCRouterParam()
	cmd := &cobra.Command{
		Use: "static-route-add",

		Short:        "Add static-route",
		Long:         `Add static-route`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticRouteAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticRouteAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticRouteAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticRouteAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticRouteAddTargets(ctx, vpcRouterStaticRouteAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterStaticRouteAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("static-route-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticRouteAddParam.SetId(id)
				go func(p *params.StaticRouteAddVPCRouterParam) {
					err := funcs.VPCRouterStaticRouteAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticRouteAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterStaticRouteAddParam.Prefix, "prefix", "", "", "set prefix")
	fs.StringVarP(&vpcRouterStaticRouteAddParam.NextHop, "next-hop", "", "", "set next-hop")
	fs.StringSliceVarP(&vpcRouterStaticRouteAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterStaticRouteAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterStaticRouteAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticRouteAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticRouteAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticRouteAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticRouteAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterStaticRouteAddParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticRouteAddNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticRouteAddFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticRouteUpdateCmd() *cobra.Command {
	vpcRouterStaticRouteUpdateParam := params.NewStaticRouteUpdateVPCRouterParam()
	cmd := &cobra.Command{
		Use: "static-route-update",

		Short:        "Update static-route",
		Long:         `Update static-route`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticRouteUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticRouteUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticRouteUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticRouteUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticRouteUpdateTargets(ctx, vpcRouterStaticRouteUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterStaticRouteUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("static-route-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticRouteUpdateParam.SetId(id)
				go func(p *params.StaticRouteUpdateVPCRouterParam) {
					err := funcs.VPCRouterStaticRouteUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticRouteUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterStaticRouteUpdateParam.Index, "index", "", 0, "index of target static-route")
	fs.StringVarP(&vpcRouterStaticRouteUpdateParam.Prefix, "prefix", "", "", "set prefix")
	fs.StringVarP(&vpcRouterStaticRouteUpdateParam.NextHop, "next-hop", "", "", "set next-hop")
	fs.StringSliceVarP(&vpcRouterStaticRouteUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterStaticRouteUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterStaticRouteUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticRouteUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticRouteUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticRouteUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticRouteUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterStaticRouteUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticRouteUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticRouteUpdateFlagOrder(cmd))
	return cmd
}

func vpcRouterStaticRouteDeleteCmd() *cobra.Command {
	vpcRouterStaticRouteDeleteParam := params.NewStaticRouteDeleteVPCRouterParam()
	cmd := &cobra.Command{
		Use: "static-route-delete",

		Short:        "Delete static-route",
		Long:         `Delete static-route`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterStaticRouteDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterStaticRouteDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterStaticRouteDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterStaticRouteDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterStaticRouteDeleteTargets(ctx, vpcRouterStaticRouteDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !vpcRouterStaticRouteDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("static-route-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterStaticRouteDeleteParam.SetId(id)
				go func(p *params.StaticRouteDeleteVPCRouterParam) {
					err := funcs.VPCRouterStaticRouteDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterStaticRouteDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&vpcRouterStaticRouteDeleteParam.Index, "index", "", 0, "index of target static-route")
	fs.StringSliceVarP(&vpcRouterStaticRouteDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&vpcRouterStaticRouteDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&vpcRouterStaticRouteDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterStaticRouteDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterStaticRouteDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterStaticRouteDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterStaticRouteDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterStaticRouteDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterStaticRouteDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterStaticRouteDeleteFlagOrder(cmd))
	return cmd
}

func vpcRouterMonitorCmd() *cobra.Command {
	vpcRouterMonitorParam := params.NewMonitorVPCRouterParam()
	cmd := &cobra.Command{
		Use: "monitor",

		Short:        "Monitor VPCRouter",
		Long:         `Monitor VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterMonitorParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterMonitorParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterMonitorParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterMonitorParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterMonitorTargets(ctx, vpcRouterMonitorParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterMonitorParam.SetId(id)
				go func(p *params.MonitorVPCRouterParam) {
					err := funcs.VPCRouterMonitor(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterMonitorParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterMonitorParam.Interface, "interface", "", "0", "index of target interface")
	fs.StringVarP(&vpcRouterMonitorParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&vpcRouterMonitorParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&vpcRouterMonitorParam.KeyFormat, "key-format", "", "sakuracloud.vpcrouter.{{.ID}}.nic.{{.Index}}", "set monitoring value key-format")
	fs.StringSliceVarP(&vpcRouterMonitorParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterMonitorParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterMonitorParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterMonitorParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterMonitorParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterMonitorParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&vpcRouterMonitorParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&vpcRouterMonitorParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&vpcRouterMonitorParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&vpcRouterMonitorParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&vpcRouterMonitorParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&vpcRouterMonitorParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&vpcRouterMonitorParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &vpcRouterMonitorParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterMonitorNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterMonitorFlagOrder(cmd))
	return cmd
}

func vpcRouterLogsCmd() *cobra.Command {
	vpcRouterLogsParam := params.NewLogsVPCRouterParam()
	cmd := &cobra.Command{
		Use: "logs",

		Short:        "Logs VPCRouter",
		Long:         `Logs VPCRouter`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return vpcRouterLogsParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, vpcRouterLogsParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if vpcRouterLogsParam.GenerateSkeleton {
				return generateSkeleton(ctx, vpcRouterLogsParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findVPCRouterLogsTargets(ctx, vpcRouterLogsParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				vpcRouterLogsParam.SetId(id)
				go func(p *params.LogsVPCRouterParam) {
					err := funcs.VPCRouterLogs(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(vpcRouterLogsParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&vpcRouterLogsParam.LogName, "log-name", "", "all", "set target logfile name (aliases: name)")
	fs.BoolVarP(&vpcRouterLogsParam.Follow, "follow", "f", false, "follow log output")
	fs.Int64VarP(&vpcRouterLogsParam.RefreshInterval, "refresh-interval", "", 3, "log refresh interval second")
	fs.BoolVarP(&vpcRouterLogsParam.ListLogNames, "list-log-names", "", false, "show log-name list")
	fs.StringSliceVarP(&vpcRouterLogsParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&vpcRouterLogsParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&vpcRouterLogsParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&vpcRouterLogsParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&vpcRouterLogsParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&vpcRouterLogsParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &vpcRouterLogsParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(vpcRouterLogsNormalizeFlagNames)
	buildFlagsUsage(cmd, vpcRouterLogsFlagOrder(cmd))
	return cmd
}
