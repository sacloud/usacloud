// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-commands'; DO NOT EDIT

package cmd

import (
	"errors"
	"sync"

	"github.com/sacloud/libsacloud/sacloud"
	"github.com/sacloud/usacloud/pkg/cli"
	"github.com/sacloud/usacloud/pkg/funcs"
	"github.com/sacloud/usacloud/pkg/params"
	"github.com/sacloud/usacloud/pkg/utils"
	"github.com/spf13/cobra"
)

// simCmd represents the command to manage SAKURA Cloud SIM
func simCmd() *cobra.Command {
	return &cobra.Command{
		Use: "sim",

		Short: "A manage commands of SIM",
		Long:  `A manage commands of SIM`,
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.HelpFunc()(cmd, args)
			return nil
		},
	}
}

func simListCmd() *cobra.Command {
	simListParam := params.NewListSIMParam()
	cmd := &cobra.Command{
		Use:          "list",
		Aliases:      []string{"ls", "find", "select"},
		Short:        "List SIM",
		Long:         `List SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simListParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simListParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simListParam.GenerateSkeleton {
				return generateSkeleton(ctx, simListParam)
			}

			return funcs.SIMList(ctx, simListParam)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simListParam.Name, "name", "", []string{}, "set filter by name(s)")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &simListParam.Id), "id", "", "set filter by id(s)")
	fs.StringSliceVarP(&simListParam.Tags, "tags", "", []string{}, "set filter by tags(AND) (aliases: selector)")
	fs.IntVarP(&simListParam.From, "from", "", 0, "set offset (aliases: offset)")
	fs.IntVarP(&simListParam.Max, "max", "", 0, "set limit (aliases: limit)")
	fs.StringSliceVarP(&simListParam.Sort, "sort", "", []string{}, "set field(s) for sort")
	fs.StringVarP(&simListParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simListParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simListParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simListParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simListParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simListParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simListParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simListParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simListParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simListParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simListParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simListParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.SetNormalizeFunc(simListNormalizeFlagNames)
	buildFlagsUsage(cmd, simListFlagOrder(cmd))
	return cmd
}

func simCreateCmd() *cobra.Command {
	simCreateParam := params.NewCreateSIMParam()
	cmd := &cobra.Command{
		Use: "create",

		Short:        "Create SIM",
		Long:         `Create SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simCreateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simCreateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simCreateParam.GenerateSkeleton {
				return generateSkeleton(ctx, simCreateParam)
			}

			// confirm
			if !simCreateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("create", ctx.IO().In(), ctx.IO().Out())
				if err != nil || !result {
					return err
				}
			}

			return funcs.SIMCreate(ctx, simCreateParam)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&simCreateParam.Iccid, "iccid", "", "", "")
	fs.StringVarP(&simCreateParam.Passcode, "passcode", "", "", "")
	fs.BoolVarP(&simCreateParam.Disabled, "disabled", "", false, "")
	fs.StringVarP(&simCreateParam.Imei, "imei", "", "", "")
	fs.StringSliceVarP(&simCreateParam.Carrier, "carrier", "", []string{}, "")
	fs.StringVarP(&simCreateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&simCreateParam.Description, "description", "", "", "set resource description (aliases: desc)")
	fs.StringSliceVarP(&simCreateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &simCreateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&simCreateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simCreateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simCreateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simCreateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simCreateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simCreateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simCreateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simCreateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simCreateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simCreateParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simCreateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simCreateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simCreateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.SetNormalizeFunc(simCreateNormalizeFlagNames)
	buildFlagsUsage(cmd, simCreateFlagOrder(cmd))
	return cmd
}

func simReadCmd() *cobra.Command {
	simReadParam := params.NewReadSIMParam()
	cmd := &cobra.Command{
		Use: "read",

		Short:        "Read SIM",
		Long:         `Read SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simReadParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simReadParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simReadParam.GenerateSkeleton {
				return generateSkeleton(ctx, simReadParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMReadTargets(ctx, simReadParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simReadParam.SetId(id)
				go func(p *params.ReadSIMParam) {
					err := funcs.SIMRead(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simReadParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simReadParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&simReadParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simReadParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simReadParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simReadParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simReadParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simReadParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simReadParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simReadParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simReadParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simReadParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simReadParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simReadParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &simReadParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simReadNormalizeFlagNames)
	buildFlagsUsage(cmd, simReadFlagOrder(cmd))
	return cmd
}

func simUpdateCmd() *cobra.Command {
	simUpdateParam := params.NewUpdateSIMParam()
	cmd := &cobra.Command{
		Use: "update",

		Short:        "Update SIM",
		Long:         `Update SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, simUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMUpdateTargets(ctx, simUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !simUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simUpdateParam.SetId(id)
				go func(p *params.UpdateSIMParam) {
					err := funcs.SIMUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&simUpdateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&simUpdateParam.Description, "description", "", "", "set resource description (aliases: desc)")
	fs.StringSliceVarP(&simUpdateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &simUpdateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&simUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &simUpdateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, simUpdateFlagOrder(cmd))
	return cmd
}

func simDeleteCmd() *cobra.Command {
	simDeleteParam := params.NewDeleteSIMParam()
	cmd := &cobra.Command{
		Use:          "delete",
		Aliases:      []string{"rm"},
		Short:        "Delete SIM",
		Long:         `Delete SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, simDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMDeleteTargets(ctx, simDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !simDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simDeleteParam.SetId(id)
				go func(p *params.DeleteSIMParam) {
					err := funcs.SIMDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&simDeleteParam.Force, "force", "f", false, "forced-delete flag if SIM is still activating")
	fs.StringSliceVarP(&simDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, simDeleteFlagOrder(cmd))
	return cmd
}

func simCarrierInfoCmd() *cobra.Command {
	simCarrierInfoParam := params.NewCarrierInfoSIMParam()
	cmd := &cobra.Command{
		Use:          "carrier-info",
		Aliases:      []string{"carrier-list"},
		Short:        "CarrierInfo SIM",
		Long:         `CarrierInfo SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simCarrierInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simCarrierInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simCarrierInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, simCarrierInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMCarrierInfoTargets(ctx, simCarrierInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simCarrierInfoParam.SetId(id)
				go func(p *params.CarrierInfoSIMParam) {
					err := funcs.SIMCarrierInfo(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simCarrierInfoParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simCarrierInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&simCarrierInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simCarrierInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simCarrierInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simCarrierInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simCarrierInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simCarrierInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simCarrierInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simCarrierInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simCarrierInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simCarrierInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simCarrierInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simCarrierInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &simCarrierInfoParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simCarrierInfoNormalizeFlagNames)
	buildFlagsUsage(cmd, simCarrierInfoFlagOrder(cmd))
	return cmd
}

func simCarrierUpdateCmd() *cobra.Command {
	simCarrierUpdateParam := params.NewCarrierUpdateSIMParam()
	cmd := &cobra.Command{
		Use: "carrier-update",

		Short:        "CarrierUpdate SIM",
		Long:         `CarrierUpdate SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simCarrierUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simCarrierUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simCarrierUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, simCarrierUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMCarrierUpdateTargets(ctx, simCarrierUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !simCarrierUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("carrier-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simCarrierUpdateParam.SetId(id)
				go func(p *params.CarrierUpdateSIMParam) {
					err := funcs.SIMCarrierUpdate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simCarrierUpdateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simCarrierUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simCarrierUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simCarrierUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simCarrierUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simCarrierUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simCarrierUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simCarrierUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simCarrierUpdateParam.Id), "id", "", "Set target ID")
	fs.StringSliceVarP(&simCarrierUpdateParam.Carrier, "carrier", "", []string{}, "")
	fs.SetNormalizeFunc(simCarrierUpdateNormalizeFlagNames)
	buildFlagsUsage(cmd, simCarrierUpdateFlagOrder(cmd))
	return cmd
}

func simActivateCmd() *cobra.Command {
	simActivateParam := params.NewActivateSIMParam()
	cmd := &cobra.Command{
		Use: "activate",

		Short:        "Activate SIM",
		Long:         `Activate SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simActivateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simActivateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simActivateParam.GenerateSkeleton {
				return generateSkeleton(ctx, simActivateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMActivateTargets(ctx, simActivateParam)
			if err != nil {
				return err
			}

			// confirm
			if !simActivateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("activate", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simActivateParam.SetId(id)
				go func(p *params.ActivateSIMParam) {
					err := funcs.SIMActivate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simActivateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simActivateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simActivateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simActivateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simActivateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simActivateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simActivateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simActivateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simActivateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simActivateNormalizeFlagNames)
	buildFlagsUsage(cmd, simActivateFlagOrder(cmd))
	return cmd
}

func simDeactivateCmd() *cobra.Command {
	simDeactivateParam := params.NewDeactivateSIMParam()
	cmd := &cobra.Command{
		Use: "deactivate",

		Short:        "Deactivate SIM",
		Long:         `Deactivate SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simDeactivateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simDeactivateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simDeactivateParam.GenerateSkeleton {
				return generateSkeleton(ctx, simDeactivateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMDeactivateTargets(ctx, simDeactivateParam)
			if err != nil {
				return err
			}

			// confirm
			if !simDeactivateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("deactivate", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simDeactivateParam.SetId(id)
				go func(p *params.DeactivateSIMParam) {
					err := funcs.SIMDeactivate(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simDeactivateParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simDeactivateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simDeactivateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simDeactivateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simDeactivateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simDeactivateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simDeactivateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simDeactivateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simDeactivateParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simDeactivateNormalizeFlagNames)
	buildFlagsUsage(cmd, simDeactivateFlagOrder(cmd))
	return cmd
}

func simImeiLockCmd() *cobra.Command {
	simImeiLockParam := params.NewImeiLockSIMParam()
	cmd := &cobra.Command{
		Use: "imei-lock",

		Short:        "ImeiLock SIM",
		Long:         `ImeiLock SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simImeiLockParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simImeiLockParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simImeiLockParam.GenerateSkeleton {
				return generateSkeleton(ctx, simImeiLockParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMImeiLockTargets(ctx, simImeiLockParam)
			if err != nil {
				return err
			}

			// confirm
			if !simImeiLockParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("imei-lock", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simImeiLockParam.SetId(id)
				go func(p *params.ImeiLockSIMParam) {
					err := funcs.SIMImeiLock(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simImeiLockParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simImeiLockParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simImeiLockParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simImeiLockParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simImeiLockParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simImeiLockParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simImeiLockParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simImeiLockParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simImeiLockParam.Id), "id", "", "Set target ID")
	fs.StringVarP(&simImeiLockParam.Imei, "imei", "", "", "")
	fs.SetNormalizeFunc(simImeiLockNormalizeFlagNames)
	buildFlagsUsage(cmd, simImeiLockFlagOrder(cmd))
	return cmd
}

func simIpAddCmd() *cobra.Command {
	simIpAddParam := params.NewIpAddSIMParam()
	cmd := &cobra.Command{
		Use: "ip-add",

		Short:        "IpAdd SIM",
		Long:         `IpAdd SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simIpAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simIpAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simIpAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, simIpAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMIpAddTargets(ctx, simIpAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !simIpAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("ip-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simIpAddParam.SetId(id)
				go func(p *params.IpAddSIMParam) {
					err := funcs.SIMIpAdd(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simIpAddParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simIpAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simIpAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simIpAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simIpAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simIpAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simIpAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simIpAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simIpAddParam.Id), "id", "", "Set target ID")
	fs.StringVarP(&simIpAddParam.Ip, "ip", "", "", "")
	fs.SetNormalizeFunc(simIpAddNormalizeFlagNames)
	buildFlagsUsage(cmd, simIpAddFlagOrder(cmd))
	return cmd
}

func simImeiUnlockCmd() *cobra.Command {
	simImeiUnlockParam := params.NewImeiUnlockSIMParam()
	cmd := &cobra.Command{
		Use: "imei-unlock",

		Short:        "ImeiUnlock SIM",
		Long:         `ImeiUnlock SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simImeiUnlockParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simImeiUnlockParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simImeiUnlockParam.GenerateSkeleton {
				return generateSkeleton(ctx, simImeiUnlockParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMImeiUnlockTargets(ctx, simImeiUnlockParam)
			if err != nil {
				return err
			}

			// confirm
			if !simImeiUnlockParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("imei-unlock", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simImeiUnlockParam.SetId(id)
				go func(p *params.ImeiUnlockSIMParam) {
					err := funcs.SIMImeiUnlock(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simImeiUnlockParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simImeiUnlockParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simImeiUnlockParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simImeiUnlockParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simImeiUnlockParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simImeiUnlockParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simImeiUnlockParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simImeiUnlockParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simImeiUnlockParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simImeiUnlockNormalizeFlagNames)
	buildFlagsUsage(cmd, simImeiUnlockFlagOrder(cmd))
	return cmd
}

func simIpDeleteCmd() *cobra.Command {
	simIpDeleteParam := params.NewIpDeleteSIMParam()
	cmd := &cobra.Command{
		Use:          "ip-delete",
		Aliases:      []string{"ip-del"},
		Short:        "IpDelete SIM",
		Long:         `IpDelete SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simIpDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simIpDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simIpDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, simIpDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMIpDeleteTargets(ctx, simIpDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !simIpDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("ip-delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simIpDeleteParam.SetId(id)
				go func(p *params.IpDeleteSIMParam) {
					err := funcs.SIMIpDelete(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simIpDeleteParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&simIpDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&simIpDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&simIpDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simIpDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simIpDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simIpDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simIpDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &simIpDeleteParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simIpDeleteNormalizeFlagNames)
	buildFlagsUsage(cmd, simIpDeleteFlagOrder(cmd))
	return cmd
}

func simLogsCmd() *cobra.Command {
	simLogsParam := params.NewLogsSIMParam()
	cmd := &cobra.Command{
		Use: "logs",

		Short:        "Logs SIM",
		Long:         `Logs SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simLogsParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simLogsParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simLogsParam.GenerateSkeleton {
				return generateSkeleton(ctx, simLogsParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMLogsTargets(ctx, simLogsParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simLogsParam.SetId(id)
				go func(p *params.LogsSIMParam) {
					err := funcs.SIMLogs(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simLogsParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&simLogsParam.Follow, "follow", "f", false, "follow log output")
	fs.Int64VarP(&simLogsParam.RefreshInterval, "refresh-interval", "", 3, "log refresh interval second")
	fs.StringSliceVarP(&simLogsParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&simLogsParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simLogsParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simLogsParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simLogsParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simLogsParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simLogsParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simLogsParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simLogsParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simLogsParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simLogsParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simLogsParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simLogsParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &simLogsParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simLogsNormalizeFlagNames)
	buildFlagsUsage(cmd, simLogsFlagOrder(cmd))
	return cmd
}

func simMonitorCmd() *cobra.Command {
	simMonitorParam := params.NewMonitorSIMParam()
	cmd := &cobra.Command{
		Use: "monitor",

		Short:        "Monitor SIM",
		Long:         `Monitor SIM`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return simMonitorParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := cli.NewCLIContext(globalFlags(), args, simMonitorParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if simMonitorParam.GenerateSkeleton {
				return generateSkeleton(ctx, simMonitorParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findSIMMonitorTargets(ctx, simMonitorParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				simMonitorParam.SetId(id)
				go func(p *params.MonitorSIMParam) {
					err := funcs.SIMMonitor(ctx, p)
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(simMonitorParam)
			}
			wg.Wait()
			return cli.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&simMonitorParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&simMonitorParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&simMonitorParam.KeyFormat, "key-format", "", "sakuracloud.sim.{{.ID}}", "set monitoring value key-format")
	fs.StringSliceVarP(&simMonitorParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&simMonitorParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&simMonitorParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&simMonitorParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&simMonitorParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&simMonitorParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&simMonitorParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv] (aliases: out)")
	fs.StringSliceVarP(&simMonitorParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only) (aliases: col)")
	fs.BoolVarP(&simMonitorParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&simMonitorParam.Format, "format", "", "", "Output format(see text/template package document for detail) (aliases: fmt)")
	fs.StringVarP(&simMonitorParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&simMonitorParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&simMonitorParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &simMonitorParam.Id), "id", "", "Set target ID")
	fs.SetNormalizeFunc(simMonitorNormalizeFlagNames)
	buildFlagsUsage(cmd, simMonitorFlagOrder(cmd))
	return cmd
}
