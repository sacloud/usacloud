// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-v2-commands'; DO NOT EDIT

package commands

import (
	"errors"
	"sync"

	"github.com/sacloud/libsacloud/sacloud"
	"github.com/sacloud/usacloud/cmdv2/params"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/pkg/utils"
	"github.com/spf13/cobra"
)

// proxyLBCmd represents the command to manage SAKURA Cloud ProxyLB
func proxyLBCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "proxy-lb",
		Short: "A manage commands of ProxyLB",
		Long:  `A manage commands of ProxyLB`,
		Run: func(cmd *cobra.Command, args []string) {
			cmd.HelpFunc()(cmd, args)
		},
	}
}

func proxyLBListCmd() *cobra.Command {
	proxyLBListParam := params.NewListProxyLBParam()
	cmd := &cobra.Command{
		Use:          "list",
		Aliases:      []string{"ls", "find", "selector"},
		Short:        "List ProxyLB",
		Long:         `List ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBListParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBListParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBListParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBListParam)
			}

			return funcs.ProxyLBList(ctx, proxyLBListParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBListParam.Name, "name", "", []string{}, "set filter by name(s)")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &proxyLBListParam.Id), "id", "", "set filter by id(s)")
	fs.StringSliceVarP(&proxyLBListParam.Tags, "tags", "", []string{}, "set filter by tags(AND)")
	fs.IntVarP(&proxyLBListParam.From, "from", "", 0, "set offset")
	fs.IntVarP(&proxyLBListParam.Max, "max", "", 0, "set limit")
	fs.StringSliceVarP(&proxyLBListParam.Sort, "sort", "", []string{}, "set field(s) for sort")
	fs.StringVarP(&proxyLBListParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBListParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBListParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBListParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBListParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBListParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBListParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBListParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBListParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBListParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBListParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBListParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	buildFlagsUsage(cmd, proxyLBListFlagOrder(cmd))
	return cmd
}

func proxyLBCreateCmd() *cobra.Command {
	proxyLBCreateParam := params.NewCreateProxyLBParam()
	cmd := &cobra.Command{
		Use: "create",

		Short:        "Create ProxyLB",
		Long:         `Create ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBCreateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBCreateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBCreateParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBCreateParam)
			}

			// confirm
			if !proxyLBCreateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("create", ctx.IO().In(), ctx.IO().Out())
				if err != nil || !result {
					return err
				}
			}

			return funcs.ProxyLBCreate(ctx, proxyLBCreateParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBCreateParam.Plan, "plan", "", 1000, "set plan")
	fs.StringVarP(&proxyLBCreateParam.Protocol, "protocol", "", "tcp", "set healthcheck protocol[http/tcp]")
	fs.StringVarP(&proxyLBCreateParam.HostHeader, "host-header", "", "", "set host header of http/https healthcheck request")
	fs.StringVarP(&proxyLBCreateParam.Path, "path", "", "/", "set path of http/https healthcheck request")
	fs.IntVarP(&proxyLBCreateParam.DelayLoop, "delay-loop", "", 10, "set delay-loop of healthcheck")
	fs.BoolVarP(&proxyLBCreateParam.StickySession, "sticky-session", "", false, "enable sticky-session")
	fs.StringVarP(&proxyLBCreateParam.SorryServerIpaddress, "sorry-server-ipaddress", "", "", "set sorry-server ip address")
	fs.IntVarP(&proxyLBCreateParam.SorryServerPort, "sorry-server-port", "", 0, "set sorry-server ports")
	fs.IntVarP(&proxyLBCreateParam.Timeout, "timeout", "", 10, "set timeout")
	fs.StringVarP(&proxyLBCreateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&proxyLBCreateParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&proxyLBCreateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &proxyLBCreateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&proxyLBCreateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBCreateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBCreateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBCreateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBCreateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBCreateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBCreateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBCreateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBCreateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBCreateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCreateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCreateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBCreateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	buildFlagsUsage(cmd, proxyLBCreateFlagOrder(cmd))
	return cmd
}

func proxyLBReadCmd() *cobra.Command {
	proxyLBReadParam := params.NewReadProxyLBParam()
	cmd := &cobra.Command{
		Use: "read",

		Short:        "Read ProxyLB",
		Long:         `Read ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBReadParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBReadParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBReadParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBReadParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBReadTargets(ctx, proxyLBReadParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBReadParam.SetId(id)
				go func(p *params.ReadProxyLBParam) {
					err := funcs.ProxyLBRead(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBReadParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBReadParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBReadParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBReadParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBReadParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBReadParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBReadParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBReadParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBReadParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBReadParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBReadParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBReadParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBReadParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBReadParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBReadParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBReadFlagOrder(cmd))
	return cmd
}

func proxyLBUpdateCmd() *cobra.Command {
	proxyLBUpdateParam := params.NewUpdateProxyLBParam()
	cmd := &cobra.Command{
		Use: "update",

		Short:        "Update ProxyLB",
		Long:         `Update ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBUpdateTargets(ctx, proxyLBUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBUpdateParam.SetId(id)
				go func(p *params.UpdateProxyLBParam) {
					err := funcs.ProxyLBUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&proxyLBUpdateParam.Protocol, "protocol", "", "", "set healthcheck protocol[http/tcp]")
	fs.StringVarP(&proxyLBUpdateParam.HostHeader, "host-header", "", "", "set host header of http/https healthcheck request")
	fs.StringVarP(&proxyLBUpdateParam.Path, "path", "", "", "set path of http/https healthcheck request")
	fs.IntVarP(&proxyLBUpdateParam.DelayLoop, "delay-loop", "", 0, "set delay-loop of healthcheck")
	fs.BoolVarP(&proxyLBUpdateParam.StickySession, "sticky-session", "", false, "enable sticky-session")
	fs.StringVarP(&proxyLBUpdateParam.SorryServerIpaddress, "sorry-server-ipaddress", "", "", "set sorry-server ip address")
	fs.IntVarP(&proxyLBUpdateParam.SorryServerPort, "sorry-server-port", "", 0, "set sorry-server ports")
	fs.IntVarP(&proxyLBUpdateParam.Timeout, "timeout", "", 10, "set timeout")
	fs.StringSliceVarP(&proxyLBUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBUpdateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&proxyLBUpdateParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&proxyLBUpdateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &proxyLBUpdateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&proxyLBUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBUpdateFlagOrder(cmd))
	return cmd
}

func proxyLBDeleteCmd() *cobra.Command {
	proxyLBDeleteParam := params.NewDeleteProxyLBParam()
	cmd := &cobra.Command{
		Use:          "delete",
		Aliases:      []string{"rm"},
		Short:        "Delete ProxyLB",
		Long:         `Delete ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBDeleteTargets(ctx, proxyLBDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBDeleteParam.SetId(id)
				go func(p *params.DeleteProxyLBParam) {
					err := funcs.ProxyLBDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBDeleteFlagOrder(cmd))
	return cmd
}

func proxyLBPlanChangeCmd() *cobra.Command {
	proxyLBPlanChangeParam := params.NewPlanChangeProxyLBParam()
	cmd := &cobra.Command{
		Use: "plan-change",

		Short:        "Change ProxyLB plan",
		Long:         `Change ProxyLB plan`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBPlanChangeParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBPlanChangeParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBPlanChangeParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBPlanChangeParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBPlanChangeTargets(ctx, proxyLBPlanChangeParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBPlanChangeParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("plan-change", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBPlanChangeParam.SetId(id)
				go func(p *params.PlanChangeProxyLBParam) {
					err := funcs.ProxyLBPlanChange(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBPlanChangeParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBPlanChangeParam.Plan, "plan", "", 0, "set plan")
	fs.StringSliceVarP(&proxyLBPlanChangeParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBPlanChangeParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBPlanChangeParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBPlanChangeParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBPlanChangeParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBPlanChangeParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBPlanChangeParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBPlanChangeParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBPlanChangeParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBPlanChangeParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBPlanChangeParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBPlanChangeParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBPlanChangeParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBPlanChangeParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBPlanChangeParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBPlanChangeFlagOrder(cmd))
	return cmd
}

func proxyLBBindPortInfoCmd() *cobra.Command {
	proxyLBBindPortInfoParam := params.NewBindPortInfoProxyLBParam()
	cmd := &cobra.Command{
		Use:          "bind-port-info",
		Aliases:      []string{"bind-port-list"},
		Short:        "BindPortInfo ProxyLB",
		Long:         `BindPortInfo ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBBindPortInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBBindPortInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBBindPortInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBBindPortInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBBindPortInfoTargets(ctx, proxyLBBindPortInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBBindPortInfoParam.SetId(id)
				go func(p *params.BindPortInfoProxyLBParam) {
					err := funcs.ProxyLBBindPortInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBBindPortInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBBindPortInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBBindPortInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBBindPortInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBBindPortInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBBindPortInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBBindPortInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBBindPortInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBBindPortInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBBindPortInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBBindPortInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBBindPortInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBBindPortInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBBindPortInfoFlagOrder(cmd))
	return cmd
}

func proxyLBBindPortAddCmd() *cobra.Command {
	proxyLBBindPortAddParam := params.NewBindPortAddProxyLBParam()
	cmd := &cobra.Command{
		Use: "bind-port-add",

		Short:        "BindPortAdd ProxyLB",
		Long:         `BindPortAdd ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBBindPortAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBBindPortAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBBindPortAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBBindPortAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBBindPortAddTargets(ctx, proxyLBBindPortAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBBindPortAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("bind-port-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBBindPortAddParam.SetId(id)
				go func(p *params.BindPortAddProxyLBParam) {
					err := funcs.ProxyLBBindPortAdd(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBBindPortAddParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&proxyLBBindPortAddParam.Mode, "mode", "", "", "set bind mode[http/https/tcp]")
	fs.IntVarP(&proxyLBBindPortAddParam.Port, "port", "", 0, "set port number")
	fs.BoolVarP(&proxyLBBindPortAddParam.RedirectToHttps, "redirect-to-https", "", false, "enable to redirect to https")
	fs.BoolVarP(&proxyLBBindPortAddParam.SupportHttp2, "support-http-2", "", false, "enable http/2")
	fs.StringSliceVarP(&proxyLBBindPortAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBBindPortAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBBindPortAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBBindPortAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBBindPortAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBBindPortAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBBindPortAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBBindPortAddParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBBindPortAddParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBBindPortAddParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBBindPortAddParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortAddParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortAddParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBBindPortAddParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBBindPortAddParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBBindPortAddFlagOrder(cmd))
	return cmd
}

func proxyLBBindPortUpdateCmd() *cobra.Command {
	proxyLBBindPortUpdateParam := params.NewBindPortUpdateProxyLBParam()
	cmd := &cobra.Command{
		Use: "bind-port-update",

		Short:        "BindPortUpdate ProxyLB",
		Long:         `BindPortUpdate ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBBindPortUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBBindPortUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBBindPortUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBBindPortUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBBindPortUpdateTargets(ctx, proxyLBBindPortUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBBindPortUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("bind-port-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBBindPortUpdateParam.SetId(id)
				go func(p *params.BindPortUpdateProxyLBParam) {
					err := funcs.ProxyLBBindPortUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBBindPortUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBBindPortUpdateParam.Index, "index", "", 0, "index of target server")
	fs.StringVarP(&proxyLBBindPortUpdateParam.Mode, "mode", "", "", "set bind mode[http/https/tcp]")
	fs.IntVarP(&proxyLBBindPortUpdateParam.Port, "port", "", 0, "set port number")
	fs.BoolVarP(&proxyLBBindPortUpdateParam.RedirectToHttps, "redirect-to-https", "", false, "enable to redirect to https")
	fs.BoolVarP(&proxyLBBindPortUpdateParam.SupportHttp2, "support-http-2", "", false, "enable http/2")
	fs.StringSliceVarP(&proxyLBBindPortUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBBindPortUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBBindPortUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBBindPortUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBBindPortUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBBindPortUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBBindPortUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBBindPortUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBBindPortUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBBindPortUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBBindPortUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBBindPortUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBBindPortUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBBindPortUpdateFlagOrder(cmd))
	return cmd
}

func proxyLBBindPortDeleteCmd() *cobra.Command {
	proxyLBBindPortDeleteParam := params.NewBindPortDeleteProxyLBParam()
	cmd := &cobra.Command{
		Use: "bind-port-delete",

		Short:        "BindPortDelete ProxyLB",
		Long:         `BindPortDelete ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBBindPortDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBBindPortDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBBindPortDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBBindPortDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBBindPortDeleteTargets(ctx, proxyLBBindPortDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBBindPortDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete bind-port", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBBindPortDeleteParam.SetId(id)
				go func(p *params.BindPortDeleteProxyLBParam) {
					err := funcs.ProxyLBBindPortDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBBindPortDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBBindPortDeleteParam.Index, "index", "", 0, "index of target bind-port")
	fs.StringSliceVarP(&proxyLBBindPortDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBBindPortDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBBindPortDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBBindPortDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBBindPortDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBBindPortDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBBindPortDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBBindPortDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBBindPortDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBBindPortDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBBindPortDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBBindPortDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBBindPortDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBBindPortDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBBindPortDeleteFlagOrder(cmd))
	return cmd
}

func proxyLBResponseHeaderInfoCmd() *cobra.Command {
	proxyLBResponseHeaderInfoParam := params.NewResponseHeaderInfoProxyLBParam()
	cmd := &cobra.Command{
		Use:          "response-header-info",
		Aliases:      []string{"response-header-list"},
		Short:        "ResponseHeaderInfo ProxyLB",
		Long:         `ResponseHeaderInfo ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBResponseHeaderInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBResponseHeaderInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBResponseHeaderInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBResponseHeaderInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBResponseHeaderInfoTargets(ctx, proxyLBResponseHeaderInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBResponseHeaderInfoParam.SetId(id)
				go func(p *params.ResponseHeaderInfoProxyLBParam) {
					err := funcs.ProxyLBResponseHeaderInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBResponseHeaderInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBResponseHeaderInfoParam.PortIndex, "port-index", "", 0, "index of target bind-port")
	fs.StringSliceVarP(&proxyLBResponseHeaderInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBResponseHeaderInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBResponseHeaderInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBResponseHeaderInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBResponseHeaderInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBResponseHeaderInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBResponseHeaderInfoFlagOrder(cmd))
	return cmd
}

func proxyLBResponseHeaderAddCmd() *cobra.Command {
	proxyLBResponseHeaderAddParam := params.NewResponseHeaderAddProxyLBParam()
	cmd := &cobra.Command{
		Use: "response-header-add",

		Short:        "ResponseHeaderAdd ProxyLB",
		Long:         `ResponseHeaderAdd ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBResponseHeaderAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBResponseHeaderAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBResponseHeaderAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBResponseHeaderAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBResponseHeaderAddTargets(ctx, proxyLBResponseHeaderAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBResponseHeaderAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("response-header-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBResponseHeaderAddParam.SetId(id)
				go func(p *params.ResponseHeaderAddProxyLBParam) {
					err := funcs.ProxyLBResponseHeaderAdd(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBResponseHeaderAddParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBResponseHeaderAddParam.PortIndex, "port-index", "", 0, "index of target bind-port")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.Header, "header", "", "", "set Header")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.Value, "value", "", "", "set Value")
	fs.StringSliceVarP(&proxyLBResponseHeaderAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBResponseHeaderAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBResponseHeaderAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBResponseHeaderAddParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBResponseHeaderAddParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBResponseHeaderAddParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBResponseHeaderAddParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBResponseHeaderAddFlagOrder(cmd))
	return cmd
}

func proxyLBResponseHeaderUpdateCmd() *cobra.Command {
	proxyLBResponseHeaderUpdateParam := params.NewResponseHeaderUpdateProxyLBParam()
	cmd := &cobra.Command{
		Use: "response-header-update",

		Short:        "ResponseHeaderUpdate ProxyLB",
		Long:         `ResponseHeaderUpdate ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBResponseHeaderUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBResponseHeaderUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBResponseHeaderUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBResponseHeaderUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBResponseHeaderUpdateTargets(ctx, proxyLBResponseHeaderUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBResponseHeaderUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("response-header-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBResponseHeaderUpdateParam.SetId(id)
				go func(p *params.ResponseHeaderUpdateProxyLBParam) {
					err := funcs.ProxyLBResponseHeaderUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBResponseHeaderUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBResponseHeaderUpdateParam.Index, "index", "", 0, "index of target server")
	fs.IntVarP(&proxyLBResponseHeaderUpdateParam.PortIndex, "port-index", "", 0, "index of target bind-port")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.Header, "header", "", "", "set Header")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.Value, "value", "", "", "set Value")
	fs.StringSliceVarP(&proxyLBResponseHeaderUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBResponseHeaderUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBResponseHeaderUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBResponseHeaderUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBResponseHeaderUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBResponseHeaderUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBResponseHeaderUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBResponseHeaderUpdateFlagOrder(cmd))
	return cmd
}

func proxyLBResponseHeaderDeleteCmd() *cobra.Command {
	proxyLBResponseHeaderDeleteParam := params.NewResponseHeaderDeleteProxyLBParam()
	cmd := &cobra.Command{
		Use: "response-header-delete",

		Short:        "ResponseHeaderDelete ProxyLB",
		Long:         `ResponseHeaderDelete ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBResponseHeaderDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBResponseHeaderDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBResponseHeaderDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBResponseHeaderDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBResponseHeaderDeleteTargets(ctx, proxyLBResponseHeaderDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBResponseHeaderDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete response-header", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBResponseHeaderDeleteParam.SetId(id)
				go func(p *params.ResponseHeaderDeleteProxyLBParam) {
					err := funcs.ProxyLBResponseHeaderDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBResponseHeaderDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBResponseHeaderDeleteParam.Index, "index", "", 0, "index of target bind-port")
	fs.IntVarP(&proxyLBResponseHeaderDeleteParam.PortIndex, "port-index", "", 0, "index of target bind-port")
	fs.StringSliceVarP(&proxyLBResponseHeaderDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBResponseHeaderDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBResponseHeaderDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBResponseHeaderDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBResponseHeaderDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBResponseHeaderDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBResponseHeaderDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBResponseHeaderDeleteFlagOrder(cmd))
	return cmd
}

func proxyLBACMEInfoCmd() *cobra.Command {
	proxyLBACMEInfoParam := params.NewACMEInfoProxyLBParam()
	cmd := &cobra.Command{
		Use: "acme-info",

		Short:        "ACMEInfo ProxyLB",
		Long:         `ACMEInfo ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBACMEInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBACMEInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBACMEInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBACMEInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBACMEInfoTargets(ctx, proxyLBACMEInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBACMEInfoParam.SetId(id)
				go func(p *params.ACMEInfoProxyLBParam) {
					err := funcs.ProxyLBACMEInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBACMEInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBACMEInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBACMEInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBACMEInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBACMEInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBACMEInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBACMEInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBACMEInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBACMEInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBACMEInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBACMEInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBACMEInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBACMEInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBACMEInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBACMEInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBACMEInfoFlagOrder(cmd))
	return cmd
}

func proxyLBACMESettingCmd() *cobra.Command {
	proxyLBACMESettingParam := params.NewACMESettingProxyLBParam()
	cmd := &cobra.Command{
		Use: "acme-setting",

		Short:        "ACMESetting ProxyLB",
		Long:         `ACMESetting ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBACMESettingParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBACMESettingParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBACMESettingParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBACMESettingParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBACMESettingTargets(ctx, proxyLBACMESettingParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBACMESettingParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("acme-setting", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBACMESettingParam.SetId(id)
				go func(p *params.ACMESettingProxyLBParam) {
					err := funcs.ProxyLBACMESetting(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBACMESettingParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&proxyLBACMESettingParam.AcceptTos, "accept-tos", "", false, "the flag of accept Let's Encrypt's terms of services: https://letsencrypt.org/repository/")
	fs.StringVarP(&proxyLBACMESettingParam.CommonName, "common-name", "", "", "set common name")
	fs.BoolVarP(&proxyLBACMESettingParam.Disable, "disable", "", false, "the flag of disable Let's Encrypt")
	fs.StringSliceVarP(&proxyLBACMESettingParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBACMESettingParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBACMESettingParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBACMESettingParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBACMESettingParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBACMESettingParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBACMESettingParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBACMESettingParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBACMESettingParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBACMESettingParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBACMESettingParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBACMESettingParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBACMESettingParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBACMESettingParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBACMESettingParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBACMESettingFlagOrder(cmd))
	return cmd
}

func proxyLBACMERenewCmd() *cobra.Command {
	proxyLBACMERenewParam := params.NewACMERenewProxyLBParam()
	cmd := &cobra.Command{
		Use: "acme-renew",

		Short:        "ACMERenew ProxyLB",
		Long:         `ACMERenew ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBACMERenewParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBACMERenewParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBACMERenewParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBACMERenewParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBACMERenewTargets(ctx, proxyLBACMERenewParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBACMERenewParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("acme-renew", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBACMERenewParam.SetId(id)
				go func(p *params.ACMERenewProxyLBParam) {
					err := funcs.ProxyLBACMERenew(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBACMERenewParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBACMERenewParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBACMERenewParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBACMERenewParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBACMERenewParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBACMERenewParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBACMERenewParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBACMERenewParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &proxyLBACMERenewParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBACMERenewFlagOrder(cmd))
	return cmd
}

func proxyLBServerInfoCmd() *cobra.Command {
	proxyLBServerInfoParam := params.NewServerInfoProxyLBParam()
	cmd := &cobra.Command{
		Use:          "server-info",
		Aliases:      []string{"server-list"},
		Short:        "ServerInfo ProxyLB",
		Long:         `ServerInfo ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBServerInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBServerInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBServerInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBServerInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBServerInfoTargets(ctx, proxyLBServerInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBServerInfoParam.SetId(id)
				go func(p *params.ServerInfoProxyLBParam) {
					err := funcs.ProxyLBServerInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBServerInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBServerInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBServerInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBServerInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBServerInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBServerInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBServerInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBServerInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBServerInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBServerInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBServerInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBServerInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBServerInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBServerInfoFlagOrder(cmd))
	return cmd
}

func proxyLBServerAddCmd() *cobra.Command {
	proxyLBServerAddParam := params.NewServerAddProxyLBParam()
	cmd := &cobra.Command{
		Use: "server-add",

		Short:        "ServerAdd ProxyLB",
		Long:         `ServerAdd ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBServerAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBServerAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBServerAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBServerAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBServerAddTargets(ctx, proxyLBServerAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBServerAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("server-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBServerAddParam.SetId(id)
				go func(p *params.ServerAddProxyLBParam) {
					err := funcs.ProxyLBServerAdd(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBServerAddParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&proxyLBServerAddParam.Ipaddress, "ipaddress", "", "", "set target ipaddress")
	fs.BoolVarP(&proxyLBServerAddParam.Disabled, "disabled", "", false, "set disabled")
	fs.IntVarP(&proxyLBServerAddParam.Port, "port", "", 0, "set server ports")
	fs.StringSliceVarP(&proxyLBServerAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBServerAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBServerAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBServerAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBServerAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBServerAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBServerAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBServerAddParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBServerAddParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBServerAddParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBServerAddParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerAddParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerAddParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBServerAddParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBServerAddParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBServerAddFlagOrder(cmd))
	return cmd
}

func proxyLBServerUpdateCmd() *cobra.Command {
	proxyLBServerUpdateParam := params.NewServerUpdateProxyLBParam()
	cmd := &cobra.Command{
		Use: "server-update",

		Short:        "ServerUpdate ProxyLB",
		Long:         `ServerUpdate ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBServerUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBServerUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBServerUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBServerUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBServerUpdateTargets(ctx, proxyLBServerUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBServerUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("server-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBServerUpdateParam.SetId(id)
				go func(p *params.ServerUpdateProxyLBParam) {
					err := funcs.ProxyLBServerUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBServerUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBServerUpdateParam.Index, "index", "", 0, "index of target server")
	fs.StringVarP(&proxyLBServerUpdateParam.Ipaddress, "ipaddress", "", "", "set target ipaddress")
	fs.BoolVarP(&proxyLBServerUpdateParam.Disabled, "disabled", "", false, "set disabled")
	fs.IntVarP(&proxyLBServerUpdateParam.Port, "port", "", 0, "set server ports")
	fs.StringSliceVarP(&proxyLBServerUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBServerUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBServerUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBServerUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBServerUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBServerUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBServerUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBServerUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBServerUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBServerUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBServerUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBServerUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBServerUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBServerUpdateFlagOrder(cmd))
	return cmd
}

func proxyLBServerDeleteCmd() *cobra.Command {
	proxyLBServerDeleteParam := params.NewServerDeleteProxyLBParam()
	cmd := &cobra.Command{
		Use: "server-delete",

		Short:        "ServerDelete ProxyLB",
		Long:         `ServerDelete ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBServerDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBServerDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBServerDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBServerDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBServerDeleteTargets(ctx, proxyLBServerDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBServerDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete server", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBServerDeleteParam.SetId(id)
				go func(p *params.ServerDeleteProxyLBParam) {
					err := funcs.ProxyLBServerDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBServerDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&proxyLBServerDeleteParam.Index, "index", "", 0, "index of target server")
	fs.StringSliceVarP(&proxyLBServerDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBServerDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBServerDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBServerDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBServerDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBServerDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBServerDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBServerDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBServerDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBServerDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBServerDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBServerDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBServerDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBServerDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBServerDeleteFlagOrder(cmd))
	return cmd
}

func proxyLBCertificateInfoCmd() *cobra.Command {
	proxyLBCertificateInfoParam := params.NewCertificateInfoProxyLBParam()
	cmd := &cobra.Command{
		Use:          "certificate-info",
		Aliases:      []string{"certificate-list", "cert-list", "cert-info"},
		Short:        "CertificateInfo ProxyLB",
		Long:         `CertificateInfo ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBCertificateInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBCertificateInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBCertificateInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBCertificateInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBCertificateInfoTargets(ctx, proxyLBCertificateInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBCertificateInfoParam.SetId(id)
				go func(p *params.CertificateInfoProxyLBParam) {
					err := funcs.ProxyLBCertificateInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBCertificateInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBCertificateInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBCertificateInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBCertificateInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBCertificateInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBCertificateInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBCertificateInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBCertificateInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBCertificateInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBCertificateInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBCertificateInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBCertificateInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBCertificateInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBCertificateInfoFlagOrder(cmd))
	return cmd
}

func proxyLBCertificateAddCmd() *cobra.Command {
	proxyLBCertificateAddParam := params.NewCertificateAddProxyLBParam()
	cmd := &cobra.Command{
		Use:          "certificate-add",
		Aliases:      []string{"cert-add"},
		Short:        "CertificateAdd ProxyLB",
		Long:         `CertificateAdd ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBCertificateAddParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBCertificateAddParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBCertificateAddParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBCertificateAddParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBCertificateAddTargets(ctx, proxyLBCertificateAddParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBCertificateAddParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("certificate-add", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBCertificateAddParam.SetId(id)
				go func(p *params.CertificateAddProxyLBParam) {
					err := funcs.ProxyLBCertificateAdd(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBCertificateAddParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&proxyLBCertificateAddParam.ServerCertificate, "server-certificate", "", "", "")
	fs.StringVarP(&proxyLBCertificateAddParam.IntermediateCertificate, "intermediate-certificate", "", "", "")
	fs.StringVarP(&proxyLBCertificateAddParam.PrivateKey, "private-key", "", "", "")
	fs.StringSliceVarP(&proxyLBCertificateAddParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBCertificateAddParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBCertificateAddParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBCertificateAddParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBCertificateAddParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBCertificateAddParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBCertificateAddParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBCertificateAddParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBCertificateAddParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBCertificateAddParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBCertificateAddParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateAddParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateAddParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBCertificateAddParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBCertificateAddParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBCertificateAddFlagOrder(cmd))
	return cmd
}

func proxyLBCertificateUpdateCmd() *cobra.Command {
	proxyLBCertificateUpdateParam := params.NewCertificateUpdateProxyLBParam()
	cmd := &cobra.Command{
		Use:          "certificate-update",
		Aliases:      []string{"cert-update"},
		Short:        "CertificateUpdate ProxyLB",
		Long:         `CertificateUpdate ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBCertificateUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBCertificateUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBCertificateUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBCertificateUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBCertificateUpdateTargets(ctx, proxyLBCertificateUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBCertificateUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("certificate-update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBCertificateUpdateParam.SetId(id)
				go func(p *params.CertificateUpdateProxyLBParam) {
					err := funcs.ProxyLBCertificateUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBCertificateUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&proxyLBCertificateUpdateParam.ServerCertificate, "server-certificate", "", "", "")
	fs.StringVarP(&proxyLBCertificateUpdateParam.IntermediateCertificate, "intermediate-certificate", "", "", "")
	fs.StringVarP(&proxyLBCertificateUpdateParam.PrivateKey, "private-key", "", "", "")
	fs.StringSliceVarP(&proxyLBCertificateUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBCertificateUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBCertificateUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBCertificateUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBCertificateUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBCertificateUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBCertificateUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBCertificateUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBCertificateUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBCertificateUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBCertificateUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBCertificateUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBCertificateUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBCertificateUpdateFlagOrder(cmd))
	return cmd
}

func proxyLBCertificateDeleteCmd() *cobra.Command {
	proxyLBCertificateDeleteParam := params.NewCertificateDeleteProxyLBParam()
	cmd := &cobra.Command{
		Use:          "certificate-delete",
		Aliases:      []string{"cert-delete"},
		Short:        "CertificateDelete ProxyLB",
		Long:         `CertificateDelete ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBCertificateDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBCertificateDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBCertificateDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBCertificateDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBCertificateDeleteTargets(ctx, proxyLBCertificateDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !proxyLBCertificateDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete certificate", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBCertificateDeleteParam.SetId(id)
				go func(p *params.CertificateDeleteProxyLBParam) {
					err := funcs.ProxyLBCertificateDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBCertificateDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&proxyLBCertificateDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&proxyLBCertificateDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&proxyLBCertificateDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBCertificateDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBCertificateDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBCertificateDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBCertificateDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBCertificateDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBCertificateDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBCertificateDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBCertificateDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBCertificateDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBCertificateDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBCertificateDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBCertificateDeleteFlagOrder(cmd))
	return cmd
}

func proxyLBMonitorCmd() *cobra.Command {
	proxyLBMonitorParam := params.NewMonitorProxyLBParam()
	cmd := &cobra.Command{
		Use: "monitor",

		Short:        "Monitor ProxyLB",
		Long:         `Monitor ProxyLB`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return proxyLBMonitorParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, proxyLBMonitorParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if proxyLBMonitorParam.GenerateSkeleton {
				return generateSkeleton(ctx, proxyLBMonitorParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findProxyLBMonitorTargets(ctx, proxyLBMonitorParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				proxyLBMonitorParam.SetId(id)
				go func(p *params.MonitorProxyLBParam) {
					err := funcs.ProxyLBMonitor(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(proxyLBMonitorParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&proxyLBMonitorParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&proxyLBMonitorParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&proxyLBMonitorParam.KeyFormat, "key-format", "", "sakuracloud.proxylb.{{.ID}}", "set monitoring value key-format")
	fs.StringSliceVarP(&proxyLBMonitorParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&proxyLBMonitorParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&proxyLBMonitorParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&proxyLBMonitorParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&proxyLBMonitorParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&proxyLBMonitorParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&proxyLBMonitorParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&proxyLBMonitorParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&proxyLBMonitorParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&proxyLBMonitorParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&proxyLBMonitorParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&proxyLBMonitorParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&proxyLBMonitorParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &proxyLBMonitorParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, proxyLBMonitorFlagOrder(cmd))
	return cmd
}
