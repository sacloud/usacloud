// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-v2-commands'; DO NOT EDIT

package commands

import (
	"errors"
	"sync"

	"github.com/sacloud/libsacloud/sacloud"
	"github.com/sacloud/usacloud/cmdv2/params"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/pkg/utils"
	"github.com/spf13/cobra"
)

// databaseCmd represents the command to manage SAKURA Cloud Database
func databaseCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "database",
		Short: "A manage commands of Database",
		Long:  `A manage commands of Database`,
		Run: func(cmd *cobra.Command, args []string) {
			cmd.HelpFunc()(cmd, args)
		},
	}
}

func databaseListCmd() *cobra.Command {
	databaseListParam := params.NewListDatabaseParam()
	cmd := &cobra.Command{
		Use:          "list",
		Aliases:      []string{"ls", "find", "selector"},
		Short:        "List Database",
		Long:         `List Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseListParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseListParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseListParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseListParam)
			}

			return funcs.DatabaseList(ctx, databaseListParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseListParam.Name, "name", "", []string{}, "set filter by name(s)")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &databaseListParam.Id), "id", "", "set filter by id(s)")
	fs.StringSliceVarP(&databaseListParam.Tags, "tags", "", []string{}, "set filter by tags(AND)")
	fs.IntVarP(&databaseListParam.From, "from", "", 0, "set offset")
	fs.IntVarP(&databaseListParam.Max, "max", "", 0, "set limit")
	fs.StringSliceVarP(&databaseListParam.Sort, "sort", "", []string{}, "set field(s) for sort")
	fs.StringVarP(&databaseListParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseListParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseListParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseListParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseListParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseListParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseListParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseListParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseListParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseListParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseListParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseListParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	buildFlagsUsage(cmd, databaseListFlagOrder(cmd))
	return cmd
}

func databaseCreateCmd() *cobra.Command {
	databaseCreateParam := params.NewCreateDatabaseParam()
	cmd := &cobra.Command{
		Use: "create",

		Short:        "Create Database",
		Long:         `Create Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseCreateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseCreateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseCreateParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseCreateParam)
			}

			// confirm
			if !databaseCreateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("create", ctx.IO().In(), ctx.IO().Out())
				if err != nil || !result {
					return err
				}
			}

			return funcs.DatabaseCreate(ctx, databaseCreateParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &databaseCreateParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.IntVarP(&databaseCreateParam.Plan, "plan", "", 10, "set plan[10/30/90/240/500/1000]")
	fs.StringVarP(&databaseCreateParam.Database, "database", "", "", "set database type[postgresql/mariadb]")
	fs.StringVarP(&databaseCreateParam.Username, "username", "", "", "set database default user name")
	fs.StringVarP(&databaseCreateParam.Password, "password", "", "", "set database default user password")
	fs.StringVarP(&databaseCreateParam.ReplicaUserPassword, "replica-user-password", "", "", "set database replica user password")
	fs.StringSliceVarP(&databaseCreateParam.SourceNetworks, "source-networks", "", []string{}, "set network of allow connection")
	fs.BoolVarP(&databaseCreateParam.EnableWebUi, "enable-web-ui", "", false, "enable web-ui")
	fs.BoolVarP(&databaseCreateParam.EnableBackup, "enable-backup", "", false, "enable backup")
	fs.StringSliceVarP(&databaseCreateParam.BackupWeekdays, "backup-weekdays", "", []string{"all"}, "set backup target weekdays[all or mon/tue/wed/thu/fri/sat/sun]")
	fs.StringVarP(&databaseCreateParam.BackupTime, "backup-time", "", "", "set backup start time")
	fs.IntVarP(&databaseCreateParam.Port, "port", "", 0, "set database port")
	fs.StringVarP(&databaseCreateParam.Ipaddress1, "ipaddress-1", "", "", "set ipaddress(#1)")
	fs.IntVarP(&databaseCreateParam.NwMaskLen, "nw-mask-len", "", 0, "set network mask length")
	fs.StringVarP(&databaseCreateParam.DefaultRoute, "default-route", "", "", "set default route")
	fs.StringVarP(&databaseCreateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&databaseCreateParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&databaseCreateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &databaseCreateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&databaseCreateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseCreateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseCreateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseCreateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseCreateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseCreateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseCreateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseCreateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseCreateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseCreateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseCreateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseCreateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseCreateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	buildFlagsUsage(cmd, databaseCreateFlagOrder(cmd))
	return cmd
}

func databaseReadCmd() *cobra.Command {
	databaseReadParam := params.NewReadDatabaseParam()
	cmd := &cobra.Command{
		Use: "read",

		Short:        "Read Database",
		Long:         `Read Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseReadParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseReadParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseReadParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseReadParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseReadTargets(ctx, databaseReadParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseReadParam.SetId(id)
				go func(p *params.ReadDatabaseParam) {
					err := funcs.DatabaseRead(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseReadParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseReadParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseReadParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseReadParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseReadParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseReadParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseReadParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseReadParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseReadParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseReadParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseReadParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseReadParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseReadParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseReadParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseReadParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseReadFlagOrder(cmd))
	return cmd
}

func databaseUpdateCmd() *cobra.Command {
	databaseUpdateParam := params.NewUpdateDatabaseParam()
	cmd := &cobra.Command{
		Use: "update",

		Short:        "Update Database",
		Long:         `Update Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseUpdateTargets(ctx, databaseUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseUpdateParam.SetId(id)
				go func(p *params.UpdateDatabaseParam) {
					err := funcs.DatabaseUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseUpdateParam.Password, "password", "", "", "set database default user password")
	fs.StringVarP(&databaseUpdateParam.ReplicaUserPassword, "replica-user-password", "", "", "set database replica user password")
	fs.BoolVarP(&databaseUpdateParam.EnableReplication, "enable-replication", "", false, "enable replication")
	fs.IntVarP(&databaseUpdateParam.Port, "port", "", 0, "set database port")
	fs.StringSliceVarP(&databaseUpdateParam.SourceNetworks, "source-networks", "", []string{}, "set network of allow connection")
	fs.BoolVarP(&databaseUpdateParam.EnableWebUi, "enable-web-ui", "", false, "enable web-ui")
	fs.BoolVarP(&databaseUpdateParam.EnableBackup, "enable-backup", "", false, "enable backup")
	fs.StringSliceVarP(&databaseUpdateParam.BackupWeekdays, "backup-weekdays", "", []string{"all"}, "set backup target weekdays[all or mon/tue/wed/thu/fri/sat/sun]")
	fs.StringVarP(&databaseUpdateParam.BackupTime, "backup-time", "", "", "set backup start time")
	fs.StringSliceVarP(&databaseUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseUpdateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&databaseUpdateParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&databaseUpdateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &databaseUpdateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&databaseUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseUpdateFlagOrder(cmd))
	return cmd
}

func databaseDeleteCmd() *cobra.Command {
	databaseDeleteParam := params.NewDeleteDatabaseParam()
	cmd := &cobra.Command{
		Use:          "delete",
		Aliases:      []string{"rm"},
		Short:        "Delete Database",
		Long:         `Delete Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseDeleteTargets(ctx, databaseDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseDeleteParam.SetId(id)
				go func(p *params.DeleteDatabaseParam) {
					err := funcs.DatabaseDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&databaseDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.BoolVarP(&databaseDeleteParam.Force, "force", "f", false, "forced-shutdown flag if database is running")
	fs.VarP(newIDValue(0, &databaseDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseDeleteFlagOrder(cmd))
	return cmd
}

func databaseBootCmd() *cobra.Command {
	databaseBootParam := params.NewBootDatabaseParam()
	cmd := &cobra.Command{
		Use:          "boot",
		Aliases:      []string{"power-on"},
		Short:        "Boot Database",
		Long:         `Boot Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBootParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBootParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBootParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBootParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBootTargets(ctx, databaseBootParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseBootParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("boot", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBootParam.SetId(id)
				go func(p *params.BootDatabaseParam) {
					err := funcs.DatabaseBoot(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBootParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseBootParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&databaseBootParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseBootParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBootParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBootParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBootParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBootParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseBootParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBootFlagOrder(cmd))
	return cmd
}

func databaseShutdownCmd() *cobra.Command {
	databaseShutdownParam := params.NewShutdownDatabaseParam()
	cmd := &cobra.Command{
		Use:          "shutdown",
		Aliases:      []string{"power-off"},
		Short:        "Shutdown Database",
		Long:         `Shutdown Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseShutdownParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseShutdownParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseShutdownParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseShutdownParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseShutdownTargets(ctx, databaseShutdownParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseShutdownParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("shutdown", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseShutdownParam.SetId(id)
				go func(p *params.ShutdownDatabaseParam) {
					err := funcs.DatabaseShutdown(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseShutdownParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseShutdownParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&databaseShutdownParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseShutdownParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseShutdownParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseShutdownParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseShutdownParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseShutdownParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseShutdownParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseShutdownFlagOrder(cmd))
	return cmd
}

func databaseShutdownForceCmd() *cobra.Command {
	databaseShutdownForceParam := params.NewShutdownForceDatabaseParam()
	cmd := &cobra.Command{
		Use:          "shutdown-force",
		Aliases:      []string{"stop"},
		Short:        "ShutdownForce Database",
		Long:         `ShutdownForce Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseShutdownForceParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseShutdownForceParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseShutdownForceParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseShutdownForceParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseShutdownForceTargets(ctx, databaseShutdownForceParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseShutdownForceParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("shutdown-force", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseShutdownForceParam.SetId(id)
				go func(p *params.ShutdownForceDatabaseParam) {
					err := funcs.DatabaseShutdownForce(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseShutdownForceParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseShutdownForceParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&databaseShutdownForceParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseShutdownForceParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseShutdownForceParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseShutdownForceParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseShutdownForceParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseShutdownForceParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseShutdownForceParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseShutdownForceFlagOrder(cmd))
	return cmd
}

func databaseResetCmd() *cobra.Command {
	databaseResetParam := params.NewResetDatabaseParam()
	cmd := &cobra.Command{
		Use: "reset",

		Short:        "Reset Database",
		Long:         `Reset Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseResetParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseResetParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseResetParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseResetParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseResetTargets(ctx, databaseResetParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseResetParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("reset", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseResetParam.SetId(id)
				go func(p *params.ResetDatabaseParam) {
					err := funcs.DatabaseReset(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseResetParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseResetParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&databaseResetParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseResetParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseResetParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseResetParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseResetParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseResetParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseResetParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseResetFlagOrder(cmd))
	return cmd
}

func databaseWaitForBootCmd() *cobra.Command {
	databaseWaitForBootParam := params.NewWaitForBootDatabaseParam()
	cmd := &cobra.Command{
		Use: "wait-for-boot",

		Short:        "Wait until boot is completed",
		Long:         `Wait until boot is completed`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseWaitForBootParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseWaitForBootParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseWaitForBootParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseWaitForBootParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseWaitForBootTargets(ctx, databaseWaitForBootParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseWaitForBootParam.SetId(id)
				go func(p *params.WaitForBootDatabaseParam) {
					err := funcs.DatabaseWaitForBoot(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseWaitForBootParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseWaitForBootParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseWaitForBootParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseWaitForBootParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseWaitForBootParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseWaitForBootParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseWaitForBootParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseWaitForBootParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseWaitForBootFlagOrder(cmd))
	return cmd
}

func databaseWaitForDownCmd() *cobra.Command {
	databaseWaitForDownParam := params.NewWaitForDownDatabaseParam()
	cmd := &cobra.Command{
		Use: "wait-for-down",

		Short:        "Wait until shutdown is completed",
		Long:         `Wait until shutdown is completed`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseWaitForDownParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseWaitForDownParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseWaitForDownParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseWaitForDownParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseWaitForDownTargets(ctx, databaseWaitForDownParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseWaitForDownParam.SetId(id)
				go func(p *params.WaitForDownDatabaseParam) {
					err := funcs.DatabaseWaitForDown(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseWaitForDownParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseWaitForDownParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseWaitForDownParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseWaitForDownParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseWaitForDownParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseWaitForDownParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseWaitForDownParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseWaitForDownParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseWaitForDownFlagOrder(cmd))
	return cmd
}

func databaseBackupInfoCmd() *cobra.Command {
	databaseBackupInfoParam := params.NewBackupInfoDatabaseParam()
	cmd := &cobra.Command{
		Use:          "backup-info",
		Aliases:      []string{"backups", "backup-list"},
		Short:        "Show information of backup",
		Long:         `Show information of backup`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBackupInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBackupInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBackupInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBackupInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBackupInfoTargets(ctx, databaseBackupInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBackupInfoParam.SetId(id)
				go func(p *params.BackupInfoDatabaseParam) {
					err := funcs.DatabaseBackupInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBackupInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&databaseBackupInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseBackupInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBackupInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBackupInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBackupInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBackupInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseBackupInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseBackupInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseBackupInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseBackupInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseBackupInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseBackupInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBackupInfoFlagOrder(cmd))
	return cmd
}

func databaseBackupCreateCmd() *cobra.Command {
	databaseBackupCreateParam := params.NewBackupCreateDatabaseParam()
	cmd := &cobra.Command{
		Use: "backup-create",

		Short:        "Make new database backup",
		Long:         `Make new database backup`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBackupCreateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBackupCreateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBackupCreateParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBackupCreateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBackupCreateTargets(ctx, databaseBackupCreateParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseBackupCreateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("backup-create", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBackupCreateParam.SetId(id)
				go func(p *params.BackupCreateDatabaseParam) {
					err := funcs.DatabaseBackupCreate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBackupCreateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&databaseBackupCreateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseBackupCreateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBackupCreateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBackupCreateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBackupCreateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBackupCreateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseBackupCreateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseBackupCreateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseBackupCreateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseBackupCreateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupCreateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupCreateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseBackupCreateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseBackupCreateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBackupCreateFlagOrder(cmd))
	return cmd
}

func databaseBackupRestoreCmd() *cobra.Command {
	databaseBackupRestoreParam := params.NewBackupRestoreDatabaseParam()
	cmd := &cobra.Command{
		Use: "backup-restore",

		Short:        "Restore database from backup",
		Long:         `Restore database from backup`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBackupRestoreParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBackupRestoreParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBackupRestoreParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBackupRestoreParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBackupRestoreTargets(ctx, databaseBackupRestoreParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseBackupRestoreParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("backup-restore", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBackupRestoreParam.SetId(id)
				go func(p *params.BackupRestoreDatabaseParam) {
					err := funcs.DatabaseBackupRestore(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBackupRestoreParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&databaseBackupRestoreParam.Index, "index", "", 0, "index of target backup")
	fs.BoolVarP(&databaseBackupRestoreParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseBackupRestoreParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBackupRestoreParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBackupRestoreParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBackupRestoreParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBackupRestoreParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseBackupRestoreParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseBackupRestoreParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseBackupRestoreParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseBackupRestoreParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupRestoreParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupRestoreParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseBackupRestoreParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseBackupRestoreParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBackupRestoreFlagOrder(cmd))
	return cmd
}

func databaseBackupLockCmd() *cobra.Command {
	databaseBackupLockParam := params.NewBackupLockDatabaseParam()
	cmd := &cobra.Command{
		Use: "backup-lock",

		Short:        "Lock backup",
		Long:         `Lock backup`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBackupLockParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBackupLockParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBackupLockParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBackupLockParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBackupLockTargets(ctx, databaseBackupLockParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseBackupLockParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("backup-lock", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBackupLockParam.SetId(id)
				go func(p *params.BackupLockDatabaseParam) {
					err := funcs.DatabaseBackupLock(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBackupLockParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&databaseBackupLockParam.Index, "index", "", 0, "index of target backup")
	fs.BoolVarP(&databaseBackupLockParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseBackupLockParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBackupLockParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBackupLockParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBackupLockParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBackupLockParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseBackupLockParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseBackupLockParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseBackupLockParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseBackupLockParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupLockParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupLockParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseBackupLockParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseBackupLockParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBackupLockFlagOrder(cmd))
	return cmd
}

func databaseBackupUnlockCmd() *cobra.Command {
	databaseBackupUnlockParam := params.NewBackupUnlockDatabaseParam()
	cmd := &cobra.Command{
		Use: "backup-unlock",

		Short:        "Unlock backup",
		Long:         `Unlock backup`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBackupUnlockParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBackupUnlockParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBackupUnlockParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBackupUnlockParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBackupUnlockTargets(ctx, databaseBackupUnlockParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseBackupUnlockParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("backup-unlock", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBackupUnlockParam.SetId(id)
				go func(p *params.BackupUnlockDatabaseParam) {
					err := funcs.DatabaseBackupUnlock(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBackupUnlockParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&databaseBackupUnlockParam.Index, "index", "", 0, "index of target backup")
	fs.BoolVarP(&databaseBackupUnlockParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseBackupUnlockParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBackupUnlockParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBackupUnlockParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBackupUnlockParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBackupUnlockParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseBackupUnlockParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseBackupUnlockParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseBackupUnlockParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseBackupUnlockParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupUnlockParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupUnlockParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseBackupUnlockParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseBackupUnlockParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBackupUnlockFlagOrder(cmd))
	return cmd
}

func databaseBackupRemoveCmd() *cobra.Command {
	databaseBackupRemoveParam := params.NewBackupRemoveDatabaseParam()
	cmd := &cobra.Command{
		Use: "backup-remove",

		Short:        "Remove backup",
		Long:         `Remove backup`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseBackupRemoveParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseBackupRemoveParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseBackupRemoveParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseBackupRemoveParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseBackupRemoveTargets(ctx, databaseBackupRemoveParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseBackupRemoveParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("backup-remove", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseBackupRemoveParam.SetId(id)
				go func(p *params.BackupRemoveDatabaseParam) {
					err := funcs.DatabaseBackupRemove(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseBackupRemoveParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&databaseBackupRemoveParam.Index, "index", "", 0, "index of target backup")
	fs.BoolVarP(&databaseBackupRemoveParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseBackupRemoveParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseBackupRemoveParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseBackupRemoveParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseBackupRemoveParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseBackupRemoveParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseBackupRemoveParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseBackupRemoveParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseBackupRemoveParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseBackupRemoveParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupRemoveParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseBackupRemoveParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseBackupRemoveParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseBackupRemoveParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseBackupRemoveFlagOrder(cmd))
	return cmd
}

func databaseCloneCmd() *cobra.Command {
	databaseCloneParam := params.NewCloneDatabaseParam()
	cmd := &cobra.Command{
		Use: "clone",

		Short:        "Create clone instance",
		Long:         `Create clone instance`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseCloneParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseCloneParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseCloneParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseCloneParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseCloneTargets(ctx, databaseCloneParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseCloneParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("clone", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseCloneParam.SetId(id)
				go func(p *params.CloneDatabaseParam) {
					err := funcs.DatabaseClone(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseCloneParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&databaseCloneParam.Port, "port", "", 0, "set database port")
	fs.VarP(newIDValue(0, &databaseCloneParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.StringVarP(&databaseCloneParam.Ipaddress1, "ipaddress-1", "", "", "set ipaddress(#1)")
	fs.IntVarP(&databaseCloneParam.Plan, "plan", "", 10, "set plan[10/30/90/240/500/1000]")
	fs.IntVarP(&databaseCloneParam.NwMaskLen, "nw-mask-len", "", 0, "set network mask length")
	fs.StringVarP(&databaseCloneParam.DefaultRoute, "default-route", "", "", "set default route")
	fs.StringVarP(&databaseCloneParam.ReplicaUserPassword, "replica-user-password", "", "", "set database replica user password")
	fs.StringSliceVarP(&databaseCloneParam.SourceNetworks, "source-networks", "", []string{}, "set network of allow connection")
	fs.BoolVarP(&databaseCloneParam.EnableWebUi, "enable-web-ui", "", false, "enable web-ui")
	fs.BoolVarP(&databaseCloneParam.EnableBackup, "enable-backup", "", false, "enable backup")
	fs.StringSliceVarP(&databaseCloneParam.BackupWeekdays, "backup-weekdays", "", []string{"all"}, "set backup target weekdays[all or mon/tue/wed/thu/fri/sat/sun]")
	fs.StringVarP(&databaseCloneParam.BackupTime, "backup-time", "", "", "set backup start time")
	fs.StringVarP(&databaseCloneParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&databaseCloneParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&databaseCloneParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &databaseCloneParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&databaseCloneParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseCloneParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseCloneParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseCloneParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseCloneParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseCloneParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseCloneParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseCloneParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseCloneParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseCloneParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseCloneParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseCloneParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseCloneParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseCloneParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseCloneFlagOrder(cmd))
	return cmd
}

func databaseReplicaCreateCmd() *cobra.Command {
	databaseReplicaCreateParam := params.NewReplicaCreateDatabaseParam()
	cmd := &cobra.Command{
		Use: "replica-create",

		Short:        "Create replication slave instance",
		Long:         `Create replication slave instance`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseReplicaCreateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseReplicaCreateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseReplicaCreateParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseReplicaCreateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseReplicaCreateTargets(ctx, databaseReplicaCreateParam)
			if err != nil {
				return err
			}

			// confirm
			if !databaseReplicaCreateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("replica-create", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseReplicaCreateParam.SetId(id)
				go func(p *params.ReplicaCreateDatabaseParam) {
					err := funcs.DatabaseReplicaCreate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseReplicaCreateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &databaseReplicaCreateParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.StringVarP(&databaseReplicaCreateParam.Ipaddress1, "ipaddress-1", "", "", "set ipaddress(#1)")
	fs.IntVarP(&databaseReplicaCreateParam.NwMaskLen, "nw-mask-len", "", 0, "set network mask length")
	fs.StringVarP(&databaseReplicaCreateParam.DefaultRoute, "default-route", "", "", "set default route")
	fs.StringVarP(&databaseReplicaCreateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&databaseReplicaCreateParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&databaseReplicaCreateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &databaseReplicaCreateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&databaseReplicaCreateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&databaseReplicaCreateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseReplicaCreateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseReplicaCreateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseReplicaCreateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseReplicaCreateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseReplicaCreateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseReplicaCreateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseReplicaCreateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseReplicaCreateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseReplicaCreateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseReplicaCreateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseReplicaCreateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseReplicaCreateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseReplicaCreateFlagOrder(cmd))
	return cmd
}

func databaseMonitorCPUCmd() *cobra.Command {
	databaseMonitorCPUParam := params.NewMonitorCPUDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-cpu",

		Short:        "Collect CPU monitor values",
		Long:         `Collect CPU monitor values`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorCPUParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorCPUParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorCPUParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorCPUParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorCPUTargets(ctx, databaseMonitorCPUParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorCPUParam.SetId(id)
				go func(p *params.MonitorCPUDatabaseParam) {
					err := funcs.DatabaseMonitorCPU(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorCPUParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorCPUParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorCPUParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorCPUParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.cpu", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorCPUParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorCPUParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorCPUParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorCPUParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorCPUParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorCPUParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorCPUParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorCPUParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorCPUParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorCPUParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorCPUParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorCPUParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorCPUParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorCPUParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorCPUFlagOrder(cmd))
	return cmd
}

func databaseMonitorMemoryCmd() *cobra.Command {
	databaseMonitorMemoryParam := params.NewMonitorMemoryDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-memory",

		Short:        "Collect memory monitor values",
		Long:         `Collect memory monitor values`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorMemoryParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorMemoryParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorMemoryParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorMemoryParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorMemoryTargets(ctx, databaseMonitorMemoryParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorMemoryParam.SetId(id)
				go func(p *params.MonitorMemoryDatabaseParam) {
					err := funcs.DatabaseMonitorMemory(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorMemoryParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorMemoryParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorMemoryParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorMemoryParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.memory", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorMemoryParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorMemoryParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorMemoryParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorMemoryParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorMemoryParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorMemoryParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorMemoryParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorMemoryParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorMemoryParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorMemoryParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorMemoryParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorMemoryParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorMemoryParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorMemoryParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorMemoryFlagOrder(cmd))
	return cmd
}

func databaseMonitorNicCmd() *cobra.Command {
	databaseMonitorNicParam := params.NewMonitorNicDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-nic",

		Short:        "Collect NIC(s) monitor values",
		Long:         `Collect NIC(s) monitor values`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorNicParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorNicParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorNicParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorNicParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorNicTargets(ctx, databaseMonitorNicParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorNicParam.SetId(id)
				go func(p *params.MonitorNicDatabaseParam) {
					err := funcs.DatabaseMonitorNic(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorNicParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorNicParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorNicParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorNicParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.nic", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorNicParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorNicParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorNicParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorNicParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorNicParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorNicParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorNicParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorNicParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorNicParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorNicParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorNicParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorNicParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorNicParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorNicParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorNicFlagOrder(cmd))
	return cmd
}

func databaseMonitorSystemDiskCmd() *cobra.Command {
	databaseMonitorSystemDiskParam := params.NewMonitorSystemDiskDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-system-disk",

		Short:        "Collect system-disk monitor values(IO)",
		Long:         `Collect system-disk monitor values(IO)`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorSystemDiskParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorSystemDiskParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorSystemDiskParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorSystemDiskParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorSystemDiskTargets(ctx, databaseMonitorSystemDiskParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorSystemDiskParam.SetId(id)
				go func(p *params.MonitorSystemDiskDatabaseParam) {
					err := funcs.DatabaseMonitorSystemDisk(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorSystemDiskParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorSystemDiskParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorSystemDiskParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorSystemDiskParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.disk1", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorSystemDiskParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorSystemDiskParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorSystemDiskParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorSystemDiskParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorSystemDiskParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorSystemDiskParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorSystemDiskParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorSystemDiskParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorSystemDiskParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorSystemDiskParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorSystemDiskParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorSystemDiskParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorSystemDiskParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorSystemDiskParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorSystemDiskFlagOrder(cmd))
	return cmd
}

func databaseMonitorBackupDiskCmd() *cobra.Command {
	databaseMonitorBackupDiskParam := params.NewMonitorBackupDiskDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-backup-disk",

		Short:        "Collect backup-disk monitor values(IO)",
		Long:         `Collect backup-disk monitor values(IO)`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorBackupDiskParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorBackupDiskParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorBackupDiskParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorBackupDiskParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorBackupDiskTargets(ctx, databaseMonitorBackupDiskParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorBackupDiskParam.SetId(id)
				go func(p *params.MonitorBackupDiskDatabaseParam) {
					err := funcs.DatabaseMonitorBackupDisk(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorBackupDiskParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorBackupDiskParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorBackupDiskParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorBackupDiskParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.disk2", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorBackupDiskParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorBackupDiskParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorBackupDiskParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorBackupDiskParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorBackupDiskParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorBackupDiskParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorBackupDiskParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorBackupDiskParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorBackupDiskParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorBackupDiskParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorBackupDiskParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorBackupDiskParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorBackupDiskParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorBackupDiskParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorBackupDiskFlagOrder(cmd))
	return cmd
}

func databaseMonitorSystemDiskSizeCmd() *cobra.Command {
	databaseMonitorSystemDiskSizeParam := params.NewMonitorSystemDiskSizeDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-system-disk-size",

		Short:        "Collect system-disk monitor values(usage)",
		Long:         `Collect system-disk monitor values(usage)`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorSystemDiskSizeParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorSystemDiskSizeParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorSystemDiskSizeParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorSystemDiskSizeParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorSystemDiskSizeTargets(ctx, databaseMonitorSystemDiskSizeParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorSystemDiskSizeParam.SetId(id)
				go func(p *params.MonitorSystemDiskSizeDatabaseParam) {
					err := funcs.DatabaseMonitorSystemDiskSize(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorSystemDiskSizeParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.disk1", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorSystemDiskSizeParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorSystemDiskSizeParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorSystemDiskSizeParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorSystemDiskSizeParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorSystemDiskSizeParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorSystemDiskSizeParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorSystemDiskSizeFlagOrder(cmd))
	return cmd
}

func databaseMonitorBackupDiskSizeCmd() *cobra.Command {
	databaseMonitorBackupDiskSizeParam := params.NewMonitorBackupDiskSizeDatabaseParam()
	cmd := &cobra.Command{
		Use: "monitor-backup-disk-size",

		Short:        "Collect backup-disk monitor values(usage)",
		Long:         `Collect backup-disk monitor values(usage)`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseMonitorBackupDiskSizeParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseMonitorBackupDiskSizeParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseMonitorBackupDiskSizeParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseMonitorBackupDiskSizeParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseMonitorBackupDiskSizeTargets(ctx, databaseMonitorBackupDiskSizeParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseMonitorBackupDiskSizeParam.SetId(id)
				go func(p *params.MonitorBackupDiskSizeDatabaseParam) {
					err := funcs.DatabaseMonitorBackupDiskSize(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseMonitorBackupDiskSizeParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.KeyFormat, "key-format", "", "sakuracloud.database.{{.ID}}.disk2", "set monitoring value key-format")
	fs.StringSliceVarP(&databaseMonitorBackupDiskSizeParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseMonitorBackupDiskSizeParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&databaseMonitorBackupDiskSizeParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&databaseMonitorBackupDiskSizeParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&databaseMonitorBackupDiskSizeParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &databaseMonitorBackupDiskSizeParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseMonitorBackupDiskSizeFlagOrder(cmd))
	return cmd
}

func databaseLogsCmd() *cobra.Command {
	databaseLogsParam := params.NewLogsDatabaseParam()
	cmd := &cobra.Command{
		Use: "logs",

		Short:        "Logs Database",
		Long:         `Logs Database`,
		SilenceUsage: true,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return databaseLogsParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, databaseLogsParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if databaseLogsParam.GenerateSkeleton {
				return generateSkeleton(ctx, databaseLogsParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findDatabaseLogsTargets(ctx, databaseLogsParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				databaseLogsParam.SetId(id)
				go func(p *params.LogsDatabaseParam) {
					err := funcs.DatabaseLogs(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(databaseLogsParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&databaseLogsParam.LogName, "log-name", "", "all", "set target logfile name")
	fs.BoolVarP(&databaseLogsParam.Follow, "follow", "f", false, "follow log output")
	fs.VarP(newIDValue(0, &databaseLogsParam.RefreshInterval), "refresh-interval", "", "log refresh interval second")
	fs.BoolVarP(&databaseLogsParam.ListLogNames, "list-log-names", "", false, "show log-name list")
	fs.StringSliceVarP(&databaseLogsParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&databaseLogsParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&databaseLogsParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&databaseLogsParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&databaseLogsParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&databaseLogsParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &databaseLogsParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, databaseLogsFlagOrder(cmd))
	return cmd
}
