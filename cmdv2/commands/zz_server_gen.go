// Copyright 2017-2020 The Usacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by 'github.com/sacloud/usacloud/tools/gen-cli-v2-commands'; DO NOT EDIT

package commands

import (
	"errors"
	"sync"

	"github.com/sacloud/libsacloud/sacloud"
	"github.com/sacloud/usacloud/cmdv2/params"
	"github.com/sacloud/usacloud/command"
	"github.com/sacloud/usacloud/command/funcs"
	"github.com/sacloud/usacloud/pkg/utils"
	"github.com/spf13/cobra"
)

// serverCmd represents the command to manage SAKURA Cloud Server
func serverCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "server",
		Short: "A manage commands of Server",
		Long:  `A manage commands of Server`,
		Run: func(cmd *cobra.Command, args []string) {
			cmd.HelpFunc()(cmd, args)
		},
	}
}

func serverListCmd() *cobra.Command {
	serverListParam := params.NewListServerParam()
	cmd := &cobra.Command{
		Use:     "list",
		Aliases: []string{"ls", "find", "selector"},
		Short:   "List Server",
		Long:    `List Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverListParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverListParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverListParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverListParam)
			}

			return funcs.ServerList(ctx, serverListParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverListParam.Name, "name", "", []string{}, "set filter by name(s)")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &serverListParam.Id), "id", "", "set filter by id(s)")
	fs.StringSliceVarP(&serverListParam.Tags, "tags", "", []string{}, "set filter by tags(AND)")
	fs.IntVarP(&serverListParam.From, "from", "", 0, "set offset")
	fs.IntVarP(&serverListParam.Max, "max", "", 0, "set limit")
	fs.StringSliceVarP(&serverListParam.Sort, "sort", "", []string{}, "set field(s) for sort")
	fs.StringVarP(&serverListParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverListParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverListParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverListParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverListParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverListParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverListParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverListParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverListParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverListParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverListParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverListParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	buildFlagsUsage(cmd, serverListFlagOrder(cmd))
	return cmd
}

func serverBuildCmd() *cobra.Command {
	serverBuildParam := params.NewBuildServerParam()
	cmd := &cobra.Command{
		Use: "build",

		Short: "Build Server",
		Long:  `Build Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverBuildParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverBuildParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverBuildParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverBuildParam)
			}

			// confirm
			if !serverBuildParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("build", ctx.IO().In(), ctx.IO().Out())
				if err != nil || !result {
					return err
				}
			}

			return funcs.ServerBuild(ctx, serverBuildParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&serverBuildParam.Core, "core", "", 1, "set CPU core count")
	fs.IntVarP(&serverBuildParam.Memory, "memory", "", 1, "set memory size(GB)")
	fs.StringVarP(&serverBuildParam.Commitment, "commitment", "", "standard", "set plan of core assignment")
	fs.VarP(newIDValue(0, &serverBuildParam.PrivateHostId), "private-host-id", "", "set private-host-id")
	fs.StringVarP(&serverBuildParam.DiskMode, "disk-mode", "", "create", "disk create mode[create/connect/diskless]")
	fs.StringVarP(&serverBuildParam.OsType, "os-type", "", "", "set source OS type")
	fs.StringVarP(&serverBuildParam.DiskPlan, "disk-plan", "", "ssd", "set disk plan('hdd' or 'ssd')")
	fs.StringVarP(&serverBuildParam.DiskConnection, "disk-connection", "", "virtio", "set disk connection('virtio' or 'ide')")
	fs.IntVarP(&serverBuildParam.DiskSize, "disk-size", "", 20, "set disk size(GB)")
	fs.VarP(newIDValue(0, &serverBuildParam.SourceArchiveId), "source-archive-id", "", "set source disk ID")
	fs.VarP(newIDValue(0, &serverBuildParam.SourceDiskId), "source-disk-id", "", "set source disk ID")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &serverBuildParam.DistantFrom), "distant-from", "", "set distant from disk IDs")
	fs.VarP(newIDValue(0, &serverBuildParam.DiskId), "disk-id", "", "set connect disk ID")
	fs.VarP(newIDValue(0, &serverBuildParam.ISOImageId), "iso-image-id", "", "set iso-image ID")
	fs.StringVarP(&serverBuildParam.NetworkMode, "network-mode", "", "shared", "network connection mode[shared/switch/disconnect/none]")
	fs.StringVarP(&serverBuildParam.InterfaceDriver, "interface-driver", "", "virtio", "set interface driver[virtio/e1000]")
	fs.VarP(newIDValue(0, &serverBuildParam.PacketFilterId), "packet-filter-id", "", "set packet filter ID")
	fs.VarP(newIDValue(0, &serverBuildParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.StringVarP(&serverBuildParam.Hostname, "hostname", "", "", "set hostname")
	fs.StringVarP(&serverBuildParam.Password, "password", "", "", "set password")
	fs.BoolVarP(&serverBuildParam.DisablePasswordAuth, "disable-password-auth", "", false, "disable password auth on SSH")
	fs.StringVarP(&serverBuildParam.Ipaddress, "ipaddress", "", "", "set ipaddress")
	fs.IntVarP(&serverBuildParam.NwMasklen, "nw-masklen", "", 24, "set ipaddress  prefix")
	fs.StringVarP(&serverBuildParam.DefaultRoute, "default-route", "", "", "set default gateway")
	fs.StringSliceVarP(&serverBuildParam.StartupScripts, "startup-scripts", "", []string{}, "set startup script(s)")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &serverBuildParam.StartupScriptIds), "startup-script-ids", "", "set startup script ID(s)")
	fs.BoolVarP(&serverBuildParam.StartupScriptsEphemeral, "startup-scripts-ephemeral", "", true, "set startup script persist mode")
	fs.StringVarP(&serverBuildParam.SSHKeyMode, "ssh-key-mode", "", "", "ssh-key mode[none/id/generate/upload]")
	fs.StringVarP(&serverBuildParam.SSHKeyName, "ssh-key-name", "", "", "set ssh-key name")
	fs.VarP(newIDSliceValue([]sacloud.ID{}, &serverBuildParam.SSHKeyIds), "ssh-key-ids", "", "set ssh-key ID(s)")
	fs.StringVarP(&serverBuildParam.SSHKeyPassPhrase, "ssh-key-pass-phrase", "", "", "set ssh-key pass phrase")
	fs.StringVarP(&serverBuildParam.SSHKeyDescription, "ssh-key-description", "", "", "set ssh-key description")
	fs.StringVarP(&serverBuildParam.SSHKeyPrivateKeyOutput, "ssh-key-private-key-output", "", "", "set ssh-key privatekey output path")
	fs.StringSliceVarP(&serverBuildParam.SSHKeyPublicKeys, "ssh-key-public-keys", "", []string{}, "set ssh-key public key ")
	fs.StringSliceVarP(&serverBuildParam.SSHKeyPublicKeyFiles, "ssh-key-public-key-files", "", []string{}, "set ssh-key public key file")
	fs.BoolVarP(&serverBuildParam.SSHKeyEphemeral, "ssh-key-ephemeral", "", true, "set ssh-key persist mode")
	fs.StringVarP(&serverBuildParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&serverBuildParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&serverBuildParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &serverBuildParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&serverBuildParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverBuildParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverBuildParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverBuildParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverBuildParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverBuildParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverBuildParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverBuildParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverBuildParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverBuildParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverBuildParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverBuildParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverBuildParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.BoolVarP(&serverBuildParam.UsKeyboard, "us-keyboard", "", false, "use us-keyboard")
	fs.BoolVarP(&serverBuildParam.DisableBootAfterCreate, "disable-boot-after-create", "", false, "boot after create")
	buildFlagsUsage(cmd, serverBuildFlagOrder(cmd))
	return cmd
}

func serverReadCmd() *cobra.Command {
	serverReadParam := params.NewReadServerParam()
	cmd := &cobra.Command{
		Use: "read",

		Short: "Read Server",
		Long:  `Read Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverReadParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverReadParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverReadParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverReadParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerReadTargets(ctx, serverReadParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverReadParam.SetId(id)
				go func(p *params.ReadServerParam) {
					err := funcs.ServerRead(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverReadParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverReadParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverReadParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverReadParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverReadParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverReadParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverReadParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverReadParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverReadParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverReadParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverReadParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverReadParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverReadParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverReadParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverReadParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverReadFlagOrder(cmd))
	return cmd
}

func serverUpdateCmd() *cobra.Command {
	serverUpdateParam := params.NewUpdateServerParam()
	cmd := &cobra.Command{
		Use: "update",

		Short: "Update Server",
		Long:  `Update Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverUpdateParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverUpdateParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverUpdateParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverUpdateParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerUpdateTargets(ctx, serverUpdateParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverUpdateParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("update", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverUpdateParam.SetId(id)
				go func(p *params.UpdateServerParam) {
					err := funcs.ServerUpdate(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverUpdateParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverUpdateParam.InterfaceDriver, "interface-driver", "", "virtio", "set interface driver[virtio/e1000]")
	fs.StringSliceVarP(&serverUpdateParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverUpdateParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&serverUpdateParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&serverUpdateParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &serverUpdateParam.IconId), "icon-id", "", "set Icon ID")
	fs.BoolVarP(&serverUpdateParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverUpdateParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverUpdateParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverUpdateParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverUpdateParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverUpdateParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverUpdateParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverUpdateParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverUpdateParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverUpdateParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverUpdateParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverUpdateParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverUpdateParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverUpdateParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverUpdateFlagOrder(cmd))
	return cmd
}

func serverDeleteCmd() *cobra.Command {
	serverDeleteParam := params.NewDeleteServerParam()
	cmd := &cobra.Command{
		Use:     "delete",
		Aliases: []string{"rm"},
		Short:   "Delete Server",
		Long:    `Delete Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverDeleteParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverDeleteParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverDeleteParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverDeleteParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerDeleteTargets(ctx, serverDeleteParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverDeleteParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("delete", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverDeleteParam.SetId(id)
				go func(p *params.DeleteServerParam) {
					err := funcs.ServerDelete(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverDeleteParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&serverDeleteParam.Force, "force", "f", false, "forced-shutdown flag if server is running")
	fs.BoolVarP(&serverDeleteParam.WithoutDisk, "without-disk", "", false, "don't delete connected disks with server")
	fs.StringSliceVarP(&serverDeleteParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverDeleteParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverDeleteParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverDeleteParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverDeleteParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverDeleteParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverDeleteParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverDeleteParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverDeleteParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverDeleteParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverDeleteParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverDeleteParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverDeleteParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverDeleteParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverDeleteParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverDeleteFlagOrder(cmd))
	return cmd
}

func serverPlanChangeCmd() *cobra.Command {
	serverPlanChangeParam := params.NewPlanChangeServerParam()
	cmd := &cobra.Command{
		Use: "plan-change",

		Short: "Change server plan(core/memory)",
		Long:  `Change server plan(core/memory)`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverPlanChangeParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverPlanChangeParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverPlanChangeParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverPlanChangeParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerPlanChangeTargets(ctx, serverPlanChangeParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverPlanChangeParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("plan-change", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverPlanChangeParam.SetId(id)
				go func(p *params.PlanChangeServerParam) {
					err := funcs.ServerPlanChange(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverPlanChangeParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.IntVarP(&serverPlanChangeParam.Core, "core", "", 0, "set CPU core count")
	fs.IntVarP(&serverPlanChangeParam.Memory, "memory", "", 0, "set memory size(GB)")
	fs.StringVarP(&serverPlanChangeParam.Commitment, "commitment", "", "standard", "set plan of core assignment")
	fs.StringSliceVarP(&serverPlanChangeParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverPlanChangeParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverPlanChangeParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverPlanChangeParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverPlanChangeParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverPlanChangeParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverPlanChangeParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverPlanChangeParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverPlanChangeParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverPlanChangeParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverPlanChangeParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverPlanChangeParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverPlanChangeParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverPlanChangeParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverPlanChangeParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverPlanChangeFlagOrder(cmd))
	return cmd
}

func serverBootCmd() *cobra.Command {
	serverBootParam := params.NewBootServerParam()
	cmd := &cobra.Command{
		Use:     "boot",
		Aliases: []string{"power-on"},
		Short:   "Boot Server",
		Long:    `Boot Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverBootParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverBootParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverBootParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverBootParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerBootTargets(ctx, serverBootParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverBootParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("boot", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverBootParam.SetId(id)
				go func(p *params.BootServerParam) {
					err := funcs.ServerBoot(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverBootParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverBootParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverBootParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverBootParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverBootParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverBootParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverBootParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverBootParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverBootParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverBootFlagOrder(cmd))
	return cmd
}

func serverShutdownCmd() *cobra.Command {
	serverShutdownParam := params.NewShutdownServerParam()
	cmd := &cobra.Command{
		Use:     "shutdown",
		Aliases: []string{"power-off"},
		Short:   "Shutdown Server",
		Long:    `Shutdown Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverShutdownParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverShutdownParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverShutdownParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverShutdownParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerShutdownTargets(ctx, serverShutdownParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverShutdownParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("shutdown", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverShutdownParam.SetId(id)
				go func(p *params.ShutdownServerParam) {
					err := funcs.ServerShutdown(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverShutdownParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverShutdownParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverShutdownParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverShutdownParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverShutdownParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverShutdownParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverShutdownParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverShutdownParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverShutdownParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverShutdownFlagOrder(cmd))
	return cmd
}

func serverShutdownForceCmd() *cobra.Command {
	serverShutdownForceParam := params.NewShutdownForceServerParam()
	cmd := &cobra.Command{
		Use:     "shutdown-force",
		Aliases: []string{"stop"},
		Short:   "ShutdownForce Server",
		Long:    `ShutdownForce Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverShutdownForceParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverShutdownForceParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverShutdownForceParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverShutdownForceParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerShutdownForceTargets(ctx, serverShutdownForceParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverShutdownForceParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("shutdown-force", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverShutdownForceParam.SetId(id)
				go func(p *params.ShutdownForceServerParam) {
					err := funcs.ServerShutdownForce(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverShutdownForceParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverShutdownForceParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverShutdownForceParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverShutdownForceParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverShutdownForceParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverShutdownForceParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverShutdownForceParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverShutdownForceParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverShutdownForceParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverShutdownForceFlagOrder(cmd))
	return cmd
}

func serverResetCmd() *cobra.Command {
	serverResetParam := params.NewResetServerParam()
	cmd := &cobra.Command{
		Use: "reset",

		Short: "Reset Server",
		Long:  `Reset Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverResetParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverResetParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverResetParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverResetParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerResetTargets(ctx, serverResetParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverResetParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("reset", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverResetParam.SetId(id)
				go func(p *params.ResetServerParam) {
					err := funcs.ServerReset(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverResetParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverResetParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverResetParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverResetParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverResetParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverResetParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverResetParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverResetParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverResetParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverResetFlagOrder(cmd))
	return cmd
}

func serverWaitForBootCmd() *cobra.Command {
	serverWaitForBootParam := params.NewWaitForBootServerParam()
	cmd := &cobra.Command{
		Use: "wait-for-boot",

		Short: "Wait until boot is completed",
		Long:  `Wait until boot is completed`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverWaitForBootParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverWaitForBootParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverWaitForBootParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverWaitForBootParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerWaitForBootTargets(ctx, serverWaitForBootParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverWaitForBootParam.SetId(id)
				go func(p *params.WaitForBootServerParam) {
					err := funcs.ServerWaitForBoot(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverWaitForBootParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverWaitForBootParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverWaitForBootParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverWaitForBootParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverWaitForBootParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverWaitForBootParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverWaitForBootParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverWaitForBootParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverWaitForBootFlagOrder(cmd))
	return cmd
}

func serverWaitForDownCmd() *cobra.Command {
	serverWaitForDownParam := params.NewWaitForDownServerParam()
	cmd := &cobra.Command{
		Use: "wait-for-down",

		Short: "Wait until shutdown is completed",
		Long:  `Wait until shutdown is completed`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverWaitForDownParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverWaitForDownParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverWaitForDownParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverWaitForDownParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerWaitForDownTargets(ctx, serverWaitForDownParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverWaitForDownParam.SetId(id)
				go func(p *params.WaitForDownServerParam) {
					err := funcs.ServerWaitForDown(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverWaitForDownParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverWaitForDownParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverWaitForDownParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverWaitForDownParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverWaitForDownParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverWaitForDownParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverWaitForDownParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverWaitForDownParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverWaitForDownFlagOrder(cmd))
	return cmd
}

func serverSSHCmd() *cobra.Command {
	serverSSHParam := params.NewSSHServerParam()
	cmd := &cobra.Command{
		Use: "ssh",

		Short: "Connect to server by SSH",
		Long:  `Connect to server by SSH`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverSSHParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverSSHParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverSSHParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverSSHParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerSSHTargets(ctx, serverSSHParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverSSHParam.SetId(id)
				go func(p *params.SSHServerParam) {
					err := funcs.ServerSSH(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverSSHParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverSSHParam.Key, "key", "i", "", "private-key file path")
	fs.StringVarP(&serverSSHParam.User, "user", "l", "", "user name")
	fs.IntVarP(&serverSSHParam.Port, "port", "p", 22, "port")
	fs.StringVarP(&serverSSHParam.Password, "password", "", "", "password(or private-key pass phrase)")
	fs.StringSliceVarP(&serverSSHParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverSSHParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverSSHParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverSSHParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverSSHParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverSSHParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.BoolVarP(&serverSSHParam.Quiet, "quiet", "q", false, "disable information messages")
	fs.VarP(newIDValue(0, &serverSSHParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverSSHFlagOrder(cmd))
	return cmd
}

func serverSSHExecCmd() *cobra.Command {
	serverSSHExecParam := params.NewSSHExecServerParam()
	cmd := &cobra.Command{
		Use: "ssh-exec",

		Short: "Execute command on server connected by SSH",
		Long:  `Execute command on server connected by SSH`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverSSHExecParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverSSHExecParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverSSHExecParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverSSHExecParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerSSHExecTargets(ctx, serverSSHExecParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverSSHExecParam.SetId(id)
				go func(p *params.SSHExecServerParam) {
					err := funcs.ServerSSHExec(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverSSHExecParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverSSHExecParam.Key, "key", "i", "", "private-key file path")
	fs.StringVarP(&serverSSHExecParam.User, "user", "l", "", "user name")
	fs.IntVarP(&serverSSHExecParam.Port, "port", "p", 22, "port")
	fs.StringVarP(&serverSSHExecParam.Password, "password", "", "", "password(or private-key pass phrase)")
	fs.StringVarP(&serverSSHExecParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverSSHExecParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverSSHExecParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverSSHExecParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverSSHExecParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.BoolVarP(&serverSSHExecParam.Quiet, "quiet", "q", false, "disable information messages")
	fs.VarP(newIDValue(0, &serverSSHExecParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverSSHExecFlagOrder(cmd))
	return cmd
}

func serverScpCmd() *cobra.Command {
	serverScpParam := params.NewScpServerParam()
	cmd := &cobra.Command{
		Use: "scp",

		Short: "Copy files/directories by SSH",
		Long:  `Copy files/directories by SSH`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverScpParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverScpParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverScpParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverScpParam)
			}

			// confirm
			if !serverScpParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("scp", ctx.IO().In(), ctx.IO().Out())
				if err != nil || !result {
					return err
				}
			}

			return funcs.ServerScp(ctx, serverScpParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverScpParam.Key, "key", "i", "", "private-key file path")
	fs.BoolVarP(&serverScpParam.Recursive, "recursive", "r", false, "set recursive copy flag")
	fs.StringVarP(&serverScpParam.User, "user", "l", "", "user name")
	fs.IntVarP(&serverScpParam.Port, "port", "p", 22, "port")
	fs.StringVarP(&serverScpParam.Password, "password", "", "", "password(or private-key pass phrase)")
	fs.BoolVarP(&serverScpParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverScpParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverScpParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverScpParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverScpParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverScpParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.BoolVarP(&serverScpParam.Quiet, "quiet", "q", false, "disable information messages")
	buildFlagsUsage(cmd, serverScpFlagOrder(cmd))
	return cmd
}

func serverVncCmd() *cobra.Command {
	serverVncParam := params.NewVncServerParam()
	cmd := &cobra.Command{
		Use: "vnc",

		Short: "Open VNC client using the OS's default application",
		Long:  `Open VNC client using the OS's default application`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverVncParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverVncParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverVncParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverVncParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerVncTargets(ctx, serverVncParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverVncParam.SetId(id)
				go func(p *params.VncServerParam) {
					err := funcs.ServerVnc(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverVncParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&serverVncParam.WaitForBoot, "wait-for-boot", "", false, "wait until the server starts up")
	fs.StringSliceVarP(&serverVncParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverVncParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverVncParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverVncParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverVncParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverVncParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverVncParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverVncFlagOrder(cmd))
	return cmd
}

func serverVncInfoCmd() *cobra.Command {
	serverVncInfoParam := params.NewVncInfoServerParam()
	cmd := &cobra.Command{
		Use: "vnc-info",

		Short: "Show VNC proxy information",
		Long:  `Show VNC proxy information`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverVncInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverVncInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverVncInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverVncInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerVncInfoTargets(ctx, serverVncInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverVncInfoParam.SetId(id)
				go func(p *params.VncInfoServerParam) {
					err := funcs.ServerVncInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverVncInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&serverVncInfoParam.WaitForBoot, "wait-for-boot", "", false, "wait until the server starts up")
	fs.StringSliceVarP(&serverVncInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverVncInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverVncInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverVncInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverVncInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverVncInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverVncInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverVncInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverVncInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverVncInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverVncInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverVncInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverVncInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverVncInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverVncInfoFlagOrder(cmd))
	return cmd
}

func serverVncSendCmd() *cobra.Command {
	serverVncSendParam := params.NewVncSendServerParam()
	cmd := &cobra.Command{
		Use: "vnc-send",

		Short: "Send keys over VNC connection",
		Long:  `Send keys over VNC connection`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverVncSendParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverVncSendParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverVncSendParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverVncSendParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerVncSendTargets(ctx, serverVncSendParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverVncSendParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("vnc-send", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverVncSendParam.SetId(id)
				go func(p *params.VncSendServerParam) {
					err := funcs.ServerVncSend(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverVncSendParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverVncSendParam.Command, "command", "c", "", "command(compatible with HashiCorp Packer's boot_command)")
	fs.StringVarP(&serverVncSendParam.CommandFile, "command-file", "f", "", "command file(compatible with HashiCorp Packer's boot_command)")
	fs.BoolVarP(&serverVncSendParam.UseUsKeyboard, "use-us-keyboard", "", false, "use US Keyboard")
	fs.BoolVarP(&serverVncSendParam.Debug, "debug", "d", false, "write debug info")
	fs.BoolVarP(&serverVncSendParam.WaitForBoot, "wait-for-boot", "", false, "wait until the server starts up")
	fs.StringSliceVarP(&serverVncSendParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverVncSendParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverVncSendParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverVncSendParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverVncSendParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverVncSendParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverVncSendParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverVncSendParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverVncSendParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverVncSendParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverVncSendParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverVncSendParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverVncSendParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverVncSendParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverVncSendParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverVncSendFlagOrder(cmd))
	return cmd
}

func serverVncSnapshotCmd() *cobra.Command {
	serverVncSnapshotParam := params.NewVncSnapshotServerParam()
	cmd := &cobra.Command{
		Use: "vnc-snapshot",

		Short: "Capture VNC snapshot",
		Long:  `Capture VNC snapshot`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverVncSnapshotParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverVncSnapshotParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverVncSnapshotParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverVncSnapshotParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerVncSnapshotTargets(ctx, serverVncSnapshotParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverVncSnapshotParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("vnc-snapshot", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverVncSnapshotParam.SetId(id)
				go func(p *params.VncSnapshotServerParam) {
					err := funcs.ServerVncSnapshot(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverVncSnapshotParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&serverVncSnapshotParam.WaitForBoot, "wait-for-boot", "", false, "wait until the server starts up")
	fs.StringVarP(&serverVncSnapshotParam.OutputPath, "output-path", "", "", "snapshot output filepath")
	fs.StringSliceVarP(&serverVncSnapshotParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverVncSnapshotParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverVncSnapshotParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverVncSnapshotParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverVncSnapshotParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverVncSnapshotParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverVncSnapshotParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverVncSnapshotParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverVncSnapshotParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverVncSnapshotParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverVncSnapshotParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverVncSnapshotParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverVncSnapshotParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverVncSnapshotParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverVncSnapshotParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverVncSnapshotFlagOrder(cmd))
	return cmd
}

func serverRemoteDesktopCmd() *cobra.Command {
	serverRemoteDesktopParam := params.NewRemoteDesktopServerParam()
	cmd := &cobra.Command{
		Use:     "remote-desktop",
		Aliases: []string{"rdp"},
		Short:   "Open RDP client using the OS's default application",
		Long:    `Open RDP client using the OS's default application`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverRemoteDesktopParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverRemoteDesktopParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverRemoteDesktopParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverRemoteDesktopParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerRemoteDesktopTargets(ctx, serverRemoteDesktopParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverRemoteDesktopParam.SetId(id)
				go func(p *params.RemoteDesktopServerParam) {
					err := funcs.ServerRemoteDesktop(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverRemoteDesktopParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverRemoteDesktopParam.User, "user", "l", "Administrator", "user name")
	fs.IntVarP(&serverRemoteDesktopParam.Port, "port", "p", 3389, "port")
	fs.StringSliceVarP(&serverRemoteDesktopParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverRemoteDesktopParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverRemoteDesktopParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverRemoteDesktopParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverRemoteDesktopParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverRemoteDesktopParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverRemoteDesktopParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverRemoteDesktopFlagOrder(cmd))
	return cmd
}

func serverRemoteDesktopInfoCmd() *cobra.Command {
	serverRemoteDesktopInfoParam := params.NewRemoteDesktopInfoServerParam()
	cmd := &cobra.Command{
		Use:     "remote-desktop-info",
		Aliases: []string{"rdp-info"},
		Short:   "Show RDP information(.rdp)",
		Long:    `Show RDP information(.rdp)`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverRemoteDesktopInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverRemoteDesktopInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverRemoteDesktopInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverRemoteDesktopInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerRemoteDesktopInfoTargets(ctx, serverRemoteDesktopInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverRemoteDesktopInfoParam.SetId(id)
				go func(p *params.RemoteDesktopInfoServerParam) {
					err := funcs.ServerRemoteDesktopInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverRemoteDesktopInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverRemoteDesktopInfoParam.User, "user", "l", "Administrator", "user name")
	fs.IntVarP(&serverRemoteDesktopInfoParam.Port, "port", "p", 3389, "port")
	fs.StringSliceVarP(&serverRemoteDesktopInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverRemoteDesktopInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverRemoteDesktopInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverRemoteDesktopInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverRemoteDesktopInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverRemoteDesktopInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverRemoteDesktopInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverRemoteDesktopInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverRemoteDesktopInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverRemoteDesktopInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverRemoteDesktopInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverRemoteDesktopInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverRemoteDesktopInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverRemoteDesktopInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverRemoteDesktopInfoFlagOrder(cmd))
	return cmd
}

func serverDiskInfoCmd() *cobra.Command {
	serverDiskInfoParam := params.NewDiskInfoServerParam()
	cmd := &cobra.Command{
		Use:     "disk-info",
		Aliases: []string{"disk-list"},
		Short:   "Show information of disk(s) connected to server",
		Long:    `Show information of disk(s) connected to server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverDiskInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverDiskInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverDiskInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverDiskInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerDiskInfoTargets(ctx, serverDiskInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverDiskInfoParam.SetId(id)
				go func(p *params.DiskInfoServerParam) {
					err := funcs.ServerDiskInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverDiskInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverDiskInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverDiskInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverDiskInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverDiskInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverDiskInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverDiskInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverDiskInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverDiskInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverDiskInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverDiskInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverDiskInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverDiskInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverDiskInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverDiskInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverDiskInfoFlagOrder(cmd))
	return cmd
}

func serverDiskConnectCmd() *cobra.Command {
	serverDiskConnectParam := params.NewDiskConnectServerParam()
	cmd := &cobra.Command{
		Use: "disk-connect",

		Short: "Connect disk to server",
		Long:  `Connect disk to server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverDiskConnectParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverDiskConnectParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverDiskConnectParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverDiskConnectParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerDiskConnectTargets(ctx, serverDiskConnectParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverDiskConnectParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("disk-connect", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverDiskConnectParam.SetId(id)
				go func(p *params.DiskConnectServerParam) {
					err := funcs.ServerDiskConnect(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverDiskConnectParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &serverDiskConnectParam.DiskId), "disk-id", "", "set target disk ID")
	fs.StringSliceVarP(&serverDiskConnectParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverDiskConnectParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverDiskConnectParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverDiskConnectParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverDiskConnectParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverDiskConnectParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverDiskConnectParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverDiskConnectParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverDiskConnectFlagOrder(cmd))
	return cmd
}

func serverDiskDisconnectCmd() *cobra.Command {
	serverDiskDisconnectParam := params.NewDiskDisconnectServerParam()
	cmd := &cobra.Command{
		Use: "disk-disconnect",

		Short: "Disconnect disk from server",
		Long:  `Disconnect disk from server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverDiskDisconnectParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverDiskDisconnectParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverDiskDisconnectParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverDiskDisconnectParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerDiskDisconnectTargets(ctx, serverDiskDisconnectParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverDiskDisconnectParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("disk-disconnect", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverDiskDisconnectParam.SetId(id)
				go func(p *params.DiskDisconnectServerParam) {
					err := funcs.ServerDiskDisconnect(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverDiskDisconnectParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &serverDiskDisconnectParam.DiskId), "disk-id", "", "set target disk ID")
	fs.StringSliceVarP(&serverDiskDisconnectParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverDiskDisconnectParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverDiskDisconnectParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverDiskDisconnectParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverDiskDisconnectParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverDiskDisconnectParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverDiskDisconnectParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverDiskDisconnectParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverDiskDisconnectFlagOrder(cmd))
	return cmd
}

func serverInterfaceInfoCmd() *cobra.Command {
	serverInterfaceInfoParam := params.NewInterfaceInfoServerParam()
	cmd := &cobra.Command{
		Use:     "interface-info",
		Aliases: []string{"interface-list"},
		Short:   "Show information of NIC(s) connected to server",
		Long:    `Show information of NIC(s) connected to server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverInterfaceInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverInterfaceInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverInterfaceInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverInterfaceInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerInterfaceInfoTargets(ctx, serverInterfaceInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverInterfaceInfoParam.SetId(id)
				go func(p *params.InterfaceInfoServerParam) {
					err := funcs.ServerInterfaceInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverInterfaceInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverInterfaceInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverInterfaceInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverInterfaceInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverInterfaceInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverInterfaceInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverInterfaceInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverInterfaceInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverInterfaceInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverInterfaceInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverInterfaceInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverInterfaceInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverInterfaceInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverInterfaceInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverInterfaceInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverInterfaceInfoFlagOrder(cmd))
	return cmd
}

func serverInterfaceAddForInternetCmd() *cobra.Command {
	serverInterfaceAddForInternetParam := params.NewInterfaceAddForInternetServerParam()
	cmd := &cobra.Command{
		Use: "interface-add-for-internet",

		Short: "Create and connect NIC connected to the internet",
		Long:  `Create and connect NIC connected to the internet`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverInterfaceAddForInternetParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverInterfaceAddForInternetParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverInterfaceAddForInternetParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverInterfaceAddForInternetParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerInterfaceAddForInternetTargets(ctx, serverInterfaceAddForInternetParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverInterfaceAddForInternetParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-add-for-internet", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverInterfaceAddForInternetParam.SetId(id)
				go func(p *params.InterfaceAddForInternetServerParam) {
					err := funcs.ServerInterfaceAddForInternet(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverInterfaceAddForInternetParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.BoolVarP(&serverInterfaceAddForInternetParam.WithoutDiskEdit, "without-disk-edit", "", false, "set skip edit-disk flag. if true, don't call DiskEdit API after interface added")
	fs.StringSliceVarP(&serverInterfaceAddForInternetParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverInterfaceAddForInternetParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverInterfaceAddForInternetParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverInterfaceAddForInternetParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverInterfaceAddForInternetParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverInterfaceAddForInternetParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverInterfaceAddForInternetParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverInterfaceAddForInternetParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverInterfaceAddForInternetFlagOrder(cmd))
	return cmd
}

func serverInterfaceAddForRouterCmd() *cobra.Command {
	serverInterfaceAddForRouterParam := params.NewInterfaceAddForRouterServerParam()
	cmd := &cobra.Command{
		Use: "interface-add-for-router",

		Short: "Create and connect NIC connected to the router",
		Long:  `Create and connect NIC connected to the router`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverInterfaceAddForRouterParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverInterfaceAddForRouterParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverInterfaceAddForRouterParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverInterfaceAddForRouterParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerInterfaceAddForRouterTargets(ctx, serverInterfaceAddForRouterParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverInterfaceAddForRouterParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-add-for-router", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverInterfaceAddForRouterParam.SetId(id)
				go func(p *params.InterfaceAddForRouterServerParam) {
					err := funcs.ServerInterfaceAddForRouter(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverInterfaceAddForRouterParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &serverInterfaceAddForRouterParam.SwitchId), "switch-id", "", "set connect switch(connected to router) ID")
	fs.BoolVarP(&serverInterfaceAddForRouterParam.WithoutDiskEdit, "without-disk-edit", "", false, "set skip edit-disk flag. if true, don't call DiskEdit API after interface added")
	fs.StringVarP(&serverInterfaceAddForRouterParam.Ipaddress, "ipaddress", "", "", "set ipaddress")
	fs.StringVarP(&serverInterfaceAddForRouterParam.DefaultRoute, "default-route", "", "", "set default gateway")
	fs.IntVarP(&serverInterfaceAddForRouterParam.NwMasklen, "nw-masklen", "", 24, "set ipaddress  prefix")
	fs.StringSliceVarP(&serverInterfaceAddForRouterParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverInterfaceAddForRouterParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverInterfaceAddForRouterParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverInterfaceAddForRouterParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverInterfaceAddForRouterParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverInterfaceAddForRouterParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverInterfaceAddForRouterParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverInterfaceAddForRouterParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverInterfaceAddForRouterFlagOrder(cmd))
	return cmd
}

func serverInterfaceAddForSwitchCmd() *cobra.Command {
	serverInterfaceAddForSwitchParam := params.NewInterfaceAddForSwitchServerParam()
	cmd := &cobra.Command{
		Use: "interface-add-for-switch",

		Short: "Create and connect NIC connected to the switch",
		Long:  `Create and connect NIC connected to the switch`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverInterfaceAddForSwitchParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverInterfaceAddForSwitchParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverInterfaceAddForSwitchParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverInterfaceAddForSwitchParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerInterfaceAddForSwitchTargets(ctx, serverInterfaceAddForSwitchParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverInterfaceAddForSwitchParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-add-for-switch", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverInterfaceAddForSwitchParam.SetId(id)
				go func(p *params.InterfaceAddForSwitchServerParam) {
					err := funcs.ServerInterfaceAddForSwitch(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverInterfaceAddForSwitchParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &serverInterfaceAddForSwitchParam.SwitchId), "switch-id", "", "set connect switch ID")
	fs.BoolVarP(&serverInterfaceAddForSwitchParam.WithoutDiskEdit, "without-disk-edit", "", false, "set skip edit-disk flag. if true, don't call DiskEdit API after interface added")
	fs.StringVarP(&serverInterfaceAddForSwitchParam.Ipaddress, "ipaddress", "", "", "set ipaddress")
	fs.StringVarP(&serverInterfaceAddForSwitchParam.DefaultRoute, "default-route", "", "", "set default gateway")
	fs.IntVarP(&serverInterfaceAddForSwitchParam.NwMasklen, "nw-masklen", "", 24, "set ipaddress  prefix")
	fs.StringSliceVarP(&serverInterfaceAddForSwitchParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverInterfaceAddForSwitchParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverInterfaceAddForSwitchParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverInterfaceAddForSwitchParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverInterfaceAddForSwitchParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverInterfaceAddForSwitchParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverInterfaceAddForSwitchParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverInterfaceAddForSwitchParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverInterfaceAddForSwitchFlagOrder(cmd))
	return cmd
}

func serverInterfaceAddDisconnectedCmd() *cobra.Command {
	serverInterfaceAddDisconnectedParam := params.NewInterfaceAddDisconnectedServerParam()
	cmd := &cobra.Command{
		Use: "interface-add-disconnected",

		Short: "Create and connect a disconnected NIC",
		Long:  `Create and connect a disconnected NIC`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverInterfaceAddDisconnectedParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverInterfaceAddDisconnectedParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverInterfaceAddDisconnectedParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverInterfaceAddDisconnectedParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerInterfaceAddDisconnectedTargets(ctx, serverInterfaceAddDisconnectedParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverInterfaceAddDisconnectedParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("interface-add-disconnected", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverInterfaceAddDisconnectedParam.SetId(id)
				go func(p *params.InterfaceAddDisconnectedServerParam) {
					err := funcs.ServerInterfaceAddDisconnected(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverInterfaceAddDisconnectedParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverInterfaceAddDisconnectedParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverInterfaceAddDisconnectedParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverInterfaceAddDisconnectedParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverInterfaceAddDisconnectedParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverInterfaceAddDisconnectedParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverInterfaceAddDisconnectedParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverInterfaceAddDisconnectedParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverInterfaceAddDisconnectedParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverInterfaceAddDisconnectedFlagOrder(cmd))
	return cmd
}

func serverISOInfoCmd() *cobra.Command {
	serverISOInfoParam := params.NewISOInfoServerParam()
	cmd := &cobra.Command{
		Use: "iso-info",

		Short: "Show information of ISO-Image inserted to server",
		Long:  `Show information of ISO-Image inserted to server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverISOInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverISOInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverISOInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverISOInfoParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerISOInfoTargets(ctx, serverISOInfoParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverISOInfoParam.SetId(id)
				go func(p *params.ISOInfoServerParam) {
					err := funcs.ServerISOInfo(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverISOInfoParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverISOInfoParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverISOInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverISOInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverISOInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverISOInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverISOInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverISOInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverISOInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverISOInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverISOInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverISOInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverISOInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverISOInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverISOInfoParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverISOInfoFlagOrder(cmd))
	return cmd
}

func serverISOInsertCmd() *cobra.Command {
	serverISOInsertParam := params.NewISOInsertServerParam()
	cmd := &cobra.Command{
		Use: "iso-insert",

		Short: "Insert ISO-Image to server",
		Long:  `Insert ISO-Image to server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverISOInsertParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverISOInsertParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverISOInsertParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverISOInsertParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerISOInsertTargets(ctx, serverISOInsertParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverISOInsertParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("iso-insert", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverISOInsertParam.SetId(id)
				go func(p *params.ISOInsertServerParam) {
					err := funcs.ServerISOInsert(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverISOInsertParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.VarP(newIDValue(0, &serverISOInsertParam.ISOImageId), "iso-image-id", "", "set iso-image ID")
	fs.IntVarP(&serverISOInsertParam.Size, "size", "", 5, "set iso size(GB)")
	fs.StringVarP(&serverISOInsertParam.ISOFile, "iso-file", "", "", "set iso image file")
	fs.StringVarP(&serverISOInsertParam.Name, "name", "", "", "set resource display name")
	fs.StringVarP(&serverISOInsertParam.Description, "description", "", "", "set resource description")
	fs.StringSliceVarP(&serverISOInsertParam.Tags, "tags", "", []string{}, "set resource tags")
	fs.VarP(newIDValue(0, &serverISOInsertParam.IconId), "icon-id", "", "set Icon ID")
	fs.StringSliceVarP(&serverISOInsertParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverISOInsertParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverISOInsertParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverISOInsertParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverISOInsertParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverISOInsertParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverISOInsertParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverISOInsertParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverISOInsertFlagOrder(cmd))
	return cmd
}

func serverISOEjectCmd() *cobra.Command {
	serverISOEjectParam := params.NewISOEjectServerParam()
	cmd := &cobra.Command{
		Use: "iso-eject",

		Short: "Eject ISO-Image from server",
		Long:  `Eject ISO-Image from server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverISOEjectParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverISOEjectParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverISOEjectParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverISOEjectParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerISOEjectTargets(ctx, serverISOEjectParam)
			if err != nil {
				return err
			}

			// confirm
			if !serverISOEjectParam.Assumeyes {
				if !utils.IsTerminal() {
					return errors.New("the confirm dialog cannot be used without the terminal. Please use --assumeyes(-y) option")
				}
				result, err := utils.ConfirmContinue("iso-eject", ctx.IO().In(), ctx.IO().Out(), ids...)
				if err != nil || !result {
					return err
				}
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverISOEjectParam.SetId(id)
				go func(p *params.ISOEjectServerParam) {
					err := funcs.ServerISOEject(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverISOEjectParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringSliceVarP(&serverISOEjectParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.BoolVarP(&serverISOEjectParam.Assumeyes, "assumeyes", "y", false, "Assume that the answer to any question which would be asked is yes")
	fs.StringVarP(&serverISOEjectParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverISOEjectParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverISOEjectParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverISOEjectParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverISOEjectParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.VarP(newIDValue(0, &serverISOEjectParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverISOEjectFlagOrder(cmd))
	return cmd
}

func serverMonitorCPUCmd() *cobra.Command {
	serverMonitorCPUParam := params.NewMonitorCPUServerParam()
	cmd := &cobra.Command{
		Use: "monitor-cpu",

		Short: "Collect CPU monitor values",
		Long:  `Collect CPU monitor values`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverMonitorCPUParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverMonitorCPUParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverMonitorCPUParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverMonitorCPUParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerMonitorCPUTargets(ctx, serverMonitorCPUParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverMonitorCPUParam.SetId(id)
				go func(p *params.MonitorCPUServerParam) {
					err := funcs.ServerMonitorCPU(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverMonitorCPUParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverMonitorCPUParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&serverMonitorCPUParam.End, "end", "", "", "set end-time")
	fs.StringVarP(&serverMonitorCPUParam.KeyFormat, "key-format", "", "sakuracloud.server.{{.ID}}.cpu", "set monitoring value key-format")
	fs.StringSliceVarP(&serverMonitorCPUParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverMonitorCPUParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverMonitorCPUParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverMonitorCPUParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverMonitorCPUParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverMonitorCPUParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverMonitorCPUParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverMonitorCPUParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverMonitorCPUParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverMonitorCPUParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverMonitorCPUParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverMonitorCPUParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverMonitorCPUParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverMonitorCPUParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverMonitorCPUFlagOrder(cmd))
	return cmd
}

func serverMonitorNicCmd() *cobra.Command {
	serverMonitorNicParam := params.NewMonitorNicServerParam()
	cmd := &cobra.Command{
		Use: "monitor-nic",

		Short: "Collect NIC(s) monitor values",
		Long:  `Collect NIC(s) monitor values`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverMonitorNicParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverMonitorNicParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverMonitorNicParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverMonitorNicParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerMonitorNicTargets(ctx, serverMonitorNicParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverMonitorNicParam.SetId(id)
				go func(p *params.MonitorNicServerParam) {
					err := funcs.ServerMonitorNic(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverMonitorNicParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverMonitorNicParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&serverMonitorNicParam.End, "end", "", "", "set end-time")
	fs.Int64SliceVarP(&serverMonitorNicParam.Index, "index", "", []int64{}, "target index(es)")
	fs.StringVarP(&serverMonitorNicParam.KeyFormat, "key-format", "", "sakuracloud.server.{{.ID}}.nic.{{.Index}}", "set monitoring value key-format")
	fs.StringSliceVarP(&serverMonitorNicParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverMonitorNicParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverMonitorNicParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverMonitorNicParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverMonitorNicParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverMonitorNicParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverMonitorNicParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverMonitorNicParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverMonitorNicParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverMonitorNicParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverMonitorNicParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverMonitorNicParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverMonitorNicParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverMonitorNicParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverMonitorNicFlagOrder(cmd))
	return cmd
}

func serverMonitorDiskCmd() *cobra.Command {
	serverMonitorDiskParam := params.NewMonitorDiskServerParam()
	cmd := &cobra.Command{
		Use: "monitor-disk",

		Short: "Collect Disk(s) monitor values",
		Long:  `Collect Disk(s) monitor values`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverMonitorDiskParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverMonitorDiskParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverMonitorDiskParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverMonitorDiskParam)
			}

			// parse ID or Name arguments(generated by tools/gen-resource-finder)
			ids, err := findServerMonitorDiskTargets(ctx, serverMonitorDiskParam)
			if err != nil {
				return err
			}

			// TODO v1で置き換えるまでの暫定実装
			var wg sync.WaitGroup
			var errs []error
			for _, id := range ids {
				wg.Add(1)
				serverMonitorDiskParam.SetId(id)
				go func(p *params.MonitorDiskServerParam) {
					err := funcs.ServerMonitorDisk(ctx, p.ToV0())
					if err != nil {
						errs = append(errs, err)
					}
					wg.Done()
				}(serverMonitorDiskParam)
			}
			wg.Wait()
			return command.FlattenErrors(errs)

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverMonitorDiskParam.Start, "start", "", "", "set start-time")
	fs.StringVarP(&serverMonitorDiskParam.End, "end", "", "", "set end-time")
	fs.Int64SliceVarP(&serverMonitorDiskParam.Index, "index", "", []int64{}, "target index(es)")
	fs.StringVarP(&serverMonitorDiskParam.KeyFormat, "key-format", "", "sakuracloud.server.{{.ID}}.disk.{{.Index}}", "set monitoring value key-format")
	fs.StringSliceVarP(&serverMonitorDiskParam.Selector, "selector", "", []string{}, "Set target filter by tag")
	fs.StringVarP(&serverMonitorDiskParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverMonitorDiskParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverMonitorDiskParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverMonitorDiskParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverMonitorDiskParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverMonitorDiskParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverMonitorDiskParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverMonitorDiskParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverMonitorDiskParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverMonitorDiskParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverMonitorDiskParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverMonitorDiskParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	fs.VarP(newIDValue(0, &serverMonitorDiskParam.Id), "id", "", "Set target ID")
	buildFlagsUsage(cmd, serverMonitorDiskFlagOrder(cmd))
	return cmd
}

func serverMaintenanceInfoCmd() *cobra.Command {
	serverMaintenanceInfoParam := params.NewMaintenanceInfoServerParam()
	cmd := &cobra.Command{
		Use: "maintenance-info",

		Short: "MaintenanceInfo Server",
		Long:  `MaintenanceInfo Server`,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return serverMaintenanceInfoParam.Initialize(newParamsAdapter(cmd.Flags()), args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			ctx, err := newCLIContext(globalFlags(), args, serverMaintenanceInfoParam)
			if err != nil {
				return err
			}

			// Experiment warning
			ctx.PrintWarning("")

			if serverMaintenanceInfoParam.GenerateSkeleton {
				return generateSkeleton(ctx, serverMaintenanceInfoParam)
			}

			return funcs.ServerMaintenanceInfo(ctx, serverMaintenanceInfoParam.ToV0())

		},
	}

	fs := cmd.Flags()
	fs.StringVarP(&serverMaintenanceInfoParam.ParamTemplate, "param-template", "", "", "Set input parameter from string(JSON)")
	fs.StringVarP(&serverMaintenanceInfoParam.Parameters, "parameters", "", "", "Set input parameters from JSON string")
	fs.StringVarP(&serverMaintenanceInfoParam.ParamTemplateFile, "param-template-file", "", "", "Set input parameter from file")
	fs.StringVarP(&serverMaintenanceInfoParam.ParameterFile, "parameter-file", "", "", "Set input parameters from file")
	fs.BoolVarP(&serverMaintenanceInfoParam.GenerateSkeleton, "generate-skeleton", "", false, "Output skelton of parameter JSON")
	fs.StringVarP(&serverMaintenanceInfoParam.OutputType, "output-type", "o", "", "Output type [table/json/csv/tsv]")
	fs.StringSliceVarP(&serverMaintenanceInfoParam.Column, "column", "", []string{}, "Output columns(using when '--output-type' is in [csv/tsv] only)")
	fs.BoolVarP(&serverMaintenanceInfoParam.Quiet, "quiet", "q", false, "Only display IDs")
	fs.StringVarP(&serverMaintenanceInfoParam.Format, "format", "", "", "Output format(see text/template package document for detail)")
	fs.StringVarP(&serverMaintenanceInfoParam.FormatFile, "format-file", "", "", "Output format from file(see text/template package document for detail)")
	fs.StringVarP(&serverMaintenanceInfoParam.Query, "query", "", "", "JMESPath query(using when '--output-type' is json only)")
	fs.StringVarP(&serverMaintenanceInfoParam.QueryFile, "query-file", "", "", "JMESPath query from file(using when '--output-type' is json only)")
	buildFlagsUsage(cmd, serverMaintenanceInfoFlagOrder(cmd))
	return cmd
}

func init() {
	parent := serverCmd()
	parent.AddCommand(serverListCmd())
	parent.AddCommand(serverBuildCmd())
	parent.AddCommand(serverReadCmd())
	parent.AddCommand(serverUpdateCmd())
	parent.AddCommand(serverDeleteCmd())
	parent.AddCommand(serverPlanChangeCmd())
	parent.AddCommand(serverBootCmd())
	parent.AddCommand(serverShutdownCmd())
	parent.AddCommand(serverShutdownForceCmd())
	parent.AddCommand(serverResetCmd())
	parent.AddCommand(serverWaitForBootCmd())
	parent.AddCommand(serverWaitForDownCmd())
	parent.AddCommand(serverSSHCmd())
	parent.AddCommand(serverSSHExecCmd())
	parent.AddCommand(serverScpCmd())
	parent.AddCommand(serverVncCmd())
	parent.AddCommand(serverVncInfoCmd())
	parent.AddCommand(serverVncSendCmd())
	parent.AddCommand(serverVncSnapshotCmd())
	parent.AddCommand(serverRemoteDesktopCmd())
	parent.AddCommand(serverRemoteDesktopInfoCmd())
	parent.AddCommand(serverDiskInfoCmd())
	parent.AddCommand(serverDiskConnectCmd())
	parent.AddCommand(serverDiskDisconnectCmd())
	parent.AddCommand(serverInterfaceInfoCmd())
	parent.AddCommand(serverInterfaceAddForInternetCmd())
	parent.AddCommand(serverInterfaceAddForRouterCmd())
	parent.AddCommand(serverInterfaceAddForSwitchCmd())
	parent.AddCommand(serverInterfaceAddDisconnectedCmd())
	parent.AddCommand(serverISOInfoCmd())
	parent.AddCommand(serverISOInsertCmd())
	parent.AddCommand(serverISOEjectCmd())
	parent.AddCommand(serverMonitorCPUCmd())
	parent.AddCommand(serverMonitorNicCmd())
	parent.AddCommand(serverMonitorDiskCmd())
	parent.AddCommand(serverMaintenanceInfoCmd())
	buildCommandsUsage(parent, serverCommandOrder(parent))
	rootCmd.AddCommand(parent)
}
